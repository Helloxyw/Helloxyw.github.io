---
title: 第一次笔试经历
date: 2017-03-21 21:59:53
tags: Java
---

---

今天博主参加了第一次笔试,所以特别记录下：

 其实今天这个笔试博主是抱着去试试水的态度去感受下笔试是怎么个过程，所以就约了室友一起去。具体是xx公司就不细说了，稍微参观了下，貌似挺大的，感觉里面参加培训的也不少。
 
下面说些整个的流程:
<center>
![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1490114033499&di=9bdfd99f7cd3e32ac8061f7e218a979a&imgtype=0&src=http%3A%2F%2Fs1.51cto.com%2Fimages%2F201510%2Ff7887c7220a49d19780910d918c37c24a4a9fa_big.jpg)
</center>

<!--more-->

1. 首先在接待那里填了个表，然后在一旁坐着等人来面试.

2. 等了十几分钟,面试官来了我们交上了各自的简历.

3. 然后叫我们自我介绍一下啥的 . 因为接待面试的不是搞技术的,所以就没有太多扯具体技术方面。只是大概说了下自己的学习经历以及主攻方向等等。

4. 笔试。

<b>这里具体说说笔试题目</b>


&nbsp;&nbsp;因为没太多打算真的在这家公司实习，所以前两天根本没有刷面试题，百分百纯裸考。在细细做了大概半小时后，我交了我的笔试题给一个专业的(个人猜测可能是公司专门负责培训的)老师修改.说实话面试题不难，相应的知识点和技能点都接触过，但根本记不起来或者无从解答.一开始是25分的一段英文文档翻译，感觉翻译得还行，大概意思语句都翻译到了，也不会太生硬。拿了20分吧,那老师提了句"你英语挺好啊"(内心OS:英语六级不是白过的好吧).

&nbsp;&nbsp;之后的面试题有网络掩码，网关，以及怎么解决客户电脑出故障等问题。

&nbsp;&nbsp;终于来到了Java专业题.这里做的极差，以至于那个老师都问我你真的学过Java吗～平心而论，考的很基础，也不算难。但奈何裸考，真的答不上来。这里记录下被问到的几个问题:

 > <h2>heap和stack的区别.</h2>
 
<strong>堆栈的概念：</strong>
	
&nbsp;&nbsp;堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，队列优先,先进先出（`FIFO—first in first out`）。栈，先进后出(`FILO—First-In/Last-Out`)。 

<b>Java堆和栈的区别：</b>
	
  &nbsp;&nbsp;　栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。
　　在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。
　　堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 

[详解可参考这篇文章 ](http://blog.csdn.net/u014306011/article/details/51044091)

 
 ><h2>String s = new String("xyz");这里共产生了几个对象.</h2>
   
 &nbsp;&nbsp;在java中除了8中基本类型外，其他的都是类对象以及其引用。所以 "xyz "在java中它是一个String对象.对于string类对象来说他的对象值是不能修改的，也就是具有不变性。 

举个例子:

	String   s= "Hello "; 
	s= "Java "; 
	String   s1= "Hello "; 
	String   s2=new   String( "Hello "); 
	
很多人可能会问：s所引用的string对象不是被修改了吗？之前所说的不变性，去那里了啊？ 

这里解释下:

在jvm的工作过程中，会创建一片的内存空间专门存入string对象。我们把这片内存空间叫做string池(String Pool)。 

`String   s= "Hello "`;当jvm看到 `"Hello "`，在string池创建string对象存储它，并将他的引用返回给s。 

`s= "Java "`，当jvm看到 `"Java "`，在string池创建新的string对象存储它，再把新建的string对象的引用返回给s。而原先的 `"Hello "`仍然在string池内。没有消失，他是不能被修改的。 

 所以我们仅仅是改变了s的引用，而没有改变他所引用的对象，因为string对象的值是不能被修改的。 
 
 `String   s1= "Hello ";`jvm首先在string池内里面看找不找到字符串 "Hello ",找到,返回他的引用给s1，否则,创建新的string对象，放到string池里。这里由于s= "Hello "了,对象已经被引用，所以依据规则s和s1都是引用同一个对象。所以  s  = =  s1将返回true。(= =对于非基本类型，是比较两引用是否引用内存中的同一个对象) 

`String   s2=String( "Hello ")`;jvm首先在string池内里面看找不找到字符串 "Hello ",找到,不做任何事情，否则,创建新的string对象，放到string池里面。由于遇到了new，还会在内存上（不是string池里面）创建string对象存储 "Hello "，并将内存上的（不是string池内的）string对象返回给s2。所以s==s2将返回false，不是引用同一个对象。 
好现在我们看题目： 

`String   s   =   new   String( "xyz ")`; 
首先在string池内找，找到？不创建string对象，否则创建，   这样就一个string对象 
遇到new运算符号了，在内存上创建string对象，并将其返回给s，又一个对象 

所以总共是2个对象 

而为什么在网上都说`String s=new String("test");`创建了2个对象？那可能因为它就写这么一句代码，误让人默认的认为执行代码之前并不实例任何一个String对象过（也许 很多人不会这么想，），跟着别人或者不经思考的就说2个，或是说存放在栈内存中专门存放String对象引用的s变量是一个对象！实在不可原谅！ 

还有疑问的可以参考这篇文章[Java的内存机制](http://blog.csdn.net/u014306011/article/details/51068495).

><h2>String 和 StringBuffe的区别</h2>
	
在Java中有三个类来负责字符的操作：

1、Character是进行单个字符的操作

2、String是对一串字符进行操作，是不可变类。

3、StringBuffer是对一串字符进行操作，是可变类。

String

是对象不是原始类型

为不可变对象，一旦创建就不能修改它的值

对于已经存在的String的对象的修改都是重新创建一个新的对象，然后把值保存进去（旧的值会被回收）。String是final类，不能被继承

StringBuffer是一个可变对象，当对她进行修改不会像String那样重新建立对象，它只能通过构造函数来建立。

	StringBuffer strBuffer = new StringBuffer();

注意，不能通过"="对其进行赋值

	strBuffer =“hello”//错误

象被建立以后,在内存中就会分配内存空间,并初始保存一个null.向StringBuffer
中付值的时候可以通过它的append方法.

	strBuffer.append("hello");

><h2>ArrayList和Vector的区别</h2>



数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半

同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的 

><h2>struts工作原理</h2>
<center>
![](http://wiki.jikexueyuan.com/project/struts-2/images/struts_2_architecture.gif)
</center>

<b>请求生命周期</b>

以上面的图为基础，它可以解释 Struts 2 中用户的请求的生命周期，如下所示：
   
  * 为了请求一些资源（即页面），用户发送请求到服务器。

 * FilterDispatcher 查看请求，然后确定适当的动作。

 * 配置的拦截器功能适用于如验证，文件上传等等。

 * 执行选定的动作来执行所请求的操作。

  * 再次，如果需要，配置的拦截器应用于做任何后处理。
  * 最后由视图准备好的结果，并且将结果返回给用户。

> <h2>Forward 和 Redirect 的区别</h2>

 直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。

　　间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。
　　
举个通俗的例子：

　　  直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；

　　间接转发就相当于："A找B借钱，B说没有，让A去找C借"。
　　
><h2>Hibernate工作原理以及我们为什么要用Hibernate</h2>

<b>hibernate 简介：</b>

hibernate是一个开源框架，它是对象关联关系映射(ORM)的框架，它对JDBC做了轻量级的封装，而我们Java程序员可以使用面向对象的思想来操纵数据库。

hibernate核心接口

* session：负责被持久化对象CRUD操作

* sessionFactory:负责初始化hibernate，创建session对象

* configuration:负责配置并启动hibernate，创建SessionFactory

* Transaction:负责事物相关的操作

* Query和Criteria接口：负责执行各种数据库查询

<b>hibernate工作原理：</b>

1. 通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件

2. 由hibernate.cfg.xml中的<mapping resource="com/xx/User.hbm.xml"/>读取并解析映射信息

3. 通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory

4. Session session = sf.openSession();//打开Sesssion

5. Transaction tx = session.beginTransaction();//创建并启动事务Transation

6. persistent operate操作数据，持久化操作

7. tx.commit();//提交事务

8. 关闭Session

9. 关闭SesstionFactory


<b>为什么要用hibernate：</b>

1. 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。

2. Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作

3. hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。

4. hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。
　
以上大概就是今天的面试经历了，讲真虽然嘴上说着是因为没好好准备，没刷题balabala...归根结底还是自己太菜了！！！如果真的技术很牛逼的话,也就不需要这所谓的去试试水了.道阻且跻，且行且珍惜 . 不忘初心，方得始终.共勉～
