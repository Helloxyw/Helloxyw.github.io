---
title: GC算法
date: 2020-04-08 
tags: GC
---

GC: 垃圾收集。这里的垃圾是指在系统运行过程中产生的一些无用的对象，这些对象占据着一定的内存空间，如果长期不释放，可能导致OOM

GC对象是 Java堆和方法区

![](https://ionutbalosin.com/wp-content/uploads/2019/12/java-garbage-collector-types.png)
<!--more-->

1. 引用计数算法 （效率高，实现简单，但存在循环引用问题）
2. 根搜索算法 当GCRoots到某一个对象不达时，认为这个对象可以被回收



* 标记清除算法（效率低，递归方式还有全堆对象遍历，清理出来的空闲内存不连续）：
  * 标记阶段：通过根节点，标记所有从根节点开始可到达的对象
  * 清除阶段：清除所有未被标记的对象
* 复制算法（适合新生代GC,缺点是空间浪费）：将内存空间分为两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收

* 标记-整理算法（适合老年代GC,效率不太高，低于复制算法)：首先需要从根节点开始，对所有可达对象做一次标记；但之后，它并不简单的清理未标记的对象，而是**将所有的存活对象压缩到内存的一端；**之后，清理边界外所有的空间。
* 分代收集算法：短命对象归为新生代、长命对象归为老年代
  * 少量对象存活，适合复制算法
  * 大量对象存活，适合标记清除/标记整理算法

**可触及性：**

所有的算法，需要能够识别一个垃圾对象，因此需要给出一个可触及性的定义。

**可触及的：**

　　从根节点可以触及到这个对象。

  　　其实就是从根节点扫描，只要这个对象在引用链中，那就是可触及的。

**可复活的：**

　　一旦所有引用被释放，就是可复活状态

　　因为在finalize()中可能复活该对象

**不可触及的：**

　　在finalize()后，可能会进入不可触及状态

　　不可触及的对象不可能复活

  　　要被回收。