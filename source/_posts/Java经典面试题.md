---
title: Java面试经典题
date: 2015-12-20 19:59:53
tags: Java
---

## 1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

Java虚拟机是一个可以执行Java字节码文件的虚拟机进程.Java源文件被编译成Java虚拟机可以执行的字节码文件.

Java被设计成允许应用程序可以运行在任意的平台上,而不需要程序员为每一个平台单独重写或者重新编译.Java虚拟机让这个变为可能,因为他知道底层硬件平台的指令长度和其他特性.

![](https://desk-fd.zol-img.com.cn/t_s1366x768c5/g3/M0A/0D/02/Cg-4WFQfin-IV8_TACWAy0NrzPcAAPR_QORRBgAJYDj999.jpg)
<!--more-->
## 2.JDK和JRE的区别是什么？
Java运行时环境(JRE).包括Java虚拟机,Java核心类库和支持文件. 它不包含开发工具(JDK) --编译器,调试器和其他工具.
Java开发工具包(JDK)是完整的Java软件开发包,包含了JRE,编译器和其他的工具.可以让开发者开发,编译,执行Java应用程序.

## 3.”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法?

"static"关键字表明一个成员变量或者成员方法可以在没有所属类的实例变量的情况下被访问.
Java中static方法不可以被覆盖,因为方法覆盖是基于运行时动态绑定的,而static是编译时静态绑定的.static方法和类的任何实例都不相关,所以概念上不适用.
(这里插入一下重写(覆盖)和重载的概念:a中的方法重载发生在同一个类里面两个或者多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型,是继承与实现中的一个概念，主要指抽象方法的重写。 
两者都是Java中多态性一个的一个体现，方法重写是父类与子类之间多态性的体现，而方法重载主要是类内部多态性的一个体现。 )

Java也不可以重写private方法,因为peivate方法和private变量只允许当前类访问,如果是其他的类继承当前类是不能访问到当前类的private变量或方法,当然也不能覆盖.

## 4.是否可以在static环境下访问非static变量

static变量在Java是属于类的,他在所有实例中的值是一样的.当类被Java虚拟机载入时,会对static变量初始化.如果你的代码尝试不用实例来访问非static变量,编译会报错,因为这些变量还没被创建出来,还没有跟任何实例关联上.

##5 Java内存模型

* java是在java虚拟机上运行，一般地大家讲到的Java内存其实就是Jvm内存

运行时内存模型，分为`线程私有`和`共享数据区`两大类，其中线程私有的数据区包含程序计数器、虚拟机栈、本地方法区，所有线程共享的数据区包含Java堆、方法区，在方法区内有一个常量池。

![](http://7xta11.com1.z0.glb.clouddn.com/jvm_memory_1.png)

* 所有线程共享的数据区

1. <b>方法区:</b>存储已被虚拟机加载的类的信息,常量,静态变量,即时编译后代码等数据.常量池位于方法区,存放编译器生成的各种字面量和符号引用.(自JDK 1.7 版本以后字符串的常量池已经从永久代（方法区）迁移到堆区。 )

2. <b>堆区:</b>即常说的存放对象的区域

* 线程私有区:
1. <b>虚拟机栈:</b>方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；用于存储局部变量、操作数栈、动态链接、方法出口等信息。每个方法一个栈帧，互不干扰

2. <b>本地方法栈:</b> 虚拟机的Native方法执行的内存区；
3. <b>程序计数器:</b>记录正在执行的虚拟机字节码的地址；



![](http://7xta11.com1.z0.glb.clouddn.com/stack_heap_info.png)


对于大多数的程序员来说，Java内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的”堆”对应内存模型的Java堆，”栈”是指虚拟机栈，然而Java内存模型远比这更复杂，想深入了解Java的内存，还是有必要明白整个内存模型。

##6 Java支持的数据类型有哪些？什么是自动拆装箱？

支持的8中基本数据类型是:
byte , short , int ,long , float , double, boolean , char

Java支持的数据类型包括两种:一种是基本数据类型,另一种是引用类型:如String等,其实是对象的引用,JVM中虚拟机栈存放的是对象的地址,创建的对象实质在堆中,通过地址找到堆中对象的过程,即为引用过程.

自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间的一种转化.例如把int转为Integer,double转为Double,反之,就是自动拆箱:如Integer调用其方法将其转化为int的过程.(自动装箱和拆箱从Java 1.5开始引入，目的是将原始类型值转自动地转换成对应的对象。自动装箱与拆箱的机制可以让我们在Java的变量赋值或者是方法调用等情况下使用原始类型或者对象类型更加简单直接。)


##7 Java支持多继承吗

Java中类不支持多继承,只支持单继承(一个类只能有一个父类).但是Java中接口支持多继承,即一个子接口可以有多个父接口.(接口的作用是用来扩展对象的功能,一个子接口继承多个父接口,说明接口扩展了多个功能,当类实现接口时,类就扩展了相应的功能).

## 8 接口和抽象类的区别
接口是一种比抽象类更加抽象的"类",这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnablle();肯定是错的,我们只能new它的实现类.

* 接口中所有的方法都是抽象的,而抽象类可以同时包含抽象的和非抽象的方法.
* 类可以实现多个接口,但只能继承一个抽象类.
* 抽象类可以在不提供接口实现的情况下实现该接口.
* 接口中的声明的所有变量默认都是final的,抽象类可以包含非final1变量
* 接口中的成员函数默认是public的,抽象类的成员函数可以是public,private,或者是protected.
* 接口是绝对抽象的,不可以被实例化.抽象类也不可以被实例化.但是它如果包含main方法是可以被调用的.

## 9 什么是值传递和引用传递

* 值传递是对基本类型变量而言,传递的是该变量的一个副本,改变的是副本而不影响原变量.
* 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本,并不是对象本身.
一般认为Java内的传递都是值传递,java函数在传递引用数据类型时，也只是拷贝了引用的值罢了，之所以能修改引用数据是因为它们同时指向了一个对象，但这仍然是按值调用而不是引用调用。

PS:对于String类型,虽然它也不是8种基本数据类型，也是一个实例，传递的也是地址，但它会显示出和传递基本数据类型类似的性质.<b>String表现为值传递，主要是因为这个玩意儿是不可变的！如何理解不可变？我们一般说的改变一个String变量，其实并不是改变的这个String本身，而是用一个新的String去替换掉原来的，原来的String本身并没有变。</b>String表现为值传递，并不是因为String是不可变的，而是因为传递的地址的拷贝指向了新的实例，而原地址指向的还是原来的实例。即使String是可变的，在一些特定操作一样会表现出类似值传递的现象。


## 10 进程和线程的区别

* 进程是执行着的应用程序,而线程是进程内部的一个执行序列.一个进程可以有多个线程,线程又叫做轻量进程.
* 线程的划分小于进程,线程隶属于某个进程.进程是程序的一个动态形式,是CPU,内存等资源占用的基本单位,而线程是不占有这些资源的.
* 进程之间相互独立，通信比较困难，而线程之间共享一块内存区域，通信比较方便。

## 11 创建线程有几种不同方式?
4种方式可以实现
1. 继承Thread类,重写run()方法
2. 实现Runnable接口
3. 应用程序可以使用Executor框架来创建线程池
4. 实现Callable接口

实现Runnable接口这种方式更受欢迎,因为这不需要继承Thread类(hread类实际上也是实现了Runnable接口的类).在应用设计中已经继承了别的类的情况下,这需要多继承(而Java不支持多继承),只能实现接口.同时,线程池是非常高效的,很容易实现和使用.

## 12 线程的几种可用状态

1. 新建(new): 新创建了一个线程对象
2. 可运行(Runnable):线程对象创建后,其他进程(比如main进程)调用了该对象的start()方法,该进程位于可运行线程池中,等待被线程调度选中,获取CPU的使用权.
3. 运行(Running):可运行状态的线程获得了CPU时间片,执行程序代码
4. 阻塞阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：
* 等待阻塞:运行的进程执行wait()方法,JVN会将该进程放入等待队列中.
* 同步阻塞:运行的进程在获取对象的同步锁时,若该同步锁被别的线程占用,则JVN会将该线程放入锁池中.
* 其它阻塞:运行的进程执行Thread.sleep(long ms)或t.join()(主线程等待子线程结束),或者发出了I/O请求,JVM会把该线程设为阻塞状态. 当sleep()状态超时,join()等待线程终止或者超时,或者I/O处理完毕时,线程转入可运行状态.
* 死亡(dead):线程run()方法,main()方法执行结束,或者因异常	退出了run()方法,则该线程结束生命周期,死亡的线程不可再次复生.

![](http://uploadfiles.nowcoder.net/images/20151217/149974_1450349079825_4697A22AC611680A692472687DEC1CFD)


## 13 同步方法和同步代码块的区别是什么?
区别:
同步方法默认用this或者当前类class对象作为锁.
同步代码块可以选择以什么来加锁,比同步方法更细颗粒度,我们可以选择只同步会发生同步问题的部分代码而不是整个方法.
同步方法使用关键字synchorized修饰方法,而同步代码块主要是修饰需要进行同步的代码,用synchronized(object){代码内容}进行修饰.

## 14 如何确保N个线程可以访问N个资源而又不会导致死锁
指定获取锁的顺序,并强制进程按照指定的顺序获取锁.因此如果所有的线程都是以同样的顺序加锁和释放锁,就不会出现死锁了.(如:进程1 2 3 资源 A B c  ,1 2 3获取资源的顺序是 ABC,即获得了A后才能请求B,获得了B之后才可以请求C,这样可以保证不会出现死锁)

##15 Java集合类框架的基本接口有哪些

总共有两大接口:Collection和Map,一个是元素集合,一个是键值对集合.

List,Set继承了Collection接口,List是有序元素集合,可以包含重复元素.Set是无序元素集合,不可以包含重复元素.

ArrayList和LinkedList实现了List接口,HashSet实现了Set接口.这几个都比较常用;

HashMap和HashTable实现了Map接口,HashTable是线程安全的,但HashMap性能更好.

## 16 HashMap的工作原理是什么

Java中的HashMap是以键值对(key-value)的形式存储元素的.HashMap需要一个hash函数,它使用hashCode()和equals()方法来向集合添加和检索元素.当调用put()方法时:首先hash(key)得到key的hashCode.hashmap根据获得的hashcode找到要插入的位置所在的链，在这个链里面放的都是hashcode相同的Entry键值对，在找到这个链之后，会通过equals()方法判断是否已经存在要插入的键值对，而这个equals比较的其实就是key。
在添加对应的key-value这样的组合时，如果原本已经存在对应的key，则直接改变对应的value，并返回旧的value，而在判断key是否存在的时候是先比较key的hashCode，再比较相等或equals的。 

## 17 HashMap 和HashTable的区别

HashMap和HashTable都实现了Map接口,因此很多特性都非常相似,但是他们有以下不同点:

* HashMap允许键和值是null,HashTable不允许键或值是null
* HashTable是synchorized的,而HashMap不是,这意味着HashTable是线程安全的,多个线程可以共享一个HashTable.而HashMap是非synchorized的,如果没有正确的同步的话,多个线程是不能共享HashMap的.所以在单线程环境下,HashTable要慢于HashMap.因此HashMap更适合于单线程环境,HashTable更适合于多线程环境.(sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。)
* HashMap的迭代器(Iterator)是fail-fast(fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件)的,而HashTable的enumeration(列举)迭代器不是fail-fast的.所以当有线程改变了HashMap的结构(增加或删除了元素),将会抛出ConcurrentModificationException异常,但迭代器本身的remove()方法移除元素不会抛出该异常.但这也不是一个一定发生的行为,这要看JVM.这同样也是Iterator和Enumeration的区别.


## 18 数组(Array)和列表(ArrayList)有什么区别? 什么时候应该使用Array而不是ArrayList?

* Array可以包含基本类型和对象类型,ArrayList只能包含对象类型
* Array的大小是固定的,ArrayList的大小是动态增长的
* ArrayList提供了更多的方法和特性,比如: addAll(),removeAll(),iterator()等.

对于基本数据类型,集合使用自动装箱来减少编码工作量.但是当处理固定大小的基本数据类型时,这种方式相对较慢.


## 19 ArrayList和LinkedList有什么区别？
ArrayList 和 LinkedList都实现了List接口,他们有以下不同点:
* ArrayList是基于索引的数据接口,他的底层是数组.他可以在O(1)的时间复杂度对元素进行访问.与此对应的LinkedList是以元素链形式存储他的数据.每一个元素和它的前一个元素和后一个元素连在一起,在这种情况下,查找某个元素的复杂度是O(n).
* 相对于ArrayList,LinkedList的插入,删除,添加速度更快.因为元素添加到集合任意位置时,不需要像数组那样重新计算大下或者是更新索引.
* LinkedList比ArrayList更占内存,因为LinkedList为每一个节点存储了两个引用,一个指向前一个元素,一个指向后一个元素.
* 

## 20 Java会内存泄漏吗
<b>内存泄漏(Memory Leak):</b>是指程序已动态分配的堆内存由于某种原因未释放或者无法释放,造成系统内存的浪费,导致程序运行苏速度减慢,甚至系统崩溃等严重后果.

Java中的内存泄露,广义并通俗的讲就是:<b>不再会被使用的对象的内存不能被回收,就是内存泄漏.</b>在Java中,我们不用(也没法)自己释放内存,无用的对象有GC自动清理,这极大简化了我们的工作.但实际有时候一些不会再被使用的对象.在GC看来不能被释放,就会造成内存泄露.
 我们知道，对象都是有生命周期的，有的长，有的短，<b>如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。</b>(具体内存泄漏请看这篇文章<a href="http://blog.csdn.net/anxpp/article/details/51325838">JAVA 内存  泄露详解（原因、例子及解决）</a>)


## 21 Mysql索引的实现原理
Mysql官方对索引的定义为:<b>索引(index)是帮助Mysql高效获取数据的数据结构.</b>
查询是数据库的最主要功能之一,我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构,所以在数据之外,数据库系统还维护着满足特定查找算法的数据结构,这些数据结构以某种方式引用(指向)数据,这样就可以在这些数据结构上实现高级查找算法.这种数据结构就是索引.

索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。在没有索引的情况下，数据库会遍历全部数据后选择符合条件的；而有了相应的索引之后，数据库会直接在索引中查找符合条件的选项。

<b>索引建立的几大原则</b>
* <b>最左前缀匹配原则:</b>非常重要的原则,Mysql会一直向右匹配直到遇到范围查询(>,<,between,like)就停止匹配.比如 a=1 and b=2 and c>3 and d=4 如果建立(a,b,c,d)的顺序索引,d是用不到索引的.如果建立(a,d,b,c)的索引则都可以遇到,a,b,d的顺序可以任意调整.
* 尽量选择区分度高的列作为索引,区分度的公式是count(distinct_col)/count(*) ,表示字段不重复的比例,比例越大,我们扫描的记录数越少,唯一键的区分度是1,而一些状态,性别字段可能在大数据面前区分度是0,那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录
* 索引列不能参与计算,保持列"干净"
* 尽量扩展索引,不要新建索引.比如表中已经有a的索引,现在要加(a,b)的索引,那么只需修改原来的索引即可.
* 定义有外键的数据列一定要加索引.
* 对于那些查询中很少涉及的列,重复值较多的列不要建立索引.
* 对于定义为text,image和bit的数据类型的列不要加索引
* 对于经常存取的列避免建立索引


目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构(详情看这篇文章<a href="https://www.jianshu.com/p/1775b4ff123a">干货：mysql索引的数据结构</a>  或者这篇<a href="http://blog.csdn.net/Jack__Frost/article/details/72571540">MySQL优化系列（三）--索引的使用、原理和设计优化</a>)


## 22 Mysql实现分页
通过`limit`和`offset` 或只通过`limit`可以实现分页功能。

		//以下都是返回表student中第10,11,12,13行数据
		select * from student limit 9,4; 
        select * from student limit 4 offset 9;


## 23 Enumeration接口和Iterator接口的区别有哪些
Enumeration速度是Iterator的两倍,同时占有更少的内存.但是Iterator远远比Enumeration安全,因为其他线程不能修改正在被Iterator遍历的集合里面的对象.同时,Iterator允许调用者删除底层集合里面的元素,这对Enumeration来说这是不可能的.

## 24 finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？
(1)GC决定回收某对象时,就会运行该对象的finalize()方法;
(2)GC本来就是内存回收,应用还需要在finalization做什么呢?答案是大部分时候,什么都不用做(也不需要重载).只有在某些很特殊的情况下,比如你调用了一些Native的方法(一般是C写的),可以在finalization里去调用C的释放函数.

## 25 如果对象的引用设置为null,垃圾收集器是否会立即释放对象占用的内存

不会立即释放对象所占用的内存.如果对象的引用被置为null,只是断开了当前线程帧中对该对象的引用关系,而垃圾收集器是运行在后台的进程,只有当用户线程运行到安全点(safe point)或者安全区域才会扫描对象引用关系,扫描到对象没有引用则会标记对象,这时候仍然不会立即释放该对象内存,因为有些对象是可恢复的(在finalize方法中恢复引用).只有确定了对象无法恢复引用的时候才会清除对象.


## 26 Java中,对象什么时候可以被垃圾回收
当一个对象到GC roots(垃圾收集器对象,GC会收集那些不是GC roots且没有被GC roots引用的对象)不可达时,在下一个垃圾回收周期中尝试回收该对象.如果该对象重写了finalize()方法时,并在这个方法中成功自救(将自身赋予某个引用),那么该对象不会被回收.但如果这个对象没有重写finalize()方法或者已经执行过这个方法,也自救失败,该对象将被回收.

## 27 Java中的两种异常类型是什么?他们有什么区别?
Throwable 包含了错误(Error)和异常(Exception)两类.(Exception和Error都是Throwable的子类.Exception用于用户程序可以捕获的异常情况.Error定义了不期望被用户程序捕获的异常).
Exception包含了运行时异常(`RuntimeException`),又叫非检查异常 和 非运行时异常(`CheckedException`),又叫检查异常.
1.Error是程序无法处理的,如`OutOfMemoryError`等,这些异常发生时,Java虚拟机一般会终止线程.
2.运行时异常都是RuntimeException类和其子类,如`NullPointException`,`IndexOutOfBoundsException`等,这些异常是不检查异常,是在程序运行时可能会发生的,所以程序可以捕捉,也可以不捕捉.这些错误一般是由程序的逻辑错误引起的,程序应该从逻辑角度去尽量避免.
3.检查异常是运行时异常以外的异常,也是Exception及其子类.这些异常从程序角度是必须经过捕捉处理的,否则不能经过编译,如`IOException`,`SQLException`等.


![](https://diycode.b0.upaiyun.com/photo/2016/ecb86e28e5df3a76a107f50d989f6123.png)


## 28 Throw和Throws的区别

1. Throw用于方法的内部,Throws用于方法的声明.
2. Throw后跟异常对象,Throws后跟异常类型.
3. Throw后只能跟一个异常对象,Throws后可以一次声明多个异常类型.


## 29 异常处理完成后,Exception对象会发生什么变化?
Exception会在下一个垃圾回收过程中被回收掉.

## 30 什么是JDBC
JDBC(Java DataBase Connectivity),是一套面向对象的应用程序接口(API),制定了统一的访问各类关系数据库的标准接口.通过JDBC技术,开发人员可以用纯Java语言和标准的Sql语句编写完整的数据库应用程序,真正实现了软件的跨平台性.

## 31 Class.forName()方法有什么作用?
Class.forName( )静态方法的目的是为了动态加载类。在加载完成后，一般还要调用Class下的newInstance( )静态方法来实例化对象以便操作。因此，单单使用Class.forName( )是动态加载类是没有用的，其最终目的是为了实例化对象。

在初始化一个类,生成类实例时,newInstance()方法和new关键字除了一个是方法,一个是关键字外,他们的区别在于创建对象的方式不一样,前者是使用类加载机制,后者是创建一个新类.从JVM的角度来看,我们使用关键字new创建一个新类的时候,这个类可以没有被加载.但是使用newInstance()方法的时候,就必须保证:
1.这个类已经被加载.
2.这个类已经连接了.

而完成上面两个步骤的正是Class的静态方法forName()所完成的,这个静态方法调用了启动类加载器,即加载Java API的那个加载器.

## 32 数据库连接池是什么意思
像打开关闭数据库连接这种和数据库的交互可能是很费时的,尤其是当客户端数量增加的时候,会消耗大量资源,成本是非常高的.可以在应用服务启动的时候建立多个数据库并维护在一个池中.连接请求由池中的连接提供.在连接使用完毕后,把连接归还给池中,以用于满足更多的请求.

## 33 解释下Serialization和Deserialization

Java提供了一种叫做对象序列化的机制,它把对象表示成一连串的字节,里面包含了对象的数据,对象的类型信息,对象内部的数据的类型信息等.因此序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式.反序列化是把对象从扁平状态转化成活动对象的相反步骤.

## 34 什么是Servlet
servlet是基于Java语言的web服务器端编程技术,是Sun提供的一种实现动态网页的解决方案.servlet是运行在servlet容器(如Tomcat)中的java类,它能处理客户端的http请求,并产生http响应.

## 35 说一下servlet的体系结构
所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。

![](http://img.my.csdn.net/uploads/201210/23/1350993311_7168.png)


## 36 解释下servlet的生命周期

对于每一个客户端的请求,servlet引擎载入servlet,调用它的init()方法,完成servlet的初始化.然后servlet对象通过单独调用service()方法处理所有随后来自客户端的请求,最后调用servlet的destory()方法把servlet删除掉.

## 37 doGet()方法和doPost()方法的区别

* doGet():GET方法会把名值对追加在请求的URL后面.因为URL对字符数目有限制,进而限制了用在客户端请求的参数的数目.并且请求中的参数值是可见的,安全性较差.因此敏感信息不能用这种方式传递.同时GET传送的数据量较小,不能大于2KB
* doPost():POST方法通过把请求参数值放在请求体中来克服GET方法的限制,因此可以发送到参数数目是没有限制的.通过POST请求传递的敏感信息对外部客户端是不可见的,安全性较高.同时POST传送的数据量较大,但是执行效率低于GET.

## 38 HTTP响应的结构是怎么样的?
HTTP响应由三个部分组成:
* 状态码(Status Code):用来描述响应的状态,可以用来检查是否成功完成了请求.请求失败的情况下,状态码可以用来查找出请求失败的原因.如果servlet没有返回状态码,默认会返回成功的状态码HttpServletResponse.SC_OK.
* HTTP头部(HTTP Header):包含了更多关于响应的信息.比如:头部可以指定认为响应过期的过期日期等.
* 主体(Body):包含了响应的内容,可以包含HTML代码,图片等等.主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成.

HTTP的请求报文组成:
请求方法 + 请求的资源URL + 协议版本 + 可选的请求首部字段 + 内容实体

HTTP的响应报文组成:
协议版本 + 状态码 + 用于解释状态码的原因短语 + 可选的请求首部字段 + 实体主体

## 39 什么是cookie? session和cookie有什么区别?

* cookie实际上是一小段文本信息. 客户端请求服务器,如果服务端需要记录该用户的状态,就用response给浏览器颁布一个cookie.客户端浏览器会把cookie保存起来,当浏览器再次请求该网站时,浏览器就会把请求地址和cookie一同发给服务器.服务器检查该cookie,从而判断该用户状态.服务器还可以根据需要修改cookie的内容.
* session是另一种记录客户状态的机制.不同的是cookie保存在客户端浏览器中,而session保存在服务器上.客户端浏览访问服务器时候,服务端以某种方式把客户端信息记录在服务器上,这就是session.客户端浏览器再次访问时只需要从该session中查找该客户状态就可以了.

在存储数据方面,session能存储任意类的Java对象,cookie只能存储String类型的对象.




