<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="秒杀系统,">





  <link rel="alternate" href="/atom.xml" title="RicardoXu博客" type="application/atom+xml">






<meta name="description" content="1.业务用户业务： 短信发送业务 注册业务 登录业务  商品业务： 查询商品  交易业务： 下单业务 订单ID的生成  秒杀业务： 活动商品下单业务">
<meta name="keywords" content="秒杀系统">
<meta property="og:type" content="article">
<meta property="og:title" content="秒杀系统设计">
<meta property="og:url" content="http://yoursite.com/2020/03/28/秒杀系统设计/index.html">
<meta property="og:site_name" content="RicardoXu博客">
<meta property="og:description" content="1.业务用户业务： 短信发送业务 注册业务 登录业务  商品业务： 查询商品  交易业务： 下单业务 订单ID的生成  秒杀业务： 活动商品下单业务">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://2.bp.blogspot.com/-Sl6wdO704eo/Tbl_cbCIAbI/AAAAAAAACFw/nlP414H6CLo/s1600/96d8e440a7dd5501977e686709a8ee60.jpg">
<meta property="og:image" content="http://assets.processon.com/chart_image/5e5ba4dfe4b0541c5e15615c.png?_=1583073379976">
<meta property="og:image" content="http://assets.processon.com/chart_image/5e5ba4dfe4b0541c5e15615c.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MaJesTySA/miaosha_Shop/master/imgs/tokenBucket.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MaJesTySA/miaosha_Shop/master/imgs/leekBucket.png">
<meta property="og:updated_time" content="2020-03-28T15:24:16.608Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="秒杀系统设计">
<meta name="twitter:description" content="1.业务用户业务： 短信发送业务 注册业务 登录业务  商品业务： 查询商品  交易业务： 下单业务 订单ID的生成  秒杀业务： 活动商品下单业务">
<meta name="twitter:image" content="https://2.bp.blogspot.com/-Sl6wdO704eo/Tbl_cbCIAbI/AAAAAAAACFw/nlP414H6CLo/s1600/96d8e440a7dd5501977e686709a8ee60.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/28/秒杀系统设计/">





  <title>秒杀系统设计 | RicardoXu博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RicardoXu博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/28/秒杀系统设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RicardoXu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g2/M00/05/05/Cg-4WlVdf2mIQWEzABhFqZtzpSYAAD5OgH-m3MAGEXB992.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RicardoXu博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">秒杀系统设计</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-28T00:00:00+08:00">
                2020-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-业务"><a href="#1-业务" class="headerlink" title="1.业务"></a>1.业务</h2><h3 id="用户业务："><a href="#用户业务：" class="headerlink" title="用户业务："></a>用户业务：</h3><ul>
<li>短信发送业务</li>
<li>注册业务</li>
<li>登录业务</li>
</ul>
<h3 id="商品业务："><a href="#商品业务：" class="headerlink" title="商品业务："></a>商品业务：</h3><ul>
<li>查询商品</li>
</ul>
<h3 id="交易业务："><a href="#交易业务：" class="headerlink" title="交易业务："></a>交易业务：</h3><ul>
<li>下单业务</li>
<li>订单ID的生成</li>
</ul>
<h3 id="秒杀业务："><a href="#秒杀业务：" class="headerlink" title="秒杀业务："></a>秒杀业务：</h3><ul>
<li>活动商品下单业务</li>
</ul>
<p><img src="https://2.bp.blogspot.com/-Sl6wdO704eo/Tbl_cbCIAbI/AAAAAAAACFw/nlP414H6CLo/s1600/96d8e440a7dd5501977e686709a8ee60.jpg" alt><br><a id="more"></a></p>
<h2 id="2-需要改进的地方"><a href="#2-需要改进的地方" class="headerlink" title="2.需要改进的地方"></a>2.需要改进的地方</h2><ol>
<li>如何发现容量问题</li>
<li>如何使得系统水平扩展</li>
<li>查询效率低下</li>
<li>活动开始前页面被疯狂刷新</li>
<li>库存行锁问题</li>
<li>下单操作多、缓慢</li>
<li>浪涌流量如何解决</li>
</ol>
<h1 id="秒杀优化部分："><a href="#秒杀优化部分：" class="headerlink" title="秒杀优化部分："></a>秒杀优化部分：</h1><h2 id="3-单机服务器并发容量问题"><a href="#3-单机服务器并发容量问题" class="headerlink" title="3.单机服务器并发容量问题"></a>3.单机服务器并发容量问题</h2><p>原因： 1. server并发线程数上不去，导致客户端被拒绝连接，tps上不去</p>
<p>查看商品详情接口压测数据：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>请求</th>
<th>平均耗时(ms)</th>
<th>tps(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1000*100</td>
<td>283</td>
<td>2749</td>
</tr>
<tr>
<td>2</td>
<td>2000*100</td>
<td>577</td>
<td>2970</td>
</tr>
<tr>
<td>3</td>
<td>3000*100</td>
<td>588</td>
<td>1879</td>
</tr>
</tbody>
</table>
<h3 id="3-1-默认内嵌Tomcat配置"><a href="#3-1-默认内嵌Tomcat配置" class="headerlink" title="3.1 默认内嵌Tomcat配置"></a>3.1 默认内嵌Tomcat配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.accept-count:等待队列长度,默认<span class="number">100</span></span><br><span class="line">server.tomcat.max-connections:最大可被连接数，默认<span class="number">8192</span></span><br><span class="line">server.tomcat.max-threads:最大工作线程数，默认<span class="number">200</span></span><br><span class="line">server.tomcat.min-spare-threads:最小工作线程数，默认<span class="number">10</span></span><br><span class="line"></span><br><span class="line">默认配置下，连接超过<span class="number">8192</span>后出现拒绝连接的情况</span><br><span class="line">默认配置下，触发的请求超过<span class="number">200</span>+<span class="number">100</span>后拒绝处理</span><br></pre></td></tr></table></figure>
<h3 id="3-2-SpringBoot内嵌tomcat线程优化"><a href="#3-2-SpringBoot内嵌tomcat线程优化" class="headerlink" title="3.2 SpringBoot内嵌tomcat线程优化"></a>3.2 SpringBoot内嵌tomcat线程优化</h3><p>在<code>application.properties</code>里面进行修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.accept-count=1000</span><br><span class="line">server.tomcat.max-threads=800</span><br><span class="line">server.tomcat.min-spare-threads=100</span><br><span class="line"># 取默认值</span><br><span class="line">server.tomcat.max-connections=8192</span><br></pre></td></tr></table></figure>
<p><strong>等待队列不是越大越好</strong>，一是受到内存的限制，二是大量的出队入队操作耗费CPU性能。</p>
<p><strong>最大线程数不是越大越好</strong>，因为线程越多，CPU上下文切换的开销越大，存在一个“阈值”，对于一个4核8G的服务器，经验值是800。</p>
<p>而最小线程数设为100，则是为了应付一些<strong>突发情况</strong>。</p>
<p>spring boot内嵌的tomcat线程优化后，再次压测，效果不是特别明显</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>请求</th>
<th>平均耗时(ms)</th>
<th>tps(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2000*100</td>
<td>595</td>
<td>2958</td>
</tr>
</tbody>
</table>
<h3 id="3-3-SpringBoot内嵌Tomcat网络连接优化"><a href="#3-3-SpringBoot内嵌Tomcat网络连接优化" class="headerlink" title="3.3 SpringBoot内嵌Tomcat网络连接优化"></a>3.3 SpringBoot内嵌Tomcat网络连接优化</h3><p>当然Spring Boot并没有把内嵌Tomcat的所有配置都导出。一些配置需要通过<code>WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;</code>接口来定义。</p>
<p>这里需要自定义<code>KeepAlive</code>长连接的配置，减少客户端和服务器的连接请求次数，避免重复建立连接，提高性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerConfiguration</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用对应工厂类提供给我们的接口，定制化Tomcat connector</span></span><br><span class="line">        ((TomcatServletWebServerFactory) factory).addConnectorCustomizers(<span class="keyword">new</span> TomcatConnectorCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">                Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line">                <span class="comment">//定制化KeepAlive Timeout为30秒</span></span><br><span class="line">                protocol.setKeepAliveTimeout(<span class="number">30000</span>);</span><br><span class="line">                <span class="comment">//10000个请求则自动断开</span></span><br><span class="line">                protocol.setMaxKeepAliveRequests(<span class="number">8192</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>springboot内嵌的tomcat网络连接优化，保持长连接，压测后效果</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>请求</th>
<th>平均耗时(ms)</th>
<th>tps(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2000*100</td>
<td>555</td>
<td>3223</td>
</tr>
</tbody>
</table>
<h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><ul>
<li>发现了Spring Boot内嵌Tomcat的<strong>线程容量问题</strong>。通过在Spring Boot配置文件中添加配置项，提高了Tomcat的等待队列长度、最大工作线程、最小工作线程，榨干服务器性能。</li>
<li>Spring Boot内嵌Tomcat默认使用<code>HTTP 1.0</code>的<strong>短连接</strong>，由于Spring Boot并没有把所有Tomcat配置都暴露出来，所以需要编写一个配置类使用<code>HTTP 1.1</code>的<strong>长连接</strong></li>
</ul>
<h3 id="3-5-接下来的优化方向"><a href="#3-5-接下来的优化方向" class="headerlink" title="3.5 接下来的优化方向"></a>3.5 接下来的优化方向</h3><ul>
<li>对服务器进行分布式扩展</li>
<li>优化SQL查询，比如添加索引</li>
</ul>
<h2 id="4-分布式扩展优化"><a href="#4-分布式扩展优化" class="headerlink" title="4. 分布式扩展优化"></a>4. 分布式扩展优化</h2><p><strong>部署图：</strong></p>
<p><img src="http://assets.processon.com/chart_image/5e5ba4dfe4b0541c5e15615c.png?_=1583073379976" alt></p>
<h3 id="4-1-nginx作用："><a href="#4-1-nginx作用：" class="headerlink" title="4.1 nginx作用："></a>4.1 nginx作用：</h3><ul>
<li>动静分离</li>
<li>反向代理、负载均衡</li>
</ul>
<h2 id="5-分布式会话"><a href="#5-分布式会话" class="headerlink" title="5. 分布式会话"></a>5. 分布式会话</h2><ul>
<li>基于cookie传输sessionID</li>
<li>基于token传输类似sessionID</li>
</ul>
<h2 id="6-查询优化之多级缓存"><a href="#6-查询优化之多级缓存" class="headerlink" title="6. 查询优化之多级缓存"></a>6. 查询优化之多级缓存</h2><p>多级缓存有两层含义，一个是<strong>缓存</strong>，一个是<strong>多级</strong>。我们知道，内存的速度是磁盘的成百上千倍，高并发下，从磁盘I/O十分影响性能。所谓缓存，就是将磁盘中的热点数据，暂时存到内存里面，以后查询直接从内存中读取，减少磁盘I/O，提高速度。所谓多级，就是在多个层次设置缓存，一个层次没有就去另一个层次查询。</p>
<h3>项目架构</h3>

<p><img src="http://assets.processon.com/chart_image/5e5ba4dfe4b0541c5e15615c.png" alt></p>
<h3 id="6-1-优化商品查询接口——单机版redis思路"><a href="#6-1-优化商品查询接口——单机版redis思路" class="headerlink" title="6.1 优化商品查询接口——单机版redis思路"></a>6.1 优化商品查询接口——单机版redis思路</h3><p>之前的<code>ItemController.getItem</code>接口，来一个<code>Id</code>，就调用<code>ItemService</code>去数据库查询一次。<code>ItemService</code>会查三张表，分别是商品信息表<code>item</code>表、商品库存<code>stock</code>表和活动信息表<code>promo</code>，十分影响性能。</p>
<p>所以修改<code>ItemController.getItem</code>接口，思路很简单，先从Redis服务器获取，若没有，则从数据库查询并存到Redis服务。有的话直接用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/get"</span>,method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getItem</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span>Integer id)</span>&#123;</span><br><span class="line">    ItemModel itemModel=(ItemModel)redisTemplate.opsForValue().get(<span class="string">"item_"</span>+id);</span><br><span class="line">    <span class="comment">//如果不存在，就执行下游操作，到数据查询</span></span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        itemModel=itemService.getItemById(id);</span><br><span class="line">        <span class="comment">//设置itemModel到redis服务器</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">        <span class="comment">//设置失效时间</span></span><br><span class="line">        redisTemplate.expire(<span class="string">"item_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    ItemVO itemVO=convertVOFromModel(itemModel);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(itemVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-优化商品查询接口——本地热点缓存"><a href="#6-2-优化商品查询接口——本地热点缓存" class="headerlink" title="6.2 优化商品查询接口——本地热点缓存"></a>6.2 优化商品查询接口——本地热点缓存</h3><p>Redis缓存虽好，但是有网络I/O，没有本地缓存快。我们可以在Redis的前面再添加一层<strong>“本地热点”</strong>缓存。所谓<strong>本地</strong>，就是利用<strong>本地JVM内存</strong>，由于JVM内存有限，仅存放<strong>多次查询</strong>的数据。</p>
<p>本地缓存，说白了就是一个<code>HashMap</code>，但是<code>HashMap</code>不支持并发读写，肯定是不行的。<code>j.u.c</code>包里面的<code>ConcurrentHashMap</code>虽然也能用，但是无法高效处理过期时限、没有淘汰机制等问题，所以这里使用了<code>Google</code>的<code>Guava Cache</code>方案。</p>
<p><code>Guava Cache</code>除了线程安全外，还可以控制超时时间，提供淘汰机制。</p>
<p>引用<code>google.guava</code>包后，在<code>service</code>包下新建一个<code>CacheService</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String,Object&gt; commonCache=<span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        commonCache= CacheBuilder.newBuilder()</span><br><span class="line">                <span class="comment">//初始容量</span></span><br><span class="line">                .initialCapacity(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//最大100个KEY，超过后会按照LRU策略移除</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                <span class="comment">//设置写缓存后多少秒过期，还有根据访问过期即expireAfterAccess</span></span><br><span class="line">                .expireAfterWrite(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommonCache</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">       commonCache.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFromCommonCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonCache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ItemController</code>里面，首先从本地缓存中获取，如果本地缓存没有，就去Redis里面获取，如果Redis也没有，就去数据库查询并存放到Redis里面。如果Redis里面有，将其获取后存到本地缓存里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getItem</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span>Integer id)</span>&#123;</span><br><span class="line">    ItemModel itemModel=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//第一级：先去本地缓存</span></span><br><span class="line">    itemModel=(ItemModel)cacheService.getFromCommonCache(<span class="string">"item_"</span>+id);</span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//第二级：从redis里面获取</span></span><br><span class="line">        itemModel=(ItemModel)redisTemplate.opsForValue().get(<span class="string">"item_"</span>+id);</span><br><span class="line">        <span class="comment">//如果不存在，就执行下游操作，到数据查询</span></span><br><span class="line">        <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">            itemModel=itemService.getItemById(id);</span><br><span class="line">            <span class="comment">//设置itemModel到redis服务器</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">            <span class="comment">//设置失效时间</span></span><br><span class="line">            redisTemplate.expire(<span class="string">"item_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//填充本地缓冲</span></span><br><span class="line">        cacheService.setCommonCache(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">    &#125;</span><br><span class="line">    ItemVO itemVO=convertVOFromModel(itemModel);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(itemVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-本地缓存缺点"><a href="#6-3-本地缓存缺点" class="headerlink" title="6.3 本地缓存缺点"></a>6.3 本地缓存缺点</h3><p>本地缓存虽然快，但是也有缺点：</p>
<ul>
<li>更新麻烦，容易产生脏数据</li>
<li>受到JVM容量的限制</li>
</ul>
<h3 id="6-4-Nginx缓存"><a href="#6-4-Nginx缓存" class="headerlink" title="6.4 Nginx缓存"></a>6.4 Nginx缓存</h3><h2 id="7-查询优化之页面静态化"><a href="#7-查询优化之页面静态化" class="headerlink" title="7.  查询优化之页面静态化"></a>7.  查询优化之页面静态化</h2><h3 id="7-1-CDN"><a href="#7-1-CDN" class="headerlink" title="7.1 CDN"></a>7.1 CDN</h3><h3 id="7-2-全页面静态化"><a href="#7-2-全页面静态化" class="headerlink" title="7.2 全页面静态化"></a>7.2 全页面静态化</h3><h2 id="8-交易优化之缓存库存"><a href="#8-交易优化之缓存库存" class="headerlink" title="8. 交易优化之缓存库存"></a>8. 交易优化之缓存库存</h2><h3 id="8-1-交易接口瓶颈"><a href="#8-1-交易接口瓶颈" class="headerlink" title="8.1 交易接口瓶颈"></a>8.1 交易接口瓶颈</h3><p>压测时发现<code>createOrder</code>接口压力很大，而数据库服务器的压力则要小很多。</p>
<p>原因在于，在<code>OrderService.createOrder</code>方法里面，首先要去数据库 <strong>查询商品信息，</strong>而在查询商品信息的过程中，又要去 <strong>查询秒杀活动消息</strong>，最后还要查询<strong>用户信息</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询商品信息的过程中，也会查询秒杀活动信息。</span></span><br><span class="line">ItemModel itemModel=itemService.getItemById(itemId);</span><br><span class="line"><span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR,<span class="string">"商品信息不存在"</span>);</span><br><span class="line"><span class="comment">//查询用户信息</span></span><br><span class="line">UserModel userModel=userService.getUserById(userId);</span><br></pre></td></tr></table></figure>
<p> 这还没完，最后还要对<code>stock</code><strong>库存表进行-1<code>update</code>操作</strong>，对<code>order_info</code><strong>订单信息表进行添加<code>insert</code>操作，</strong>对<code>item</code><strong>商品信息表进行销量+1<code>update</code>操作</strong>。仅仅一个下单，就有<strong>6次</strong>数据库I/O操作，此外，减库存操作还存在<strong>行锁阻塞</strong>，所以下单接口并发性很低。</p>
<h3 id="8-2-交易验证优化"><a href="#8-2-交易验证优化" class="headerlink" title="8.2 交易验证优化"></a>8.2 交易验证优化</h3><p>验证用户信息，是为了<strong>用户风控策略</strong>。判断用户信息是否存在是基本的策略，在企业级中，还可以判断用户状态是否异常，是否异地登录等。用户风控的信息，实际上可以缓存话，放到Redis里。</p>
<p>查询商品信息、活动信息，是为了<strong>活动校验策略</strong>。商品信息、活动信息，也可以存入缓存中。活动信息，由于具有<strong>时效性</strong>，需要具备紧急下线的接口，可以编写一个接口，清除活动信息的缓存。</p>
<h4 id="8-2-1-用户校验缓存化"><a href="#8-2-1-用户校验缓存化" class="headerlink" title="8.2.1 用户校验缓存化"></a>8.2.1 用户校验缓存化</h4><p>思路很简单，就是先从Redis里面获取用户信息，没有再去数据库查，并放到Redis里面。<code>UserService</code>新开一个<code>getUserByIdCache()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UserModel <span class="title">getUserByIdInCache</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    UserModel userModel= (UserModel) redisTemplate.opsForValue().get(<span class="string">"user_validate_"</span>+id);</span><br><span class="line">    <span class="keyword">if</span>(userModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        userModel=<span class="keyword">this</span>.getUserById(id);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"user_validate_"</span>+id,userModel);</span><br><span class="line">        redisTemplate.expire(<span class="string">"user_validate_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-2-2-活动校验缓存优化"><a href="#8-2-2-活动校验缓存优化" class="headerlink" title="8.2.2 活动校验缓存优化"></a>8.2.2 活动校验缓存优化</h4><p>跟用户校验类似，<code>ItemService</code>新开了一个<code>getItemByIdCache()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ItemModel <span class="title">getItemByIdInCache</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    ItemModel itemModel=(ItemModel)redisTemplate.opsForValue().get(<span class="string">"item_validate_"</span>+id);</span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        itemModel=<span class="keyword">this</span>.getItemById(id);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"item_validate_"</span>+id,itemModel);</span><br><span class="line">         redisTemplate.expire(<span class="string">"item_validate_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> itemModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-2-3-缓存优化后的效果"><a href="#8-2-3-缓存优化后的效果" class="headerlink" title="8.2.3 缓存优化后的效果"></a>8.2.3 缓存优化后的效果</h4><p>优化之后，tps和响应时间提升效果很好</p>
<h3 id="8-3-库存扣减优化"><a href="#8-3-库存扣减优化" class="headerlink" title="8.3 库存扣减优化"></a>8.3 库存扣减优化</h3><h4 id="8-3-1-索引优化"><a href="#8-3-1-索引优化" class="headerlink" title="8.3.1 索引优化"></a>8.3.1 索引优化</h4><p>之前扣减库存的操作，会执行<code>update stock set stock = stock - #{amount} where item_id = #{itemId} and stock &gt; #{amount}</code>这条SQL语句。如果<code>where</code>条件的<code>item_id</code>字段没有<strong>索引</strong>，那么会<strong>锁表</strong>，性能很低。所以先查看<code>item_id</code>字段是否有索引，没有的话，使用<code>alter table stock add UNIQUE INDEX item_id_index(item_id)</code>，为<code>item_id</code>字段添加一个<code>唯一索引</code>，这样在修改的时候，只会<strong>锁行</strong>。</p>
<h4 id="8-3-2-库存扣减缓存优化"><a href="#8-3-2-库存扣减缓存优化" class="headerlink" title="8.3.2 库存扣减缓存优化"></a>8.3.2 库存扣减缓存优化</h4><p>之前下单，是<strong>直接操作数据库</strong>，一旦秒杀活动开始，大量的流量涌入扣减库存接口，<strong>数据库压力很大</strong>。那么可不可以现在<strong>缓存中</strong>下单？答案是可以的。如果要在缓存中扣减库存，需要解决<strong>两个</strong>问题，第一个是活动开始前，将数据库的库存信息，同步到缓存中。第二个是下单之后，要将缓存中的库存信息同步到数据库中。这就需要用到<strong>异步消息队列</strong>——也就是<strong>RocketMQ</strong>。</p>
<h5 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h5><p>RocketMQ是阿里巴巴在RabbitMQ基础上改进的一个消息中间件。</p>
<p>只是要特别说明一下，默认的RocketMQ<strong>配置很坑</strong>（<code>Xms4g Xmx4g Xmn2g</code>），会导致Java<strong>内存不足</strong>的问题。需要修改<code>mqnamesrv.xml</code>，将<code>NewSize</code>、<code>MaxNewSize</code>、<code>PermSize</code>、<code>MaxPermSize</code>设置为自己服务器可承受值。</p>
<p>此外，<code>mqnamesrv</code>甚至不能用<code>localhost</code>启动，必须是本机公网IP，否则报<code>RemotingTooMuchRequestException</code>。</p>
<p><code>PromoService</code>新建一个<code>publishPromo()</code>方法，把数据库的缓存存到redis里去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishPromo</span><span class="params">(Integer promoId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过活动id获取活动</span></span><br><span class="line">    PromoDO promoDO=promoDOMapper.selectByPrimaryKey(promoId);</span><br><span class="line">    <span class="keyword">if</span>(promoDO.getItemId()==<span class="keyword">null</span> || promoDO.getItemId().intValue()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ItemModel itemModel=itemService.getItemById(promoDO.getItemId());</span><br><span class="line">    <span class="comment">//库存同步到Redis</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_"</span>+itemModel.getId(),itemModel.getStock());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意到的是，当我们把<strong>库存存到Redis的时候，商品可能被下单，</strong>这样数据库的库存和Redis的库存就 <strong>不一致</strong>了。解决方法就是活动<strong>未开始</strong>的时候，商品是<strong>下架状态</strong>，不能被下单。</p>
<p>最后，在<code>ItemService</code>里面修改<code>decreaseStock()</code>方法，在Redis里面扣减库存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 老方法，直接在数据库减</span></span><br><span class="line">    <span class="comment">// int affectedRow=itemStockDOMapper.decreaseStock(itemId,amount);</span></span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (affectedRow &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="同步缓存库存到数据库（异步扣减库存）"><a href="#同步缓存库存到数据库（异步扣减库存）" class="headerlink" title="同步缓存库存到数据库（异步扣减库存）"></a>同步缓存库存到数据库（异步扣减库存）</h5><p>引入RocketMQ相应<code>jar</code>包，在Spring Boot配置文件中添加MQ配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mq.nameserver.addr=IP:<span class="number">9876</span></span><br><span class="line">mq.topicname=stock</span><br></pre></td></tr></table></figure>
<p>新建一个<code>mq.MQProducer</code>类，编写<code>init</code>方法，初始化生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqProducer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> DefaultMQProducer producer;</span><br><span class="line">  <span class="comment">//即是IP:9867</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.nameserver.addr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameAddr;</span><br><span class="line">    <span class="comment">//即是stock</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.topicname&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String topicName;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">//Producer初始化，Group对于生产者没有意义，但是消费者有意义</span></span><br><span class="line">        producer=<span class="keyword">new</span> DefaultMQProducer(<span class="string">"producer_group"</span>);</span><br><span class="line">        producer.setNamesrvAddr(nameAddr);</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写<code>asyncReduceStock()</code>方法，实现异步扣减库存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">asyncReduceStock</span><span class="params">(Integer itemId, Integer amount)</span>  </span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; bodyMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    bodyMap.put(<span class="string">"itemId"</span>,itemId);</span><br><span class="line">    bodyMap.put(<span class="string">"amount"</span>,amount);</span><br><span class="line">    <span class="comment">//创建消息</span></span><br><span class="line">    Message message=<span class="keyword">new</span> Message(topicName,<span class="string">"increase"</span>,</span><br><span class="line">                JSON.toJSON(bodyMap).toString().getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        producer.send(message);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">      ···</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个<code>mq.MqConsumer</code>类，与<code>MqProducer</code>类类似，也有一个<code>init</code>方法，实现<strong>异步扣减库存</strong>的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DefaultMQPushConsumer consumer;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.nameserver.addr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameAddr;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.topicname&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String topicName;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ItemStockDOMapper itemStockDOMapper;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        consumer=<span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"stock_consumer_group"</span>);</span><br><span class="line">        <span class="comment">//监听名为topicName的话题</span></span><br><span class="line">        consumer.setNamesrvAddr(nameAddr);</span><br><span class="line">        <span class="comment">//监听topicName话题下的所有消息</span></span><br><span class="line">        consumer.subscribe(topicName,<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">//这个匿名类会监听消息队列中的消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//实现缓存数据真正到数据库扣减的逻辑</span></span><br><span class="line">                <span class="comment">//从消息队列中获取消息</span></span><br><span class="line">                Message message=list.get(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//反序列化消息</span></span><br><span class="line">                String jsonString=<span class="keyword">new</span> String(message.getBody());</span><br><span class="line">                Map&lt;String,Object&gt; map=JSON.parseObject(jsonString, Map.class);</span><br><span class="line">                Integer itemId= (Integer) map.get(<span class="string">"itemId"</span>);</span><br><span class="line">                Integer amount= (Integer) map.get(<span class="string">"amount"</span>);</span><br><span class="line">                <span class="comment">//去数据库扣减库存</span></span><br><span class="line">                itemStockDOMapper.decreaseStock(itemId,amount);</span><br><span class="line">                <span class="comment">//返回消息消费成功</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ItemService.decreaseStock()</code>方法也要做更改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//&gt;0，表示Redis扣减成功</span></span><br><span class="line">    <span class="keyword">if</span>(affectedRow&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//发送消息到消息队列，准备异步扣减</span></span><br><span class="line">        <span class="keyword">boolean</span> mqResult = mqProducer.asyncReduceStock(itemId,amount);</span><br><span class="line">        <span class="keyword">if</span> (!mqResult)&#123;</span><br><span class="line">            <span class="comment">//消息发送失败，需要回滚Redis</span></span><br><span class="line">          redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Redis扣减失败，回滚</span></span><br><span class="line">        redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="异步扣减库存存在的问题"><a href="#异步扣减库存存在的问题" class="headerlink" title="异步扣减库存存在的问题"></a>异步扣减库存存在的问题</h5><ul>
<li>如果发送消息失败，只能回滚Redis</li>
<li>消费端从数据库扣减操作执行失败，如何处理（这里默认成功）？</li>
<li>下单失败无法正确回补库存（比如用户取消订单）。</li>
</ul>
<p>所以需要引入<strong>事务型消息</strong>。</p>
<h3 id="8-4-小结"><a href="#8-4-小结" class="headerlink" title="8.4 小结"></a>8.4 小结</h3><ul>
<li>首先对<strong>交易验证</strong>进行了优化，把对用户、商品、活动的查询从数据库转移到了缓存中，优化效果明显。</li>
<li>随后，优化了减库存的逻辑<ul>
<li>一是添加了索引，从锁表变成了锁行；</li>
<li>二是将减库存的操作也移到了缓存中，先从缓存中扣，再从数据库中扣。这就涉及到了<strong>异步减库存</strong>，所以需要引入<strong>消息中间件</strong>。</li>
</ul>
</li>
</ul>
<h2 id="9-交易优化之事务型优化"><a href="#9-交易优化之事务型优化" class="headerlink" title="9. 交易优化之事务型优化"></a>9. 交易优化之事务型优化</h2><h3 id="9-1-异步消息发送时机问题"><a href="#9-1-异步消息发送时机问题" class="headerlink" title="9.1 异步消息发送时机问题"></a>9.1 异步消息发送时机问题</h3><p>目前扣减库存的事务<code>ItemService.decreaseStock()</code>是封装在<code>OrderService()</code>事务里面的。在扣减Redis库存、发送异步消息之后，还有订单入库、增加销量的操作。如果这些操作失败，那么<code>createOrder()</code><strong>事务会回滚</strong>，<code>decreaseStock()</code><strong>事务也回滚</strong>，但是Redis的<strong>扣减操作却不能回滚，</strong>这会导致数据不一致。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>解决方法就是在订单入库、增加销量成功之后，再发生异步消息，<code>ItemService.decreaseStock()</code>只<strong>负责扣减Redis库存，不发送异步消息</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//&gt;0，表示Redis扣减成功</span></span><br><span class="line">    <span class="keyword">if</span>(affectedRow&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//抽离了发送异步消息的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Redis扣减失败，回滚</span></span><br><span class="line">        increaseStock(itemId, amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将发送异步消息的逻辑抽出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ItemService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">asyncDecreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mqProducer.asyncReduceStock(itemId, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再在<code>OrderService.createOrder()</code>里面调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="comment">//订单入库</span></span><br><span class="line">orderDOMapper.insertSelective(orderDO);</span><br><span class="line"><span class="comment">//销量增加</span></span><br><span class="line">itemService.increaseSales(itemId,amount);</span><br><span class="line"><span class="comment">//执行完最后一步才发送异步消息</span></span><br><span class="line"><span class="keyword">boolean</span> mqResult=itemService.asyncDecreaseStock(itemId,amount);</span><br><span class="line">    <span class="keyword">if</span>(!mqResult)&#123;</span><br><span class="line">        <span class="comment">//回滚redis库存</span></span><br><span class="line">        itemService.increaseStock(itemId,amount);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.MQ_SEND_FAIL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样，就算订单入库失败、销量增加失败、消息发送失败，都能保证缓存和数据库的一致性。</p>
<h3 id="9-2-事务提交问题"><a href="#9-2-事务提交问题" class="headerlink" title="9.2 事务提交问题"></a>9.2 事务提交问题</h3><p>但是这么做，仍然有问题。Spring的<code>@Transactional</code>标签，会在<strong>事务方法返回后才提交</strong>，如果提交的过程中，发生了异常，则数据库回滚，但是Redis库存已扣，还是无法保证一致性。我们需要在<strong>事务提交成功后，再发生异步消息</strong>。</p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>Spring给我们提供了<code>TransactionSynchronizationManager.registerSynchronization()</code>方法，这个方法传入一个<code>TransactionSynchronizationAdapter</code>的匿名类，通过<code>afterCommit()</code>方法，在<strong>事务提交成功后，</strong>执行<strong>发送消息操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> mqResult=itemService.asyncDecreaseStock(itemId,amount);</span><br><span class="line">    <span class="keyword">if</span>(!mqResult)&#123;</span><br><span class="line">        itemService.increaseStock(itemId,amount);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.MQ_SEND_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-事务型消息"><a href="#9-3-事务型消息" class="headerlink" title="9.3 事务型消息"></a>9.3 事务型消息</h3><p>上面的做法，依然不能保证万无一失。假设现在<strong>事务提交成功了</strong>，等着执行 <code>afterCommit()</code>方法，这个时候<strong>突然宕机了</strong>，那么<strong>订单已然入库，销量已然增加，</strong>但是<strong>去数据库扣减库存的这条消息</strong>却<strong>“丢失”</strong>了。这里就需要引入RocketMQ的事务型消息。</p>
<p>所谓事务型消息，也会被发送到消息队列里面，这条消息处于<code>prepared</code>状态，<code>broker</code>会接收到这条消息，<strong>但是不会把这条消息给消费者消费</strong>。</p>
<p>处于<code>prepared</code>状态的消息，会执行<code>TransactionListener</code>的<code>executeLocalTransaction()</code>方法，根据执行结果，<strong>改变事务型消息的状态，让消费端消费或是不消费</strong>。</p>
<p>在<code>mq.MqProducer</code>类里面新注入一个<code>TransactionMQProducer</code>类，与<code>DefaultMQProducer</code>类似，也需要设置服务器地址、命名空间等。</p>
<p>新建一个<code>transactionAsyncReduceStock</code>的方法，该方法使用<code>事务型消息</code>进行异步扣减库存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务型消息同步库存扣减消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transactionAsyncReduceStock</span><span class="params">(Integer userId, Integer itemId, Integer promoId, Integer amount, String stockLogId)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; bodyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    bodyMap.put(<span class="string">"itemId"</span>, itemId);</span><br><span class="line">    bodyMap.put(<span class="string">"amount"</span>, amount);</span><br><span class="line">    <span class="comment">//用于执行orderService.createOrder的传参</span></span><br><span class="line">    Map&lt;String, Object&gt; argsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    argsMap.put(<span class="string">"itemId"</span>, itemId);</span><br><span class="line">    argsMap.put(<span class="string">"amount"</span>, amount);</span><br><span class="line">    argsMap.put(<span class="string">"userId"</span>, userId);</span><br><span class="line">    argsMap.put(<span class="string">"promoId"</span>, promoId);</span><br><span class="line"></span><br><span class="line">    Message message = <span class="keyword">new</span> Message(topicName, <span class="string">"increase"</span>,</span><br><span class="line">                JSON.toJSON(bodyMap).toString().getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注意，发送的是sendMessageInTransaction</span></span><br><span class="line">        transactionMQProducer.sendMessageInTransaction(message, argsMap);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，就会发送一个事务型消息到<code>broke</code>，而处于<code>prepared</code>状态的事务型消息，会执行<code>TransactionListener</code>的<code>executeLocalTransaction</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">transactionMQProducer.setTransactionListener(<span class="keyword">new</span> TransactionListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message message, Object args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在事务型消息中去进行下单</span></span><br><span class="line">    Integer itemId = (Integer) ((Map) args).get(<span class="string">"itemId"</span>);</span><br><span class="line">    Integer promoId = (Integer) ((Map) args).get(<span class="string">"promoId"</span>);</span><br><span class="line">    Integer userId = (Integer) ((Map) args).get(<span class="string">"userId"</span>);</span><br><span class="line">    Integer amount = (Integer) ((Map) args).get(<span class="string">"amount"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用下单接口</span></span><br><span class="line">        orderService.createOrder(userId, itemId, promoId, amount);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BizException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//发生异常就回滚消息</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在<strong>事务型消息中去执行下单操作，</strong>下单失败，则消息回滚，<strong>不会去数据库扣减库存</strong>。下单成功，则消息被消费，<strong>扣减数据库库存</strong>。</p>
<h4 id="更新下单流程"><a href="#更新下单流程" class="headerlink" title="更新下单流程"></a>更新下单流程</h4><p>之前的下单流程是：<code>OrderController</code>里面调用<code>OrderService.createOrder()</code>方法，然后在该方法最后发送了异步消息，会导致异步消息丢失的问题。所以我们引入了<strong>事务型消息</strong>。</p>
<p>现在的下单流程是：<code>OrderController</code>里面直接调用<code>MqProducer.transactionAsyncReduceStock()</code>方法，发送一个事务型消息，然后在<strong>事务型消息中调用<code>OrderService.createOrder()</code>方法</strong>，进行下单。</p>
<h3 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4 小结"></a>9.4 小结</h3><ul>
<li>首先解决了<strong>发送异步消息时机</strong>的问题，之前是在<code>ItemService.decreaseStock()</code>，当在Redis里面扣减成功之后，发送异步消息。这样会导致数据库回滚，但Redis无法回滚的问题。所以我们把发送异步消息提到所有下单操作操作完成之后。</li>
<li>其次，由于Spring的<code>@Transactional</code>标签是在方法返回之后，才提交事务，如果返回阶段出了问题，那么数据库回滚了，但是缓存的库存却扣了。所以我们使用了<code>afterCommit()</code>方法。</li>
<li>最后，如果在执行<code>afterCommit()</code>的时候，发生了异常，那么消息就发不出去，又会导致数据一致性问题。所以我们通过使用<strong>事务型消息</strong>，把<strong>下单操作包装在异步扣减消息里面</strong>，让下单操作和扣减消息<strong>同生共死</strong>。</li>
</ul>
<h3 id="9-5-接下来的优化方向"><a href="#9-5-接下来的优化方向" class="headerlink" title="9.5 接下来的优化方向"></a>9.5 接下来的优化方向</h3><p>上述流程还有一个漏掉，就是当执行<code>orderService.createOrder()</code>后，突然<strong>又宕机</strong>了，根本没有返回，这个时候事务型消息就会进入<code>UNKNOWN</code>状态，我们需要处理这个状态。</p>
<p>在匿名类<code>TransactionListener</code>里面，还需要覆写<code>checkLocalTransaction()</code>方法，这个方法就是用来处理<code>UNKNOWN</code>状态的。应该怎么处理？这需要引入<strong>库存流水</strong>。</p>
<h2 id="10-库存流水"><a href="#10-库存流水" class="headerlink" title="10. 库存流水"></a>10. 库存流水</h2><p>数据库新建一张<code>stock_log</code>的表，用来记录库存流水，添加一个<code>ItemService.initStockLog</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">initStockLog</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    StockLogDO stockLogDO = <span class="keyword">new</span> StockLogDO();</span><br><span class="line">    stockLogDO.setItemId(itemId);</span><br><span class="line">    stockLogDO.setAmount(amount);</span><br><span class="line">    stockLogDO.setStockLogId(UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">    <span class="comment">//1表示初始状态，2表示下单扣减库存成功，3表示下单回滚</span></span><br><span class="line">    stockLogDO.setStatus(<span class="number">1</span>);</span><br><span class="line">    stockLogDOMapper.insertSelective(stockLogDO);</span><br><span class="line">    <span class="keyword">return</span> stockLogDO.getStockLogId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户请求后端<code>OrderController.createOrder()</code>接口，我们先初始化库存流水的状态，再调用事务型消息去下单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OrderController</span></span><br><span class="line"><span class="comment">//先检验用户登录信息</span></span><br><span class="line">String token = httpServletRequest.getParameterMap().get(<span class="string">"token"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.USER_NOT_LOGIN, <span class="string">"用户还未登录，不能下单"</span>);</span><br><span class="line">&#125;</span><br><span class="line">UserModel userModel = (UserModel) redisTemplate.opsForValue().get(token);</span><br><span class="line"><span class="keyword">if</span> (userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.USER_NOT_LOGIN, <span class="string">"登录过期，请重新登录"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化库存流水</span></span><br><span class="line">String stockLogId = itemService.initStockLog(itemId, amount);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送事务型消息，完成下单逻辑</span></span><br><span class="line"><span class="keyword">if</span> (!mqProducer.transactionAsyncReduceStock(userModel.getId(), itemId, promoId, amount, stockLogId)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.UNKNOWN_ERROR, <span class="string">"下单失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事务型消息会调用<code>OrderService.createOrder()</code>方法，执行Redis扣减库存、订单入库、销量增加的操作，当这些操作都完成后，就说明下单完成了，<strong>等着异步更新数据库了</strong>。那么需要修改订单流水状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OrderService.createOrder</span></span><br><span class="line"><span class="comment">//订单入库</span></span><br><span class="line">orderDOMapper.insertSelective(orderDO);</span><br><span class="line"><span class="comment">//增加销量</span></span><br><span class="line">itemService.increaseSales(itemId, amount);</span><br><span class="line">StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line"><span class="keyword">if</span> (stockLogDO == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.UNKNOWN_ERROR);</span><br><span class="line"><span class="comment">//设置库存流水状态为成功</span></span><br><span class="line">stockLogDO.setStatus(<span class="number">2</span>);</span><br><span class="line">stockLogDOMapper.updateByPrimaryKeySelective(stockLogDO);</span><br></pre></td></tr></table></figure>
<h3 id="10-1-下单操作的处理"><a href="#10-1-下单操作的处理" class="headerlink" title="10.1 下单操作的处理"></a>10.1 下单操作的处理</h3><p>异步更新数据库，需要事务型消息从<code>prepare</code>状态编程<code>commit</code>状态。假设此时<code>orderService。createOrder()</code> <strong>本身发生了异常</strong>，那么就回滚事务型消息，并且返回<code>LocalTransactionState.ROLLBACK_MESSAGE</code>，这个下单操作就会被取消。</p>
<p>如果<strong>本身没有发生异常</strong>，那么就返回<code>LocalTransactionState.COMMIT_MESSAGE</code>，此时事务型消息会从<code>prepare</code>状态变为<code>commit</code>状态，接着被消费端消费，异步扣减库存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MqProducer.TransactionListener().executeLocalTransaction()</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    orderService.createOrder(userId, itemId, promoId, amount, stockLogId);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BizException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//如果发生异常，createOrder已经回滚，此时要回滚事务型消息。</span></span><br><span class="line">    <span class="comment">//设置stockLog为回滚状态</span></span><br><span class="line">    StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line">    stockLogDO.setStatus(<span class="number">3</span>);</span><br><span class="line">    stockLogDOMapper.updateByPrimaryKeySelective(stockLogDO);</span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-UNKNOWN状态处理"><a href="#10-2-UNKNOWN状态处理" class="headerlink" title="10.2 UNKNOWN状态处理"></a>10.2 UNKNOWN状态处理</h3><p>如上节结尾所述，如果在执行<code>createOrder()</code>的时候，突然宕机了，此时事务型消息的状态是<code>UNKNOWN</code>，需要在<code>TransactionListener.checkLocalTransaction()</code>方法中处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据是否扣减库存成功，来判断要返回COMMIT，ROLLBACK还是UNKNOWN</span></span><br><span class="line">    String jsonString = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">    Map&lt;String, Object&gt; map = JSON.parseObject(jsonString, Map.class);</span><br><span class="line">    String stockLogId = (String) map.get(<span class="string">"stockLogId"</span>);</span><br><span class="line">    StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line">    <span class="keyword">if</span> (stockLogDO == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    <span class="comment">//订单操作已经完成，等着异步扣减库存，那么就提交事务型消息</span></span><br><span class="line">    <span class="keyword">if</span> (stockLogDO.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    <span class="comment">//订单操作还未完成，需要执行下单操作，那么就维持为prepare状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stockLogDO.getStatus() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就回滚</span></span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-3-库存售罄处理"><a href="#10-3-库存售罄处理" class="headerlink" title="10.3 库存售罄处理"></a>10.3 库存售罄处理</h3><p>现在是用户请求一次<code>OrderController.createOrder()</code>就初始化一次流水，但是如果10000个用户抢10个商品，就会初始化10000次库存流水，这显然是不行的。</p>
<p>解决的办法是在<code>ItemService.decreaseStock()</code>中，如果库存没有了，就打上<strong>“售罄标志”</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ublic <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow = redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span> + itemId, amount.intValue() * -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (affectedRow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (affectedRow == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//打上售罄标识</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_invalid_"</span> + itemId, <span class="string">"true"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        increaseStock(itemId, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>OrderController.createOrder()</code>初始化流水之前，先判断一下是否售罄，售罄了就直接抛异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否售罄</span></span><br><span class="line"><span class="keyword">if</span> (redisTemplate.hasKey(<span class="string">"promo_item_stock_invalid_"</span>+itemId))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.STOCK_NOT_ENOUGH);</span><br><span class="line">String stockLogId = itemService.initStockLog(itemId, amount);</span><br></pre></td></tr></table></figure>
<h3 id="10-4-小节"><a href="#10-4-小节" class="headerlink" title="10.4 小节"></a>10.4 小节</h3><p>这一节通过引入库存流水，来记录库存的状态，以便在<strong>事务型消息处于不同状态时进行处理</strong>。</p>
<p>事务型消息提交后，会在<code>broker</code>里面处于<code>prepare</code>状态，也即是<code>UNKNOWN</code>状态，等待被消费端消费，或者回滚。<code>prepare</code>状态下，会执行<code>OrderService.createOrder</code>方法。</p>
<p>此时有两种情况：</p>
<ol>
<li><code>createOrder()</code>执行完<strong>没有宕机</strong>，要么<strong>执行成功</strong>，要么<strong>抛出异常</strong>。<strong>执行成功</strong>，那么说明下单成功了，订单入库了，Redis里的库存扣了，销量增加了，<strong>等待着异步扣减库存</strong>，所以将事务型消息的状态，从<code>UNKNOWN</code>变为<code>COMMIT</code>，这样消费端就会消费这条消息，异步扣减库存。抛出异常，那么订单入库、Redis库存、销量增加，就会被数据库回滚，此时去异步扣减的消息，就应该”丢弃”，所以发回<code>ROLLBACK</code>，进行回滚。</li>
<li><code>createOrder()</code>执行完<strong>宕机了</strong>，那么这条消息会是<code>UNKNOWN</code>状态，这个时候需要在<code>checkLocalTransaction</code>进行处理。如果<code>createOrder()</code>执行完毕，此时<code>stockLog.status == 2</code>，就说明下单成功，需要去异步扣减库存，所以返回<code>COMMIT</code>。如果<code>status == 1</code>，说明下单还未完成，还需要继续执行下单操作，所以返回<code>UNKNOWN</code>。如果<code>status == 3</code>，说明下单失败，需要回滚，不需要异步扣减库存，所以返回<code>ROLLBACK</code>。</li>
</ol>
<h4 id="可以改进的地方"><a href="#可以改进的地方" class="headerlink" title="可以改进的地方"></a>可以改进的地方</h4><p>目前只是扣减库存异步化，实际上销量逻辑和交易逻辑都可以异步化，这里就不赘述了。</p>
<h4 id="接下来的优化方向"><a href="#接下来的优化方向" class="headerlink" title="接下来的优化方向"></a>接下来的优化方向</h4><p>目前下单接口会被脚本不停的刷，影响用户的正常体验。此外，验证逻辑和下单逻辑强关联，耦合度比较高。最后，验证逻辑也比较复杂。接下来会引入流量削峰技术。</p>
<h2 id="11-流量削峰"><a href="#11-流量削峰" class="headerlink" title="11. 流量削峰"></a>11. 流量削峰</h2><p>秒杀秒杀，就是在活动开始的一瞬间，有大量流量涌入，优化不当，会导致服务器停滞，甚至宕机。所以引入流量削峰技术十分有必要。</p>
<h3 id="11-1-业务解耦——秒杀令牌"><a href="#11-1-业务解耦——秒杀令牌" class="headerlink" title="11.1 业务解耦——秒杀令牌"></a>11.1 业务解耦——秒杀令牌</h3><p>之前的<strong>验证逻辑</strong>和<strong>下单逻辑</strong>都耦合在<code>OrderService.createOrder</code>里面，现在利用秒杀令牌，使校验逻辑和下单逻辑分离。</p>
<p><code>PromoService</code>新开一个<code>generateSecondKillToken()</code>里面，将活动、商品、用户信息校验逻辑封装在里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSecondKillToken</span><span class="params">(Integer promoId,Integer itemId,Integer userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断库存是否售罄，若Key存在，则直接返回下单失败</span></span><br><span class="line">    <span class="keyword">if</span>(redisTemplate.hasKey(<span class="string">"promo_item_stock_invalid_"</span>+itemId))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    PromoDO promoDO=promoDOMapper.selectByPrimaryKey(promoId);</span><br><span class="line">    PromoModel promoModel=convertFromDataObj(promoDO);</span><br><span class="line">    <span class="keyword">if</span>(promoModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(promoModel.getStartDate().isAfterNow()) &#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(promoModel.getEndDate().isBeforeNow())&#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断活动是否正在进行</span></span><br><span class="line">    <span class="keyword">if</span>(promoModel.getStatus()!=<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断item信息是否存在</span></span><br><span class="line">    ItemModel itemModel=itemService.getItemByIdInCache(itemId);</span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断用户是否存在</span></span><br><span class="line">    UserModel userModel=userService.getUserByIdInCache(userId);</span><br><span class="line">    <span class="keyword">if</span>(userModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//生成Token，并且存入redis内，5分钟时限</span></span><br><span class="line">    String token= UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_token_"</span>+promoId+<span class="string">"_userid_"</span>+userId+<span class="string">"_itemid_"</span>+itemId,token);</span><br><span class="line">    redisTemplate.expire(<span class="string">"promo_token_"</span>+promoId+<span class="string">"_userid_"</span>+userId+<span class="string">"_itemid_"</span>+itemId, <span class="number">5</span>,TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，<code>OrderService.createOrder</code>的校验逻辑就可以删掉了。</p>
<p><code>OrderController</code>新开了一个<code>generateToken()</code>接口，以便前端请求时，返回令牌。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/generatetoken"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">generateToken</span><span class="params">(···)</span> <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">    <span class="comment">//用户登录状态校验</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//获取秒杀访问令牌</span></span><br><span class="line">    String promoToken = promoService.generateSecondKillToken(promoId, itemId, userModel.getId());</span><br><span class="line">    <span class="keyword">if</span> (promoToken == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"生成令牌失败"</span>);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(promoToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端在点击<strong>“下单”</strong>后，首先会请求<code>generateToken()</code>接口，返回秒杀令牌。然后将秒杀令牌<code>promoToken</code>作为参数，再去请求后端<code>createOrder()</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/createorder"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">createOrder</span><span class="params">(··· @RequestParam(name = <span class="string">"promoToken"</span>, required = <span class="keyword">false</span>)</span> String promoToken) <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//校验秒杀令牌是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (promoId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String inRedisPromoToken = (String) redisTemplate.opsForValue().</span><br><span class="line">                    get(<span class="string">"promo_token_"</span> + promoId + <span class="string">"_userid_"</span> + userModel.getId() + <span class="string">"_itemid_"</span> + itemId);</span><br><span class="line">    <span class="keyword">if</span> (inRedisPromoToken == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"令牌校验失败"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.equals(promoToken, inRedisPromoToken)) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"令牌校验失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就彻底完成了校验逻辑和下单逻辑的分离。现在的问题是，假设有1E个用户请求下单，那么就会生成1E的令牌，这是十分消耗性能的，所以接下来引入<strong>秒杀大闸进行限流</strong>.</p>
<h3 id="11-2-限流——令牌大闸"><a href="#11-2-限流——令牌大闸" class="headerlink" title="11.2 限流——令牌大闸"></a>11.2 限流——令牌大闸</h3><p>大闸的意思就是<strong>令牌的数量是有限的</strong>，当令牌用完时，就不再发放令牌了，那么下单将无法进行。之前我们通过<code>PromoService.publishPromo()</code>将库存发布到了Redis上，现在我们将令牌总数也发布到Redis上，这里我们设定令牌总量是库存的5倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishPromo</span><span class="params">(Integer promoId)</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//库存同步到Redis</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_"</span> + itemModel.getId(), itemModel.getStock());</span><br><span class="line">    <span class="comment">//大闸限制数量设置到redis内</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_door_count_"</span> + promoId, itemModel.getStock().intValue() * <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在<code>PromoService.generateSecondKillToken()</code>方法中，在生成令牌之前，首先将Redis里的令牌总量减1，然后再判断是否剩余，如果 &lt;0，直接返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取大闸数量</span></span><br><span class="line"><span class="keyword">long</span> result = redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_door_count_"</span> + promoId, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (result &lt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//令牌生成</span></span><br></pre></td></tr></table></figure>
<p>这样，当令牌总量为0时，就不再发放令牌了，也就无法下单了。</p>
<h4 id="令牌大闸限流缺点"><a href="#令牌大闸限流缺点" class="headerlink" title="令牌大闸限流缺点"></a>令牌大闸限流缺点</h4><p>当商品种类少、库存少的时候，令牌大闸效果还不错。但是一旦参与活动的商品库存太大，比如1W个，那么一秒钟也有上十万的流量涌入，限制能力是很弱的。所以需要<strong>队列泄洪</strong>。</p>
<h3 id="11-3-限流——队列泄洪"><a href="#11-3-限流——队列泄洪" class="headerlink" title="11.3 限流——队列泄洪"></a>11.3 限流——队列泄洪</h3><p>队列泄洪，就是让多余的请求<strong>排队等待</strong>。<strong>排队</strong>有时候比<strong>多线程</strong>并发效率更高，多线程毕竟有锁的竞争、上下文的切换，很消耗性能。而排队是无锁的，单线程的，某些情况下效率更高。</p>
<p>比如Redis就是<strong>单线程模型</strong>，多个用户同时执行<code>set</code>操作，只能一一等待。</p>
<p>比如MySQL的<code>insert</code>和<code>update</code>语句，会维护一个行锁。阿里SQL就不会，而是让多个SQL语句排队，然后依次执行。</p>
<p>像支付宝就使用了队列泄洪，双十一的时候，支付宝作为网络科技公司，可以承受很高的TPS，但是下游的各个银行，无法承受这么高的TPS。支付宝维护了一个”拥塞窗口”，慢慢地向下游银行发送流量，保护下游。</p>
<p>那对于我们的项目，什么时候引入”队列泄洪”呢？在<code>OrderController</code>里面，之前拿到秒杀令牌后，就要开始执行下单的业务了。现在我们把<strong>下单业务</strong>封装到一个<strong>固定大小的线程池中，</strong>一次<strong>只处理固定大小的请求</strong>。</p>
<p>在<code>OrderController</code>里面引入<code>j.u.c.ExecutorService</code>，创建了一个<code>init</code>方法，初始化线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//20个线程的线程池</span></span><br><span class="line">    executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在拿到秒杀令牌后，使用线程池来处理下单请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String stockLogId = itemService.initStockLog(itemId, amount);</span><br><span class="line">        <span class="keyword">if</span> (!mqProducer.transactionAsyncReduceStock(userModel.getId(), itemId, promoId, amount, stockLogId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.UNKNOWN_ERROR, <span class="string">"下单失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，就算转瞬间涌入再多流量，得到处理的也就20个，其他全部等待。</p>
<h3 id="11-4-小结"><a href="#11-4-小结" class="headerlink" title="11.4 小结"></a>11.4 小结</h3><p>这一章我们</p>
<ul>
<li>使用秒杀令牌，实现了校验业务和下单业务的分离。同时为秒杀大闸做了铺垫</li>
<li>使用秒杀大闸，实现了限流的第一步，限制了流量的总量</li>
<li>使用队列泄洪，实现了限流的第二步，同一时间只有部分请求得到处理。</li>
</ul>
<h3 id="11-5-接下来的优化方向"><a href="#11-5-接下来的优化方向" class="headerlink" title="11.5 接下来的优化方向"></a>11.5 接下来的优化方向</h3><p>接下来会引入防刷限流技术，比如验证码技术等。</p>
<h2 id="12-防刷限流"><a href="#12-防刷限流" class="headerlink" title="12. 防刷限流"></a>12. 防刷限流</h2><h3 id="12-1-验证码技术"><a href="#12-1-验证码技术" class="headerlink" title="12.1 验证码技术"></a>12.1 验证码技术</h3><p>之前的流程是，用户点击下单后，会直接拿到令牌然后执行下单流程。现在，用户点击下单后，前端会弹出一个”验证码“，用户输入之后，才能请求下单接口。</p>
<p><code>OrderController</code>新开一个<code>generateVerifyCode()</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/generateverifycode"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateVerifyCode</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> BizException, IOException </span>&#123;</span><br><span class="line">    ···验证</span><br><span class="line">    <span class="comment">//验证用户信息</span></span><br><span class="line">    Map&lt;String, Object&gt; map = CodeUtil.generateCodeAndPic();</span><br><span class="line">    <span class="comment">//生成的验证码存到Redis里，并设置过期时间</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"verify_code_"</span> + userModel.getId(), map.get(<span class="string">"code"</span>));</span><br><span class="line">    redisTemplate.expire(<span class="string">"verify_code_"</span> + userModel.getId(), <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//生成的图片，响应到前端页面</span></span><br><span class="line">    ImageIO.write((RenderedImage) map.get(<span class="string">"codePic"</span>), <span class="string">"jpeg"</span>, response.getOutputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前获取秒杀令牌的<code>generateToken()</code>接口，需要添加验证码校验逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">generateToken</span><span class="params">(··· @RequestParam(name = <span class="string">"verifyCode"</span>)</span> String verifyCode) <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">    <span class="comment">//验证用户登录信息</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//验证验证码的有效性</span></span><br><span class="line">    String redisVerifyCode = (String) redisTemplate.opsForValue().get(<span class="string">"verify_code_"</span> + userModel.getId());</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(redisVerifyCode))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"请求非法"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!redisVerifyCode.equalsIgnoreCase(verifyCode))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"请求非法"</span>);</span><br><span class="line">    <span class="comment">//获取秒杀访问令牌</span></span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，就实现了在下单之前，添加一个验证码，限制部分流量的功能。</p>
<h3 id="12-2-限流方案——限并发"><a href="#12-2-限流方案——限并发" class="headerlink" title="12.2 限流方案——限并发"></a>12.2 限流方案——限并发</h3><p>限制并发量意思就是同一时间<strong>只有一定数量的线程去处理请求</strong>，实现也比较简单，维护一个<strong>全局计数器</strong>，当请求进入接口时，计数器-1，并且判断计数器是否&gt;0，大于0则处理请求，小于0则拒绝等待。</p>
<p>但是一般衡量并发性，是用TPS或者QPS，而该方案由于限制了线程数，自然不能用TPS或者QPS衡量。</p>
<h3 id="12-3-限流方案——令牌桶-漏桶"><a href="#12-3-限流方案——令牌桶-漏桶" class="headerlink" title="12.3 限流方案——令牌桶/漏桶"></a>12.3 限流方案——令牌桶/漏桶</h3><h4 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h4><p>客户端请求接口，必须先从令牌桶中获取令牌，令牌是由一个”定时器“定期填充的。在一个时间内，令牌的数量是有限的。令牌桶的大小为100，那么TPS就为100。</p>
<p><img src="https://raw.githubusercontent.com/MaJesTySA/miaosha_Shop/master/imgs/tokenBucket.png" alt></p>
<h4 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h4><p>客户端请求接口，会向漏桶里面”加水“。漏桶每秒漏出一定数量的”水“，也就是处理请求。只有当漏桶不满时，才能请求。</p>
<p><img src="https://raw.githubusercontent.com/MaJesTySA/miaosha_Shop/master/imgs/leekBucket.png" alt></p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>漏桶无法应对<strong>突发流量</strong>，比如突然来10个请求，只能处理一个。但是令牌桶，可以一次性处理10个。所以令牌桶用得比较多。</p>
<h3 id="12-4-限流力度"><a href="#12-4-限流力度" class="headerlink" title="12.4 限流力度"></a>12.4 限流力度</h3><p>分为<strong>接口维度</strong>和<strong>总维度</strong>，很好理解。接口维度就是限制某个接口的流量，而总维度是限制所有接口的流量。</p>
<h3 id="12-5-限流范围"><a href="#12-5-限流范围" class="headerlink" title="12.5 限流范围"></a>12.5 限流范围</h3><p>分为<strong>集群限流</strong>和<strong>单机限流</strong>，集群限流顾名思义就是限制整个集群的流量，需要用Redis或者其他中间件技术来做统一计数器，往往会产生性能瓶颈。单机限流在负载均衡的前提下效果更好。</p>
<h3 id="12-6-RateLimiter限流实现"><a href="#12-6-RateLimiter限流实现" class="headerlink" title="12.6 RateLimiter限流实现"></a>12.6 RateLimiter限流实现</h3><p><code>google.guava.RateLimiter</code>就是令牌桶算法的一个实现类，<code>OrderController</code>引入这个类，在<code>init</code>方法里面，初始令牌数量为200。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//20个线程的线程池</span></span><br><span class="line">    executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//200个令牌，即200TPS</span></span><br><span class="line">    orderCreateRateLimiter = RateLimiter.create(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求<code>createOrder()</code>接口之前，会调用<code>RateLimiter.tryAcquire()</code>方法，看当前令牌是否足够，不够直接抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f (!orderCreateRateLimiter.tryAcquire())</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.RATELIMIT);</span><br></pre></td></tr></table></figure>
<h3 id="12-7-防刷技术"><a href="#12-7-防刷技术" class="headerlink" title="12.7 防刷技术"></a>12.7 防刷技术</h3><p>排队、限流、令牌只能控制总流量，无法控制黄牛流量。</p>
<h4 id="传统防刷技术"><a href="#传统防刷技术" class="headerlink" title="传统防刷技术"></a>传统防刷技术</h4><ul>
<li>限制一个会话(Session、Token)一定时间内请求接口的次数。多会话接入绕开无效，比如黄牛可以开启多个会话。</li>
<li>限制一个IP一定时间内请求接口的次数。容易误伤，某个局域网内的正常用户共享一个IP进行访问。而且IP可以被伪造。</li>
</ul>
<h4 id="黄牛为什么难防"><a href="#黄牛为什么难防" class="headerlink" title="黄牛为什么难防"></a>黄牛为什么难防</h4><ul>
<li>模拟硬件设备，比如手机。一个看似正常的用户，可能是用模拟器模拟出来的。</li>
<li>设备牧场，一屋子手机刷接口</li>
<li>人工作弊，这个最难防，情真人刷接口</li>
</ul>
<h4 id="防黄牛方案"><a href="#防黄牛方案" class="headerlink" title="防黄牛方案"></a>防黄牛方案</h4><ul>
<li><strong>设备指纹方式：</strong>采集终端设备各项数据，启动应用时生成一个唯一设备指纹。根据对应设备的指纹参数，估计是可疑设备的概率。</li>
<li><strong>凭证系统：</strong>根据设备指纹下发凭证，在关键业务链路上带上凭证并有凭证服务器验证。凭证服务器根据设备指纹参数和风控系统判断凭证的可疑程度。若凭证分数低于设定值，则开启验证</li>
</ul>
<h3 id="12-8-小结"><a href="#12-8-小结" class="headerlink" title="12.8 小结"></a>12.8 小结</h3><ul>
<li>通过引入验证码技术，在发送秒杀令牌之前，再做一层限流</li>
<li>介绍了三种限流方案，使用<code>RateLimiter</code>实现了令牌桶限流</li>
<li>介绍了常见的防刷技术以及它们的缺点。介绍了黄牛为什么难防，应该怎样防。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/秒杀系统/" rel="tag"># 秒杀系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/25/Linux 五种IO模型/" rel="next" title="Linux 五种IO模型">
                <i class="fa fa-chevron-left"></i> Linux 五种IO模型
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/30/乐观锁与悲观锁/" rel="prev" title="乐观锁与悲观锁">
                乐观锁与悲观锁 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g2/M00/05/05/Cg-4WlVdf2mIQWEzABhFqZtzpSYAAD5OgH-m3MAGEXB992.jpg" alt="RicardoXu">
            
              <p class="site-author-name" itemprop="name">RicardoXu</p>
              <p class="site-description motion-element" itemprop="description">技术博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-业务"><span class="nav-number">1.</span> <span class="nav-text">1.业务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户业务："><span class="nav-number">1.1.</span> <span class="nav-text">用户业务：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#商品业务："><span class="nav-number">1.2.</span> <span class="nav-text">商品业务：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交易业务："><span class="nav-number">1.3.</span> <span class="nav-text">交易业务：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#秒杀业务："><span class="nav-number">1.4.</span> <span class="nav-text">秒杀业务：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-需要改进的地方"><span class="nav-number">2.</span> <span class="nav-text">2.需要改进的地方</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#秒杀优化部分："><span class="nav-number"></span> <span class="nav-text">秒杀优化部分：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-单机服务器并发容量问题"><span class="nav-number">1.</span> <span class="nav-text">3.单机服务器并发容量问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-默认内嵌Tomcat配置"><span class="nav-number">1.1.</span> <span class="nav-text">3.1 默认内嵌Tomcat配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-SpringBoot内嵌tomcat线程优化"><span class="nav-number">1.2.</span> <span class="nav-text">3.2 SpringBoot内嵌tomcat线程优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-SpringBoot内嵌Tomcat网络连接优化"><span class="nav-number">1.3.</span> <span class="nav-text">3.3 SpringBoot内嵌Tomcat网络连接优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-小结"><span class="nav-number">1.4.</span> <span class="nav-text">3.4 小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-接下来的优化方向"><span class="nav-number">1.5.</span> <span class="nav-text">3.5 接下来的优化方向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-分布式扩展优化"><span class="nav-number">2.</span> <span class="nav-text">4. 分布式扩展优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-nginx作用："><span class="nav-number">2.1.</span> <span class="nav-text">4.1 nginx作用：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-分布式会话"><span class="nav-number">3.</span> <span class="nav-text">5. 分布式会话</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-查询优化之多级缓存"><span class="nav-number">4.</span> <span class="nav-text">6. 查询优化之多级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.1.</span> <span class="nav-text">项目架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-优化商品查询接口——单机版redis思路"><span class="nav-number">4.2.</span> <span class="nav-text">6.1 优化商品查询接口——单机版redis思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-优化商品查询接口——本地热点缓存"><span class="nav-number">4.3.</span> <span class="nav-text">6.2 优化商品查询接口——本地热点缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-本地缓存缺点"><span class="nav-number">4.4.</span> <span class="nav-text">6.3 本地缓存缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-Nginx缓存"><span class="nav-number">4.5.</span> <span class="nav-text">6.4 Nginx缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-查询优化之页面静态化"><span class="nav-number">5.</span> <span class="nav-text">7.  查询优化之页面静态化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-CDN"><span class="nav-number">5.1.</span> <span class="nav-text">7.1 CDN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-全页面静态化"><span class="nav-number">5.2.</span> <span class="nav-text">7.2 全页面静态化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-交易优化之缓存库存"><span class="nav-number">6.</span> <span class="nav-text">8. 交易优化之缓存库存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-交易接口瓶颈"><span class="nav-number">6.1.</span> <span class="nav-text">8.1 交易接口瓶颈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-交易验证优化"><span class="nav-number">6.2.</span> <span class="nav-text">8.2 交易验证优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1-用户校验缓存化"><span class="nav-number">6.2.1.</span> <span class="nav-text">8.2.1 用户校验缓存化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2-活动校验缓存优化"><span class="nav-number">6.2.2.</span> <span class="nav-text">8.2.2 活动校验缓存优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-3-缓存优化后的效果"><span class="nav-number">6.2.3.</span> <span class="nav-text">8.2.3 缓存优化后的效果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-库存扣减优化"><span class="nav-number">6.3.</span> <span class="nav-text">8.3 库存扣减优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-1-索引优化"><span class="nav-number">6.3.1.</span> <span class="nav-text">8.3.1 索引优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-2-库存扣减缓存优化"><span class="nav-number">6.3.2.</span> <span class="nav-text">8.3.2 库存扣减缓存优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RocketMQ"><span class="nav-number">6.3.2.1.</span> <span class="nav-text">RocketMQ</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#同步缓存库存到数据库（异步扣减库存）"><span class="nav-number">6.3.2.2.</span> <span class="nav-text">同步缓存库存到数据库（异步扣减库存）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异步扣减库存存在的问题"><span class="nav-number">6.3.2.3.</span> <span class="nav-text">异步扣减库存存在的问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-小结"><span class="nav-number">6.4.</span> <span class="nav-text">8.4 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-交易优化之事务型优化"><span class="nav-number">7.</span> <span class="nav-text">9. 交易优化之事务型优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-异步消息发送时机问题"><span class="nav-number">7.1.</span> <span class="nav-text">9.1 异步消息发送时机问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解决方法"><span class="nav-number">7.1.1.</span> <span class="nav-text">解决方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-事务提交问题"><span class="nav-number">7.2.</span> <span class="nav-text">9.2 事务提交问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解决方法-1"><span class="nav-number">7.2.1.</span> <span class="nav-text">解决方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-事务型消息"><span class="nav-number">7.3.</span> <span class="nav-text">9.3 事务型消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#更新下单流程"><span class="nav-number">7.3.1.</span> <span class="nav-text">更新下单流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-小结"><span class="nav-number">7.4.</span> <span class="nav-text">9.4 小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5-接下来的优化方向"><span class="nav-number">7.5.</span> <span class="nav-text">9.5 接下来的优化方向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-库存流水"><span class="nav-number">8.</span> <span class="nav-text">10. 库存流水</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-下单操作的处理"><span class="nav-number">8.1.</span> <span class="nav-text">10.1 下单操作的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-UNKNOWN状态处理"><span class="nav-number">8.2.</span> <span class="nav-text">10.2 UNKNOWN状态处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-库存售罄处理"><span class="nav-number">8.3.</span> <span class="nav-text">10.3 库存售罄处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-小节"><span class="nav-number">8.4.</span> <span class="nav-text">10.4 小节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可以改进的地方"><span class="nav-number">8.4.1.</span> <span class="nav-text">可以改进的地方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接下来的优化方向"><span class="nav-number">8.4.2.</span> <span class="nav-text">接下来的优化方向</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-流量削峰"><span class="nav-number">9.</span> <span class="nav-text">11. 流量削峰</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-业务解耦——秒杀令牌"><span class="nav-number">9.1.</span> <span class="nav-text">11.1 业务解耦——秒杀令牌</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-限流——令牌大闸"><span class="nav-number">9.2.</span> <span class="nav-text">11.2 限流——令牌大闸</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#令牌大闸限流缺点"><span class="nav-number">9.2.1.</span> <span class="nav-text">令牌大闸限流缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-限流——队列泄洪"><span class="nav-number">9.3.</span> <span class="nav-text">11.3 限流——队列泄洪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-小结"><span class="nav-number">9.4.</span> <span class="nav-text">11.4 小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-5-接下来的优化方向"><span class="nav-number">9.5.</span> <span class="nav-text">11.5 接下来的优化方向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-防刷限流"><span class="nav-number">10.</span> <span class="nav-text">12. 防刷限流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-验证码技术"><span class="nav-number">10.1.</span> <span class="nav-text">12.1 验证码技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-限流方案——限并发"><span class="nav-number">10.2.</span> <span class="nav-text">12.2 限流方案——限并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-限流方案——令牌桶-漏桶"><span class="nav-number">10.3.</span> <span class="nav-text">12.3 限流方案——令牌桶/漏桶</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#令牌桶"><span class="nav-number">10.3.1.</span> <span class="nav-text">令牌桶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#漏桶"><span class="nav-number">10.3.2.</span> <span class="nav-text">漏桶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区别"><span class="nav-number">10.3.3.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-限流力度"><span class="nav-number">10.4.</span> <span class="nav-text">12.4 限流力度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-5-限流范围"><span class="nav-number">10.5.</span> <span class="nav-text">12.5 限流范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-6-RateLimiter限流实现"><span class="nav-number">10.6.</span> <span class="nav-text">12.6 RateLimiter限流实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-7-防刷技术"><span class="nav-number">10.7.</span> <span class="nav-text">12.7 防刷技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传统防刷技术"><span class="nav-number">10.7.1.</span> <span class="nav-text">传统防刷技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#黄牛为什么难防"><span class="nav-number">10.7.2.</span> <span class="nav-text">黄牛为什么难防</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#防黄牛方案"><span class="nav-number">10.7.3.</span> <span class="nav-text">防黄牛方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-8-小结"><span class="nav-number">10.8.</span> <span class="nav-text">12.8 小结</span></a></li></ol></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RicardoXu</span>
  <span>&nbsp;<a href="http://www.miitbeian.gov.cn/">赣ICP备16002615号-1</a></span>

  
</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
