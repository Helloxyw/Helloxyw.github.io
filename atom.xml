<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RicardoXu博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-08T14:16:37.650Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>RicardoXu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kafak</title>
    <link href="http://yoursite.com/2020/04/08/kafka/"/>
    <id>http://yoursite.com/2020/04/08/kafka/</id>
    <published>2020-04-07T16:00:00.000Z</published>
    <updated>2020-04-08T14:16:37.650Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3>1. 消息队列的好处</h3><p></p><ul><li>缓存和削峰： 上游数据时有突发流量，下游可能扛不住，或者下游没有足够的机器来保证冗余，kafka在中间可以起到一个缓冲作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理</li></ul><p><img src="https://images.vogel.de/vogelonline/bdb/1484300/1484344/41.jpg" alt><br><a id="more"></a></p><ul><li>解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。</li><li>冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用</li><li>健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。</li><li>异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它。</li></ul><p></p><h3>2.消息队列通信的模式</h3><br><strong>一、点对点模式（队列模式）</strong><p></p><p><img src="https://pic3.zhimg.com/80/v2-8ca010d65aa8e4c385a901fb2e91f31a_1440w.jpg" alt="image-20191226210942873"></p><blockquote><p>点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。</p></blockquote><p><strong>二、发布订阅模式</strong></p><p><img src="https://pic4.zhimg.com/80/v2-92c5c49e68a6213914936ed979c05c6b_1440w.jpg" alt="image-20191226211754863"></p><blockquote><p>发布订阅模式是一个基于消息推送的消息传送模型，该模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将该消息推送给订阅过该类消息的消费者（类似微信公众号）。由于消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅者模式的一个问题！假设三个消费者的处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受！如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费！</p></blockquote><p><strong>kafka采用的模式</strong></p><p>两种方式各有优缺点：</p><ul><li>点对点模式中多个消费者共同消费同一个队列，效率高</li><li>发布订阅模式，一个消息可以被多次消费，能支持冗余的消费（例如两个消费者共同消费一个消息，防止某个消费者挂了）</li></ul><p>显然要构建一个大数据下消息队列，两种模式都是必需的。因此kafka引入了ConsumerGroup（消费组）的概念，Consumer Group是以发布订阅模式工作的；一个Consumer Group中可以有多个Consumer，Group内的Consumer以点对点模式工作。</p><p><img src="https://lotabout.me/2018/kafka-introduction/kafka-consumer-group.svg" alt="image-20191228151527931"></p><p></p><h3>3.Kafka基础架构及术语</h3><br><strong>kafka是一种高吞吐量的分布式发布订阅消息系统</strong>，它可以处理消费者规模的网站中的所有动作流数据。具有：<p></p><ul><li>高吞吐量</li><li>低延迟</li><li>容错</li><li>耐久性</li><li>可扩展性</li></ul><p><img src="https://pic1.zhimg.com/80/v2-4692429e9184ed4a93911fa3a1361d28_1440w.jpg" alt="image-20191228135443219"></p><p><strong>相关概念：</strong></p><ul><li>Producer： 生产者，消息的生产者，是消息的入口</li></ul><p><strong>Kafka Cluster</strong></p><ul><li>Broker：kafka实例，每个服务器上有一个或多个kafka实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个<strong>不重复</strong>的编号，如图中的broker-0、broker-1等。。。</li><li>Topic：消息的主题，可以理解为消息的分类，kafka数据就保存在topic。每个broker上可以创建多个topic</li><li>Partition：Topic的分区，每个topic可以有多个分区，分区的作用就是负载，提高kafka的吞吐量。同一个topic在不同分区的数据不重复的，partition的表现形式就是一个个文件夹。</li><li>Replication：每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader)故障的时候会选择一个备胎（Follower)上位，成为Leader。在kafka中默认副本最大数目是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一分区也只可能存放一个副本（包括自己）</li><li>Message：每一条发送的消息主体</li><li>Consumer：消费者，即消息的消费方，是消息的出口</li><li>ConsumerGroup：我们可以将多个消费者组成一个消费组，在kafka的设计中同一个分区的数据只能被消费组中的某一个消费者消费。同一个消费组的消费者可以消费同一个topic的不同分区的数据，这是为了提高kafka的吞吐量。</li><li>Zookeeper：kafka集群依赖zookeeper来保存集群的元数据，来保证系统的可用性。</li></ul><p></p><h3>4.工作流程分析</h3><br><strong>发送数据</strong><p></p><p>Producer在写入数据时<strong>永远的找Leader</strong>，不会直接将数据写入Follower。写入的流程如下图：</p><p><img src="https://pic2.zhimg.com/80/v2-b7e72e9c5b9971e89ec174a2c2201ed9_1440w.jpg" alt="image-20191228142209444"></p><p>需要注意的一点：消息写入Leader后，follower是主动的去leader同步的！Producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证<strong>同一分区</strong>内的数据是有序的！</p><p><img src="https://pic3.zhimg.com/80/v2-87d558aaa349bf920711b9c157e11f6a_1440w.jpg" alt="image-20191228142638781"></p><p>上面说到数据会写入不同的分区，kafka分区的主要目的是：</p><ul><li>方便扩展：因为同一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量</li><li>提高并发：以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</li></ul><p>​        </p><p>​        熟悉负载均衡的同学应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，producer又怎么知道该将数据发往哪个partition呢？kafka有以下几个原则：</p><ol><li>partition在写入是可以指定需要写入的partition，如果有指定，则写入对应的partition</li><li>如果没有指定partition，但是设置了数据的key，则会根据key值hash出一个partition</li><li>如果没有指定partition，又没有设置key，则会轮询出一个partition</li></ol><p>​        保证数据不丢失是一个消息中间件的基本保证，那producer在向kafka写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过ACK应答机制！在生产者向队列写入数据时，可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为0、1、-1（all）。</p><ul><li>0：代表producer往集群发送数据，不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高</li><li>1：代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功</li><li>-1：代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有副本都完成备份，安全性最高，但是效率最低</li></ul><p>最后需要注意的是，如果往不存在topic写数据，能不能写入成功呢？kafka会自动创建topic，分区和副本的数量根据默认值都是1。</p><p><strong>保存数据</strong></p><p>topic可以分为一个或多个partition，partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早起版本中没有）三个文件，log文件实际上就是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。</p><p><img src="https://pic4.zhimg.com/80/v2-72e50c12fd9c6fbf58d3b5ca14c90623_1440w.jpg" alt="image-20191228144748824"></p><p>如上图，这个partition有三组segment文件，每个log文件大小是一样的，但是存储message数量不一定相等的（每条message大小不一致）。文件的命名就是以该segment最小offset来命名的，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。</p><p><strong>Message结构</strong></p><p>存入log的message主要包含消息体、消息大小、offset、压缩类型。。。等等！重点了解下面三个：</p><ul><li>offset：offset是一个占用8byte的语有序id号，它可以唯一确定每条消息在partition内的位置！</li><li>消息大小：消息大小占用4byte,用于描述消息的大小</li><li>消息体：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不会一样。</li></ul><p><strong>存储策略</strong></p><p>无论消息是否被消费，kafka都会保存所有的消息。那么对于旧数据有什么删除策略?</p><ul><li>基于时间，默认配置是168小时（7天）</li><li>基于大小，默认配置1073741824</li></ul><p>需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka性能！</p><p><strong>消费数据</strong></p><p>消息存储在log文件后，消费者就可以进行消费了。消费组内的消费者是以点对点模式进行消费，消费者主动的去kafka集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找leader去拉取。</p><p>多个消费者可以组成一个消费者组（Consumer Group），每个消费者组都有一个组id！同一个Consumer Group下的Consumer可以消费同一个topic下不同partition的数据，但是不会组内多个Consumer消费同一个partition的数据。</p><p><img src="https://pic4.zhimg.com/80/v2-75a79cba9cfafe5c2f4d5349acb72207_1440w.jpg" alt="image-20191228152107909"></p><p>图示是Consumer Group内的Consumer小于partition数量的情况，所以会出现某个Consumer消费多个partition数据的情况，消费的速度也就不及只处理一个partition的Consumer的处理速度！如果Consumer Group的Consumer多于Partition的数量，那会不会出现多个Consumer消费同一个partition的数据呢？上面已经提到不会出现这种情况！多出来的Consumer不消费任何partition的数据。所以在实际的应用中，建议<strong>Consumer Group的Consumer数量于Partition的数量一致！</strong></p><p><strong>查找message</strong></p><p>假如现在需要查找一个offset为368801的message是什么样的过程？</p><p><img src="https://pic1.zhimg.com/80/v2-87051d884344edf9f8fd97a3dacb32d0_1440w.jpg" alt="image-20191228152622924"></p><ol><li>先找到offset为368801的message所在的segment文件（利用二分查找），在这里找到的就是第二个segment文件。</li><li>打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找offset为368801的message在该index内的偏移量为368796+5  = 368801，所以这里要查找的<strong>相对offset</strong>为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的那个索引</li><li>根据找到的相对offset为4的索引确定message存储的物理偏移量位置为256，打开数据文件，从位置为256那个地方开始顺序扫描直到找到offset为368801的那条message。</li></ol><p>这套机制是建立在offset为有序的基础上，利用<strong>segment + 有序offset + 稀疏索引 + 二分查找 + 顺序查找</strong>等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的offset维护到zookeeper中，Consumer每隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的offset以及直接维护在kafka集群的_consumer_offsets这个topic中。</p><p></p><h3>参考</h3><p></p><ul><li><p>稀疏索引</p><p><img src="https://s1.ax1x.com/2020/04/08/GhnHHg.png" alt="GhnHHg.png"></p></li></ul><p></p><h3>面试题</h3><br><strong>1.Kafka中的ISR、AR代表什么？ISR的伸缩性又指什么？</strong><p></p><p>提到副本，肯定就会想到正本。副本是正本的拷贝。在kafka中，正本和副本都称为副本(Replica)，但存在leader和follower之分。</p><ul><li>ISR：In-Sync Replicas 副本同步队列（所有与leader副本保持一定程度同步的副本，包括leader副本）</li><li>AR: Assigned Replicas 所有副本</li><li>OSR：Out-of-Sync Replicas  于leader副本同步滞后过多的副本（不包含leader副本）</li></ul><p>ISR集合是AR集合的子集。消息会先发送给leader副本，然后follower副本才能从leader副本中拉取消息进行同步。同步期间，follower副本相对于leader副本而言会有一定程度的滞后。<code>一定程度的滞后</code>是指可忍受的滞后范围，这个范围可以通过参数配置。</p><p>ISR是由leader维护，follower从leader同步数据有一定延迟：</p><ul><li>延迟时间：replica.lag.time.max.ms（0.9.0.0版本之后只支持延迟时间维度）</li><li>延迟条数：replica.lag.max.message（0.9.0.0版本之前只支持延迟条数维度）</li></ul><p>任意一个超过阈值都会把follower剔除出ISR，存入OSR。由此可见AR = ISR + OSR。正常情况下，所有follower副本都应该与leader副本保持一定程度的同步，即AR = ISR，OR集合为空。</p><p><strong>ISR伸缩性</strong></p><p><strong>leader副本负责维护和跟踪</strong><code>ISR</code>集合中所有follower副本的滞后状态，当follower副本落后太多或失效时，leader副本会把它从ISR集合中剔除。如果<code>OSR</code>集合中有follower副本“追”上了leader副本，那么leader副本会把它从OSR集合转移至ISR集合。默认情况下，当leader副本发生故障时，只有在ISR集合中的follower副本才有资格被选举为新的leader，而在OSR中的副本则没有任何机会。</p><p><strong>2.broker作用</strong></p><p>broker是消息的代理，producer往broker里面的指定topic中写消息，Consumer从broker里面拉取指定topic的消息，然后进行业务处理，broker在中间起到一个代理保存消息的中转站</p><p><strong>3.kafka中zookeeper起到什么作用？可以不用zookeeper么</strong></p><p>zookeeper是一个分布式的协调组件，早起版本kafka用zk做meta信息存储，Consumer的消费状态、Group的管理以及offset的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的Consumer使用了kafka内部的group coordination协议，也逐渐减少了对zookeeper的依赖。</p><p>但是broker依然依赖于zk，zookeeper在kafka中还用来选举controller和检查broker是否存活等。</p><p><strong>4.kafka follower如何与leader同步数据</strong></p><p><img src="https://img-blog.csdnimg.cn/20190425101924979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoZWVwODUyMQ==,size_16,color_FFFFFF,t_70" alt></p><p>kafka的复制既不是完全的同步复制，也不是单纯的异步复制。</p><ul><li>完全同步复制：要求all live follower都复制完，这条消息才算commit，这种复制方式极大影响了吞吐率</li><li>异步复制：follower异步的从leader复制数据，数据只要被leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据</li></ul><p>kafka使用ISR方式很好的均衡了确保数据不丢失以及吞吐率。follower可以批量的从leader复制数据，而且leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了follower与leader的消息量差</p><p><strong>5.如果leader crash时，ISR为空怎么办？</strong></p><p>kafka在broker端提供了一个配置参数：unclean.leader.election，这个参数有两个值：</p><ul><li>true（默认）：允许不同步的副本成为leader，由于不同步副本消息较为滞后，此时成为leader，可能会出现消息不一致的情况</li><li>false：不允许不同步的副本成为leader，此时如果发生ISR列表为空，会一直等待旧leader恢复，降低了可用性</li></ul><p><strong>6.kafka中消息是否会丢失和重复消费？</strong></p><p>要确定kafka的消息是否丢失或重复消费，从两个方面分析入手：消息发送和消息消费</p><p><strong>消息发送</strong></p><p>kafak消息发送有两种方式：同步（sync)和异步（async），默认是同步方式，可通过producer.type 属性进行配置。kafka通过配置request.required.asks属性来确认消息的生产：</p><ul><li>0：表示不进行消息接收是否成功的确认</li><li>1：表示leader接收成功时确认</li><li>-1：表示leader和follower都接收成功时确认</li></ul><p>综上所述，有6种消息生产情况，下面分情况来分析消息丢失的场景：</p><ul><li>Asks =0 :不和kafka进行消息接收确认，则当网络异常、缓冲区满了等情况时，消息可能丢失</li><li>Asks =1 :同步模式下，只有leader确认接收成功后但挂掉了，副本没有同步，数据可能丢失</li></ul><p><strong>消息消费</strong></p><p>kafka消息消费有两个Consumer接口，Low-level API和 High-level API：</p><ul><li>Low-level API：消费者自己维护offset等值，实现对kafka的完全控制</li><li>High-level API：封装了对Partition和offset的管理，使用简单</li></ul><p>如果使用高级接口High-level API，可能存在一个问题就是当消费者从集群中把消息取出来、并提交了新的消息offset值后，还没来得及消费就挂掉了，那么下次再消费时之前没消费成功的消息就”诡异“的消息了</p><p><strong>解决办法</strong></p><ul><li>消息丢失：同步模式下，确认机制设置为-1，即让消息写入leader和follower之后再确认消息发送成功；异步模式下，为防止缓冲区满，可以在配置文件设置不限制阻塞超时时间，当缓冲区满时，让生产者一直处于阻塞状态</li><li>消息重复消费：将消息的唯一标识保存到外部介质中，每次消费时判断是否处理过即可</li></ul><p><strong>7.为什么kafka不支持读写分离</strong></p><p>​        在kafak中，生产者写入消息、消费者读取消息的操作都是与leader副本进行交互的，从而实现的是一种主写主读的生产者消费模型。</p><p>​        kafak并不支持主写从读，因为主写从读有两个很明显的缺点：</p><ul><li>数据一致性问题： 数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中A数据的值都为X，之后将主节点中A的值修改为Y，那么在这个变更通知到从节点之前，应用读取从节点中的A数据的值并不是最新的Y,这就产生了数据不一致的问题</li><li>延时问题：类似Redis这种组件，数据从写入主节点到同步至从节点中的过程需要经历网络-&gt;主节点内存-&gt;网络-&gt;从节点内存这几个阶段，整个过程会耗费一定的时间。而在kafka中，主从同步会比redis更加耗时，他需要经历网络-&gt;主节点内存-&gt;主节点磁盘-&gt;网络-&gt;从节点内存-&gt;从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用</li></ul><p><strong>8.kafka中是怎么体现消息顺序性的？</strong></p><p>kafka每个Partition中的消息在写入时都是有序的，消费时，每个Partition只能被每一个Group中的一个消费者消费，保证了消费时也是有序。</p><p>整个topic不保证有序，如果为了保证整个topic有序，那么将Partition调整为1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h3&gt;1. 消息队列的好处&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存和削峰： 上游数据时有突发流量，下游可能扛不住，或者下游没有足够的机器来保证冗余，kafka在中间可以起到一个缓冲作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://images.vogel.de/vogelonline/bdb/1484300/1484344/41.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="kafak" scheme="http://yoursite.com/tags/kafak/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="http://yoursite.com/2020/04/08/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/04/08/Java集合框架/</id>
    <published>2020-04-07T16:00:00.000Z</published>
    <updated>2020-04-16T08:04:49.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ArrayList-和LinkedList异同"><a href="#1-ArrayList-和LinkedList异同" class="headerlink" title="1. ArrayList 和LinkedList异同"></a>1. ArrayList 和LinkedList异同</h3><ul><li><strong>是否保证线程安全</strong>：ArrayList和LinkedList都是不同步的，也就是不保证线程安全</li><li><strong>底层数据结构</strong>：ArrayList底层使用的是Object数组，LinkedList底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环）</li></ul><p><img src="https://images.cnitblog.com/blog/556852/201308/17200016-b868ad987c4947ceb76c42b44887c783.png" alt><br><a id="more"></a></p><ul><li><strong>插入和删除是否受元素位置的影响：</strong><ul><li>ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置影响，时间复杂度近似O(n)</li><li>LinkedList采用链表存储，所以插入删除元素时间复杂度不受元素位置的影响，时间复杂度近似O(1)</li></ul></li><li><strong>是否支持快速访问：</strong>LinkedList不支持高效的随机元素访问，而ArrayList支持。（快速访问就是通过元素的序号快速获取元素对象（对应于<code>get(int index)</code>方法））</li><li><strong>内存空间占用：</strong><ul><li>ArrayList的空间浪费主要体现在list列表的结尾会预留一定的容量空间</li><li>LinkedList的空间浪费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ul></li></ul><p><strong>补充：RandomAccess接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码，我们发现实际上<code>RandomAccess</code>接口中什么也没有定义。所以RandomAccess接口不过是一个标识罢了。标识什么？标识实现这个接口的类具有随机访问功能。</p><p>在<code>binarySearch()</code>方法中，他要判断传入的list是否<code>RandomAccess</code>的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，调用<code>iteratorBinarySearch()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) </span><br><span class="line">    <span class="keyword">return</span> Collections.indexedBinarySearch(list, key); </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！</p><p>ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！</p><p><strong>下面再总结一下</strong> <strong>list</strong> <strong>的遍历方式选择：</strong></p><ul><li><p>实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,</p></li><li><p>未实现RandomAccess接口的list， 优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大</p></li></ul><p>size的数据，千万不要使用普通for循环</p><h3 id="2-ArrayList-与-Vector-区别"><a href="#2-ArrayList-与-Vector-区别" class="headerlink" title="2. ArrayList 与 Vector 区别"></a>2. <strong>ArrayList</strong> <strong>与</strong> <strong>Vector</strong> 区别</h3><ul><li><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p></li><li><p>Arraylist不是同步的，所以在不需要保证线程安全时建议使用Arraylist。</p></li></ul><h3 id="3-HashMap的底层实现"><a href="#3-HashMap的底层实现" class="headerlink" title="3.HashMap的底层实现"></a>3.HashMap的底层实现</h3><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap</strong> <strong>通过</strong> <strong>key</strong> <strong>的</strong> <strong>hashCode</strong> <strong>经过扰动函数处理过后得到</strong> <strong>hash</strong> <strong>值，然后通过</strong> <code>(n - 1) &amp; hash</code> <strong>判断当前元素存放的位置（这里的</strong> <strong>n</strong> <strong>指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的</strong> <strong>hash</strong> <strong>值以及</strong> <strong>key</strong> <strong>是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><blockquote><p><strong>所谓扰动函数指的就是</strong> <strong>HashMap</strong> <strong>的</strong> <strong>hash</strong> <strong>方法。使用</strong> <strong>hash</strong> <strong>方法也就是扰动函数是为了防止一些实现比较差的</strong>hashCode() <strong>方法 ,换句话说使用扰动函数之后可以减少碰撞。</strong></p></blockquote><p><strong>JDK 1.8 HashMap</strong> <strong>的</strong> <strong>hash</strong> <strong>方法源码</strong></p><p>JDK 1.8 的hash方法相比于 JDK 1.7 hash方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> h; </span><br><span class="line">  <span class="comment">// key.hashCode()：返回散列值也就是hashcode </span></span><br><span class="line">  <span class="comment">// ^ ：按位异或 </span></span><br><span class="line">  <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 </span></span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This function ensures that hashCodes that differ only by </span></span><br><span class="line">  <span class="comment">// constant multiples at each bit position have a bounded </span></span><br><span class="line">  <span class="comment">// number of collisions (approximately 8 at default load factor). </span></span><br><span class="line">  h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>); <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><blockquote><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p></blockquote><p><img src="/Users/ricardo/Library/Application Support/typora-user-images/image-20200105194913491.png" alt="image-20200105194913491"></p><h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><p>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/Users/ricardo/Library/Application Support/typora-user-images/image-20200105194953598.png" alt="image-20200105194953598"></p><blockquote><p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺</p><p>陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><p><strong>推荐阅读</strong></p><ul><li>《Java 8系列之重新认识HashMap》 ：<a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></li></ul><h3 id="4-HashMap和HashTable的区别"><a href="#4-HashMap和HashTable的区别" class="headerlink" title="4.HashMap和HashTable的区别"></a>4.HashMap和HashTable的区别</h3><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过</li></ol><p><code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）</p><ol><li><p><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p></li><li><p><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 <code>NullPointerException</code>。 </p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> </p><p>①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</p><p>②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的 tableSizeFor() 方法保证）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</p></li><li><p><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为</p></li></ol><p>8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p><h3 id="5-HashMap的长度为什么是2的幂次方"><a href="#5-HashMap的长度为什么是2的幂次方" class="headerlink" title="5.HashMap的长度为什么是2的幂次方"></a>5.HashMap的长度为什么是2的幂次方</h3><p>​        HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。<br>​        这个算法实际就是取模，<code>hash%length</code>，计算机中直接求余效率不如位移运算，源码中做了优化<code>hash&amp;(length-1)</code>，<code>hash%length</code>==<code>hash&amp;(length-1)</code>的前提是length是2的n次方；这就解释了<code>HashMap</code>的长度为什么是2的幂次方。</p><h3 id="6-HashSet和HashMap的区别"><a href="#6-HashSet和HashMap的区别" class="headerlink" title="6.HashSet和HashMap的区别"></a>6.HashSet和HashMap的区别</h3><p>如果你看过HashSet源码就应该知道：HashSet底层就是基于HashMap实现到。（HashSet源码非常非常少，因为除了clone()方法、writeObject()方法、readObject()方法是HashSet自己不得不实现之外，其他方法都是直接调用HashMap中的方法。）</p><p><img src="/Users/ricardo/Library/Application Support/typora-user-images/image-20200105202437786.png" alt="image-20200105202437786"></p><h3 id="7-ConcurrentHashMap和HashTable的区别"><a href="#7-ConcurrentHashMap和HashTable的区别" class="headerlink" title="7.ConcurrentHashMap和HashTable的区别"></a>7.ConcurrentHashMap和HashTable的区别</h3><ul><li><p><strong>底层数据结构：</strong>JDK1.7以前的<code>ConcurrentHashMap</code>底层采用 <strong>分段的数组+链表</strong>实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。HashTable和JDK1.8之前的HashMap的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是HashMap的主体，链表则是为了解决哈希冲突而存在的。</p></li><li><p><strong>实现线程安全的方式（重要）：</strong></p><ul><li><strong>在JDK1.7的时候，ConcurrentHashMap(分段锁)</strong> 对整个桶数组进行了分割分段（Segment），每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发率。 <strong>到了JDK1.8的时候已经摒弃了Segment的概念，而是直接用Node数组 + 链表 + 红黑树的数据结构来实现，并发控制使用synchronized和 CAS来操作。（JDK1.6以后对synchronized锁做了很多优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销）</strong>整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本</li><li><strong>HashTable（同一把锁）：</strong> 使用synchronized来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能用get，竞争会越来越激烈，效率越低</li></ul></li></ul><p>  <strong>两者的对比图：</strong></p><p>  <img src="/Users/ricardo/Library/Application Support/typora-user-images/image-20200105204126728.png" alt="image-20200105204126728"></p><p>  <img src="/Users/ricardo/Library/Application Support/typora-user-images/image-20200105204142062.png" alt="image-20200105204142062"></p><p>  <img src="/Users/ricardo/Library/Application Support/typora-user-images/image-20200105204217831.png" alt="image-20200105204217831"></p><h3 id="8-ConcurrentHashMap线程安全的具体实现方式-底层具体实现"><a href="#8-ConcurrentHashMap线程安全的具体实现方式-底层具体实现" class="headerlink" title="8.ConcurrentHashMap线程安全的具体实现方式/底层具体实现"></a>8.ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h3><h4 id="JDK1-7（参考上面示意图）"><a href="#JDK1-7（参考上面示意图）" class="headerlink" title="JDK1.7（参考上面示意图）"></a>JDK1.7（参考上面示意图）</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。</strong></p><p>Segment实现了ReentrantLock，所以Segment是一种可重入锁，扮演锁定角色。HashEntry用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个ConcurrentHashMap包含一个Segment数组。Segment的结构和HashMap类似，是一种数组加链表结构，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构元素，每个Segment守护着HashEntry数组里的元素，当对HashEntry数组里的数据进行修改时，必须首先获得对应的Segment锁。</p><h4 id="JDK1-8（参考上面示意图）"><a href="#JDK1-8（参考上面示意图）" class="headerlink" title="JDK1.8（参考上面示意图）"></a>JDK1.8（参考上面示意图）</h4><p>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构和HashMap 1.8的结构类似，数组+ 链表/红黑二叉树。</p><p>synchronized只锁定当前链表或者红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率提升N倍。</p><h3 id="9-集合框架底层数据结构总结"><a href="#9-集合框架底层数据结构总结" class="headerlink" title="9.集合框架底层数据结构总结"></a>9.集合框架底层数据结构总结</h3><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><p><strong>1.List</strong></p><ul><li><strong>ArrayList：</strong>Object数组</li><li><strong>Vector:</strong> Object数组</li><li><strong>LinkedList：</strong>双向链表（JDK1.6之前为循环链表，JDK1.7取消了循环）</li></ul><p><strong>2.Set</strong></p><ul><li><strong>HashSet（无序，唯一）：</strong>基于HashMap实现的，底层采用HashMap来保存元素</li><li><strong>LinkedHashSet：</strong>LinkedHashSet继承于HashSet，并且内部是通过LinkedHashMap来实现的。</li><li><strong>TreeSet（有序，唯一）：</strong>红黑树（自平衡的排序二叉树）</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><strong>HashMap：</strong>JDK1.8前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时，有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li><li><strong>LinkedHashMap：</strong>LinkedHashMap继承自HashMap，所以它的底层仍然还是基于拉链式的散列式结构，即数组和链表/红黑树组成。另外，LinkedHashMap在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><strong>HashTable：</strong>数组+链表组成，数组是HashTable的主体，链表则是为了解决哈希冲突而存在的，线程安全</li><li><strong>TreeMap：</strong>红黑树（自平衡的排序二叉树）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-ArrayList-和LinkedList异同&quot;&gt;&lt;a href=&quot;#1-ArrayList-和LinkedList异同&quot; class=&quot;headerlink&quot; title=&quot;1. ArrayList 和LinkedList异同&quot;&gt;&lt;/a&gt;1. ArrayList 和LinkedList异同&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;是否保证线程安全&lt;/strong&gt;：ArrayList和LinkedList都是不同步的，也就是不保证线程安全&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;底层数据结构&lt;/strong&gt;：ArrayList底层使用的是Object数组，LinkedList底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnitblog.com/blog/556852/201308/17200016-b868ad987c4947ceb76c42b44887c783.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>GC算法</title>
    <link href="http://yoursite.com/2020/04/08/GC%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/08/GC算法/</id>
    <published>2020-04-07T16:00:00.000Z</published>
    <updated>2020-04-08T13:20:49.447Z</updated>
    
    <content type="html"><![CDATA[<p>GC: 垃圾收集。这里的垃圾是指在系统运行过程中产生的一些无用的对象，这些对象占据着一定的内存空间，如果长期不释放，可能导致OOM</p><p>GC对象是 Java堆和方法区</p><p><img src="https://ionutbalosin.com/wp-content/uploads/2019/12/java-garbage-collector-types.png" alt><br><a id="more"></a></p><ol><li>引用计数算法 （效率高，实现简单，但存在循环引用问题）</li><li>根搜索算法 当GCRoots到某一个对象不达时，认为这个对象可以被回收</li></ol><ul><li>标记清除算法（效率低，递归方式还有全堆对象遍历，清理出来的空闲内存不连续）：<ul><li>标记阶段：通过根节点，标记所有从根节点开始可到达的对象</li><li>清除阶段：清除所有未被标记的对象</li></ul></li><li><p>复制算法（适合新生代GC,缺点是空间浪费）：将内存空间分为两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收</p></li><li><p>标记-整理算法（适合老年代GC,效率不太高，低于复制算法)：首先需要从根节点开始，对所有可达对象做一次标记；但之后，它并不简单的清理未标记的对象，而是<strong>将所有的存活对象压缩到内存的一端；</strong>之后，清理边界外所有的空间。</p></li><li>分代收集算法：短命对象归为新生代、长命对象归为老年代<ul><li>少量对象存活，适合复制算法</li><li>大量对象存活，适合标记清除/标记整理算法</li></ul></li></ul><p><strong>可触及性：</strong></p><p>所有的算法，需要能够识别一个垃圾对象，因此需要给出一个可触及性的定义。</p><p><strong>可触及的：</strong></p><p>　　从根节点可以触及到这个对象。</p><p>  　　其实就是从根节点扫描，只要这个对象在引用链中，那就是可触及的。</p><p><strong>可复活的：</strong></p><p>　　一旦所有引用被释放，就是可复活状态</p><p>　　因为在finalize()中可能复活该对象</p><p><strong>不可触及的：</strong></p><p>　　在finalize()后，可能会进入不可触及状态</p><p>　　不可触及的对象不可能复活</p><p>  　　要被回收。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GC: 垃圾收集。这里的垃圾是指在系统运行过程中产生的一些无用的对象，这些对象占据着一定的内存空间，如果长期不释放，可能导致OOM&lt;/p&gt;
&lt;p&gt;GC对象是 Java堆和方法区&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ionutbalosin.com/wp-content/uploads/2019/12/java-garbage-collector-types.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://yoursite.com/2020/04/07/Redis/"/>
    <id>http://yoursite.com/2020/04/07/Redis/</id>
    <published>2020-04-06T16:00:00.000Z</published>
    <updated>2020-04-07T14:46:24.681Z</updated>
    
    <content type="html"><![CDATA[<h3>1.Redis简介</h3><br>简单来说redis就是一个数据库，不过与传统数据库不同的是redis的数据是存在内存中的，所以读写速度非常快，因此redis被广泛应用于缓存方向。另外，redis也经常被用来做分布式锁。redis提供了多种数据类型来支持不同的业务场景。除此之外，redis支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案<br><br><img src="https://miro.medium.com/max/1200/1*DPd3_f1ruu3rrkgaFeo2Ug.png" alt><br><br><a id="more"></a><br><br><h3>2.为什么要用redis做缓存?</h3><br>主要从<code>高性能</code>和<code>高并发</code>这两点来看待这个问题<br><br><strong>高性能</strong><br><br>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的访问数据存在缓存中，这样下一次再访问这些数据时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变了之后，同步改变缓存中相应数据即可<br><br><strong>高并发</strong><br><br>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户一部分的请求会直接到缓存这里，而不用经过数据库<br><br><br><br><strong>3.为什么要用redis而不用map/guava做缓存？</strong><br><br>缓存分为本地缓存和分布式缓存。以Java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。<br><br>使用Redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持redis和memcached服务的高可用，整个程序架构上较为复杂<br><br><br><br><strong>4.redis的线程模型</strong><br><br>redis内部使用文件事件处理器<code>file event handler</code>，这个文件事件处理器是单线程的，所以redis才叫做单线程的模型。它采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理<br><br>文件事件处理器的结构包含4个部分：<br><br><em> 多个socket</em> IO多路复用程序<br><em> 文件事件分派器</em> 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）<br><br>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理<br><br><strong>5.redis和memcached的区别</strong><br><br><em> <strong>redis支持更丰富的数据类型（支持更复杂的应用场景）：</strong>Redis不仅仅支持简单的K/V类型的数据，同时还提供list、set、zest、hash等数据结构的存储。memcached支持简单的数据类型: String</em> redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用；而memcached把数据全部存在内存中<br><em> 集群模式：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是Redis目前是原生支持cluster模式的</em> Memcached是多线程，非阻塞IO复用的网络模型；redis使用单线程的多路IO复用模型<br><br><img src="/Users/ricardo/Library/Application Support/typora-user-images/image-20200101133849862.png" alt="image-20200101133849862"><br><br><strong>6.redis常用数据结构以及使用场景分析</strong><br><br><strong>6.1 String</strong><br><br>&gt;常用命令：set、get、decr、incr、mget等<br><br>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。常规key-value缓存应用；常规计数：微博数、粉丝数等<br><br><strong>6.2 Hash</strong><br><br>&gt; 常用命令：hget、hset、hgetall等<br><br>hash是一个String类型的field和value的映射表，hash特别适合存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。比如我们可以hash数据结构来存储用户信息、商品信息等。比如下面使用hash类型存放一个个人信息：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;</span><br><span class="line">  "id":1,</span><br><span class="line">  "name":"Ricardo",</span><br><span class="line">  "age":24,</span><br><span class="line">  "location":"china"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>6.3 List</strong><br><br>&gt; 常用命令：lpush、rpush、loop、rpop、lrange等<br><br>​        list就是链表，Redis list的应用场景非常多，也是redis最重要的数据结构之一，比如微博的关注列表、粉丝列表、消息列表等功能可以用Redis的list结构来实现。<br><br>​       Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销<br><br>​       另外可以通过lrange命令，就是从某个元素开始读取多少个元素，可以基于list实现分页查询，这个很棒的功能，基于Redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高<br><br><strong>6.4 Set </strong><br><br>&gt; 常用命令：sadd、spoop、smembers、sunion等<br><br>set对外提供的功能和list类似是一个列表的功能，特殊之处在于set是可以自动排重的。<br><br>​        当你需要存储一个列表数据，又不希望出现重复数据使，set可以是一个很好的选择并且set提供了判断某一个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于set轻易实现交集、并集、差集等操作。<br><br>​        比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有的粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinterstore key1 key2 key3</span><br></pre></td></tr></table></figure><br><br><strong>6.5 Sorted set</strong><br><br>&gt; 常用命令：zadd、zrange、zrem、zcard等<br><br>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排序。<br><br>举例：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用Redis中的Sorted Set结构进行存储。<br><br><br><br><strong>7. Redis过期策略</strong><br><br>​        Redis中有个设置时间过期的功能，即对存储在redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的token或者一些登录信息，尤其短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。<br><br>​        我们set key的时候，都可以给一个expire time,就是过期时间，通过过期时间我们可以指定这个key可以存活的时间。如果假设你设置了一批key只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？<br><br>过期策略通常有以下三种：<br><br><em> 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据。从而影响缓存的响应时间和吞吐量。</em> 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除，没过期则返回该key对应的value值。该策略可以最大化地节省CPU资源，却对内存很不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。<br><br><em> 定期过期：每隔一定时间（默认100ms)，会扫描一定数量的数据库的expires字典中一定数量的key,并清除其中已经过期的key。该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下是的CPU和内存资源达到最优的平衡效果<br><br>  （expires字典会保存所有设置了过期时间的key的过期时间数据，其中key是指向键空间中的某个键的指针，value是改建的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键）<br><br>Redis同时采用了<strong>定期删除 + 惰性删除</strong>两种策略。<br><br><br><br><strong>8.Redis内存淘汰策略</strong><br><br>但是仅仅通过设置过期时间还是有问题的。如果定期删除漏了很多过期key，然后你也没有及时去查，也就没有走惰性删除，此时会怎样？如果大量过期的key堆积在内存中，导致redis内存块耗尽了。怎么解决这个问题呢？通过<strong>Redis内存淘汰机制</strong>，redis提供了6种数据淘汰策略：</em> volatile-lru : 从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br><em> Volatile-ttl ：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</em> volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br><em> Allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</em> allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br><em> no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。<br><br>4.0版本以后增加了以下两种：</em> Volatile-lfu：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰<br><em> Allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key<br><br><br><br><strong>9. 缓存雪崩</strong><br><br>如果缓存数据<strong>设置的过期时间是相同的</strong>,导致缓存在某一时刻同时失效，或者缓存服务器宕机导致缓存全面失效，请求全部转发到了DB层面，DB由于瞬间压力增大而导致崩溃，导致整个服务直接瘫痪。这就是缓存雪崩，缓存雪崩导致的雪崩效应对底层系统的冲击是非常大的。<br><br><strong>针对缓存数据设置相同的过期时间，导致某段时间缓存失效，请求全部走数据库</strong>这种情况，非常好解决：<br><br><strong>解决办法（也适用于热点数据集中失效问题）：</strong></em> 第一种：采用加锁或者队列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求走到数据库<br><br><em> 第二种：在缓存的时候给过期时间加上一个<strong>随机值</strong>，这样就会大幅度的<strong>减少缓存在同一时间过期</strong><br><br><strong>针对“redis”挂掉了，请求全部走数据库这种情况，</strong>我们有以下几种思路：</em> 事发前：实现redis的<strong>高可用</strong>（主从架构+Sentinel 或者Redis Cluster），尽量避免Redis挂掉这种情况发生<br><em> 事发中：万一Redis真的挂了，我们可以设置本地缓存（encache) + hystrix限流&amp;降级，避免DB崩掉</em> 事发后：redis持久化，重启后自动从磁盘上加载数据，<strong>快速回复缓存数据</strong><br><br><br><br><strong>10.缓存穿透</strong><br><br>缓存穿透是指查询一个一定<strong>不存在的数据</strong>。由于缓存不命中，并且出于容错考虑，如果<strong>从数据库查不到数据则不写入缓存</strong>，这将导致这个不存在的数据<strong>每次请求都要到数据库去查询</strong>，失去了缓存的意义。<br><br>解决方案：<br><br><em> 第一种：由于每次请求的参数都是不合法的（每次都请求不存在的参数），于是我们可以使用布隆过滤器（BloomFilter)，将所有可能存在的数据哈希到一个足够大的bitMap中，一个一定不存在的数据会被这个bitmap拦截，从而避免对底层存储系统的查询压力。</em> 第二种：当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里去边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个<strong>较短的过期时间</strong><br><br><strong>11.缓存击穿</strong><br><br>在平常高并发的系统中，大量的请求同时查询一个key时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去，造成某一时刻数据库请求量过大，压力剧增。这种现象我们称为<strong>缓存击穿</strong>。<br><br>解决方案：上面的现象是多个线程同时去查询数据库这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。其他线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。<br><br><strong>12. 缓存与数据库双写一致</strong><br><br><strong>读操作</strong><br><br>​        一般我们对于读操作的时候，有这么一个固定套路：<br><br><em> 如果我们的数据在缓存里边有，那么就直接取缓存里的</em> 如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存在中<br><em> 最后将数据返回给请求<br><br><strong>什么是缓存与数据库双写不一致问题？</strong><br><br>​        如果仅仅查询的话，缓存的数据和数据库的数据时没问题的。但是我们要<strong>更新</strong>的时候呢，各种情况很可能<strong>造成数据库和缓存的数据不一致</strong>。<br><br>​        这里的不一致指的是：<strong>数据库的数据和缓存的数据不一致</strong><br><br><img src="/Users/ricardo/Library/Application Support/typora-user-images/image-20200101183328576.png" alt="image-20200101183328576"><br><br><strong>更新操作</strong><br><br>一般来说，执行更新操作，我们会有两种选择：</em> 先操作数据库，再操作缓存<br><em> 先操作缓存，再操作数据库<br><br>首先，要明确的是，无论我们选择操作哪个，我们都希望<strong>这两个操作要么同时成功，要么同时失败。</strong>所以这会演变成<strong>分布式事务</strong>的问题。所以<strong>如果原子性被破坏了</strong>，可能会有以下的情况：</em> 操作数据库失败了，操作缓存失败了<br><em> 操作缓存成功了，操作数据库失败了<br><br>&gt; 如果第一步已经失败了，我们直接返回Exception出去就好了，第二步根本不会执行<br><br>下面具体分析下：<br><br><strong>操作缓存</strong><br><br>操作缓存也有两种方案：</em> 更新缓存<br><em> 删除缓存<br><br>一般我们都是采取<strong>删除缓存</strong>方案，原因如下：</em> 高并发环境下，无论是先操作数据库还是后操作数据库而言，如果加上更新缓存，那就<strong>更容易</strong>导致数据库与缓存数据不一致问题（删除缓存<strong>直接和简单</strong>很多）<br><em> 如果每次更新了数据库，都要更新缓存（这里指的是频繁更新的场景，这会耗费一定的性能），倒不如直接删除掉。等再次读取时，缓存里没有，那我到数据库里找，在数据库找到再写到缓存里边（体现懒加载）<br><br>基于这两点，对于缓存在更新时而言，都是建议执行<strong>删除操作</strong>！<br><br><br><br><strong>（1）先更新数据库，再删除缓存</strong><br><br>正常情况是这样的：</em> 先操作数据库，成功；<br><em> 再删除缓存，成功；<br><br>如果原子性被破坏了：</em> 第一步成功（操作数据库），第二步失败（删除缓存），这会导致<strong>数据库里的是新数据，而缓存里的是旧数据</strong><br><em> 如果第一步（操作数据库）就失败了，我们直接返回错误（Exception），不会出现数据不一致问题<br><br>如果在高并发的场景下，出现数据库与缓存数据不一致的<strong>概率特别低，</strong>也不是没有：</em> 缓存<strong>刚好</strong>失效<br><em> 线程A查询数据库，得到一个旧值</em> 线程B将新值写入数据库<br><em> 线程B删除缓存</em> 线程A将查到的旧值写入缓存<br><br>&gt; 因为这个条件要发生在读数据库时缓存失效，并且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，<strong>而读操作必须在写操作前进入数据库操作，而又要晚于写操作更新缓存，</strong>所以这些条件都具备的概率基本不大<br><br>对于这种策略，其实是一种设计模式：Cache Aside Pattern<br><br><img src="/Users/ricardo/Library/Application Support/typora-user-images/image-20200101185309530.png" alt="image-20200101185309530"><br><br>删除缓存失败的解决思路：<br><br><em> 将需要删除的key发送到消息队列中</em> 自己消费消息，获得需要删除的key<br><em> 不断重试删除操作，直到成功<br><br><strong>（2）先删除缓存，再更新数据库</strong><br><br>正常情况是这样：</em> 先删除缓存，成功；<br><em> 再更新数据库，成功；<br><br>如果原子性被破坏了：</em> 第一步成功（删除缓存），第二步失败（更新数据库），数据库和缓存的数据还是一致的<br><em> 如果第一步（删除缓存）就失败了，我们可以直接返回错误（Exception)，数据库和缓存的数据还是一致的<br><br>看起来是很美好，但是我们在并发场景下分析一下，就知道还是有问题的了：</em> 线程A删除了缓存<br><em> 线程B查询，发现缓存已经不存在</em> 线程B去数据库查询到旧值<br><em> 线程B将旧值写入缓存</em> 线程A将新值写入数据库<br><br>所以也会导致数据库和缓存不一致问题<br><br><strong>并发下解决数据库和缓存不一致的思路：</strong><br><br><em> 将删除缓存、修改数据库、读取缓存等操作积压到队列里边，实现串行化<br><br><img src="/Users/ricardo/Library/Application Support/typora-user-images/image-20200101190113727.png" alt="image-20200101190113727"><br><br><br><br><strong>对比两种策略：</strong></em> 先更新数据库，再删除缓存（Cache Aside Pattern模式）<br>  <em> 在高并发下表现优异，在原子性被破坏时表现不如意</em> 先删除缓存，再更新数据库<br>  * 在高并发下表现不如意，在原子性被破坏时表现优异<br><br><h3>13：如何实现redis分布式锁–面试解答</h3><p>为了实现分布式锁，需要确保锁同时满足以下四个条件：</p><ul><li>互斥性： 在任意时刻，只能有一个客户端能持有锁</li><li>不会发送死锁：即使一个客户端持有锁的期间奔溃而没有主动释放锁，也需要保证后续客户端能够加锁成功</li><li>加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁释放了。</li><li>容错性：只要大部分的Redis节点正常运行，客户端就可以进行加锁和解锁操作。</li></ul><p><strong>Redis实现分布式锁的正确姿势</strong></p><ol><li>使用setnx命令保证互斥性</li><li>需要设置锁的过期时间，避免死锁</li><li>setnx和设置过期时间需要保持原子性，避免在setnx成功之后再设置过期时间客户端崩溃导致死锁</li><li>加锁的value值为一个唯一标识，可以采用UUID作为唯一标识。加锁成功后需要把唯一标识返回客户端，来给客户端进行解锁操作。</li></ol><p><strong>解锁的正确姿势：</strong></p><ol><li>需要拿加锁成功的唯一标识进行解锁，从而保证加锁和解锁是同一客户端</li><li>解锁操作需要比较唯一标识是否相等，相等再执行删除操作。这2个操作可以采用Lua脚本方式实现2个命令的原子性</li></ol><h3 id="14-Redis持久化"><a href="#14-Redis持久化" class="headerlink" title="14.Redis持久化"></a>14.Redis持久化</h3><p>​        很多时候我们需要持久化数据，也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>​        Redis不同于Memcached的很重一点就是，Redis支持赤计划，而且支持两种不同的持久化操作：</p><ul><li>RDB：snapshotting（快照）</li><li>AOF：append-only file（只追加文件）</li></ul><p><strong>RDB</strong></p><p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地，以便重启服务器时候使用</p><p>RDB是Redis默认采用的持久化方式，在redis.conf配置文件下默认有以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">save 900 1       #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10      #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000    #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure><p>RDB使用bgsave做镜像全量持久化，因为bgsave会耗费较长时间，不够实时。在停机时候会导致大量丢失数据，所以需要AOF配合使用。在redis实例重启时，会使用bgsave持久化文件，重新构建内存，再使用aof重放近期的操作指令，来实现完整恢复重启之前的状态。</p><p>bgsave原理： </p><ul><li>fork：redis通过创建子进程来进行bgsave操作</li><li>Cow ：copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来</li></ul><p><strong>AOF</strong></p><p>与RDB相比，AOF持久化的实时性更好，因此已成为主流的持久化方案。默认情况下，redis没有开启AOF方式的持久化，可以通过appendonly参数开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，redis就会将该命令写入硬盘中的AOF文件。在Redis的配置文件中存在三种不同的AOF持久化方式，它们分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑appendfsync everysec选项，让redis 每秒同步一次AOF文件，redis性能几乎没收到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。</p><p><strong>Redis 4.0持久化机制的优化</strong></p><p>redis 4.0 开始支持RDB和AOF的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble开启）。</p><p>如果把混合持久化打开，AOF重写的时候就直接把RDB的内容写到AOF文件开头。这样的好处是可以结合RDB和AOF的优点，快速加载同时避免丢失过多的数据。缺点是，AOF里面的RDB部分是压缩格式，不再是AOF格式，可读性较差。</p><p><strong>AOF重写</strong></p><p>​        AOF重写可以产生一个新的AOF文件（AOF 由于每次都会记录写命令，文件会很大，因此需要进行优化），这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</p><p>​        在执行<code>BGREWRITEAOF</code>命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新的AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;1.Redis简介&lt;/h3&gt;&lt;br&gt;简单来说redis就是一个数据库，不过与传统数据库不同的是redis的数据是存在内存中的，所以读写速度非常快，因此redis被广泛应用于缓存方向。另外，redis也经常被用来做分布式锁。redis提供了多种数据类型来支持不同的业务场景。除此之外，redis支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://miro.medium.com/max/1200/1*DPd3_f1ruu3rrkgaFeo2Ug.png&quot; alt&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁</title>
    <link href="http://yoursite.com/2020/03/30/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://yoursite.com/2020/03/30/乐观锁与悲观锁/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T06:19:23.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何谓悲观锁与乐观锁"><a href="#何谓悲观锁与乐观锁" class="headerlink" title="何谓悲观锁与乐观锁"></a>何谓悲观锁与乐观锁</h3><blockquote><p>乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另一种人</p></blockquote><p><img src="https://desk-fd.zol-img.com.cn/t_s1600x900c5/g5/M00/09/01/ChMkJ1ZdCsSIageLAAUIdpQQjZAAAFjoQHAPJcABQiO840.jpg" alt><br><a id="more"></a></p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程）</strong>。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新时会判断一下在此期间别人有没有去更新这个数据，可以用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用场景，这样可以提高吞吐量</strong>，像数据库提供的类似于 <strong>write_condition机制</strong>，其实都是提供的乐观锁。在java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong> 实现的。</p><h3 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h3><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像 <strong>乐观锁适用于读多写少的情况（多读场景），</strong> 即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就导致上层应用会不断进行retry，这样反倒是降低了性能，所以 <strong>一般多写的场景下用悲观锁比较合适</strong>。</p><h3 id="乐观锁实现方式"><a href="#乐观锁实现方式" class="headerlink" title="乐观锁实现方式"></a>乐观锁实现方式</h3><blockquote><p><strong>乐观锁一般会使用版本号机制或者CAS算法实现</strong></p></blockquote><h4 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1.版本号机制"></a>1.版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据值的同时也会读取version数据值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子：</strong></p><p>假设数据库中账户信息表中有一个version字段，当前值为1；而当前账户余额字段（balance）为￥100。</p><ol><li>操作员A此时将其读出（version = 1），并从其账户余额中扣除￥50 （ ￥100-￥50）</li><li>在操作员A读取的过程中，操作B也读入此用户信息（version = 1），并从其账户余额中扣除￥20（￥100 - ￥20）</li><li>操作员A完成了修改工作，将数据版本号加一（version = 2），连同账户扣除后余额（balance =  ￥50），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录version更新为2</li><li>操作员B完成了操作，也将版本号加一（version = 2）视图向数据库提交数据（balance = ￥80），此时比对数据库记录版本时发现，操作员B提交的数据版本号为2，数据库记录当前版本也为2，不满足“提交版本必须大于记录当前版本才能执行更新”的乐观锁策略，因此操作员B的提交被驳回</li></ol><p>这样就避免了操作员B用基于version = 1的旧数据修改的结果覆盖操作员A的操作结果的可能。</p><h4 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2.CAS算法"></a>2.CAS算法</h4><p>即 <strong>compare and swap （比较与交换）</strong>，是一种有名的 <strong>无锁算法</strong>。无锁编程，即不使用锁的情况下，实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下，实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization)。<strong>CAS算法</strong>涉及到三个操作数</p><ul><li>需要读写的内存值V</li><li>进行比较的值A</li><li>拟写入的新值B</li></ul><p>并且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个 <strong>自旋操作</strong>，即 <strong>不断的重试</strong>。</p><h3 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h3><blockquote><p>ABA问题是乐观锁一个常见的问题</p></blockquote><p><strong>1. ABA问题</strong></p><p>如果一个变量V初次读取的时候是A值，并且在准备赋值时检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过么？这明显不能，因为在这段时间内它的值可能被改为其他值，然后又改回A，那么CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>ABA问题</strong>。</p><p>JDK1.5以后的<code>AtomicStampedreference</code>类就提供了此种能力，其中的<code>compareAndSet</code>方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设为给定的更新值。</p><p><strong>2.循环时间长开销大</strong></p><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销</strong></p><p><strong>3.只能保证一个共享变量的原子操作</strong></p><p> CAS只对单个共享变量有效，当操作涉及多个共享变量时CAS无效。但是从JDK1.5开始，提供了<code>AtomicReference</code>类来保证对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。所以我们可以使用锁或者利用<code>AtomicReference</code>把多个共享变量合并成一个共享变量来操作。</p><h3 id="CAS与synchronized的使用场景"><a href="#CAS与synchronized的使用场景" class="headerlink" title="CAS与synchronized的使用场景"></a>CAS与synchronized的使用场景</h3><blockquote><p>简单来说，CAS适用于些比较少的情况（多读场景，冲突一般较少），synchronized适用于写比较多的情况（多写场景，冲突一般比较多）</p></blockquote><ol><li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切花以及用户态内核态间的切换操作额外浪费消耗CPU资源；而CAS基于硬件实现，不需要进入内核，不需要切换进程，操作自旋几率较少，因此可以获得高性能</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li></ol><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>Java并发编程这个领域中synchronized关键字一直都是元老级别的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在javaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其他 <strong>各种优化</strong> 之后，变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较小的情况下，可以获得和CAS类似的性能；在线程冲突严重的情况下，性能远高于CAS。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;何谓悲观锁与乐观锁&quot;&gt;&lt;a href=&quot;#何谓悲观锁与乐观锁&quot; class=&quot;headerlink&quot; title=&quot;何谓悲观锁与乐观锁&quot;&gt;&lt;/a&gt;何谓悲观锁与乐观锁&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另一种人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1600x900c5/g5/M00/09/01/ChMkJ1ZdCsSIageLAAUIdpQQjZAAAFjoQHAPJcABQiO840.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="http://yoursite.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>秒杀系统设计</title>
    <link href="http://yoursite.com/2020/03/28/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2020/03/28/秒杀系统设计/</id>
    <published>2020-03-27T16:00:00.000Z</published>
    <updated>2020-03-28T15:24:16.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-业务"><a href="#1-业务" class="headerlink" title="1.业务"></a>1.业务</h2><h3 id="用户业务："><a href="#用户业务：" class="headerlink" title="用户业务："></a>用户业务：</h3><ul><li>短信发送业务</li><li>注册业务</li><li>登录业务</li></ul><h3 id="商品业务："><a href="#商品业务：" class="headerlink" title="商品业务："></a>商品业务：</h3><ul><li>查询商品</li></ul><h3 id="交易业务："><a href="#交易业务：" class="headerlink" title="交易业务："></a>交易业务：</h3><ul><li>下单业务</li><li>订单ID的生成</li></ul><h3 id="秒杀业务："><a href="#秒杀业务：" class="headerlink" title="秒杀业务："></a>秒杀业务：</h3><ul><li>活动商品下单业务</li></ul><p><img src="https://2.bp.blogspot.com/-Sl6wdO704eo/Tbl_cbCIAbI/AAAAAAAACFw/nlP414H6CLo/s1600/96d8e440a7dd5501977e686709a8ee60.jpg" alt><br><a id="more"></a></p><h2 id="2-需要改进的地方"><a href="#2-需要改进的地方" class="headerlink" title="2.需要改进的地方"></a>2.需要改进的地方</h2><ol><li>如何发现容量问题</li><li>如何使得系统水平扩展</li><li>查询效率低下</li><li>活动开始前页面被疯狂刷新</li><li>库存行锁问题</li><li>下单操作多、缓慢</li><li>浪涌流量如何解决</li></ol><h1 id="秒杀优化部分："><a href="#秒杀优化部分：" class="headerlink" title="秒杀优化部分："></a>秒杀优化部分：</h1><h2 id="3-单机服务器并发容量问题"><a href="#3-单机服务器并发容量问题" class="headerlink" title="3.单机服务器并发容量问题"></a>3.单机服务器并发容量问题</h2><p>原因： 1. server并发线程数上不去，导致客户端被拒绝连接，tps上不去</p><p>查看商品详情接口压测数据：</p><table><thead><tr><th>序号</th><th>请求</th><th>平均耗时(ms)</th><th>tps(s)</th></tr></thead><tbody><tr><td>1</td><td>1000*100</td><td>283</td><td>2749</td></tr><tr><td>2</td><td>2000*100</td><td>577</td><td>2970</td></tr><tr><td>3</td><td>3000*100</td><td>588</td><td>1879</td></tr></tbody></table><h3 id="3-1-默认内嵌Tomcat配置"><a href="#3-1-默认内嵌Tomcat配置" class="headerlink" title="3.1 默认内嵌Tomcat配置"></a>3.1 默认内嵌Tomcat配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.accept-count:等待队列长度,默认<span class="number">100</span></span><br><span class="line">server.tomcat.max-connections:最大可被连接数，默认<span class="number">8192</span></span><br><span class="line">server.tomcat.max-threads:最大工作线程数，默认<span class="number">200</span></span><br><span class="line">server.tomcat.min-spare-threads:最小工作线程数，默认<span class="number">10</span></span><br><span class="line"></span><br><span class="line">默认配置下，连接超过<span class="number">8192</span>后出现拒绝连接的情况</span><br><span class="line">默认配置下，触发的请求超过<span class="number">200</span>+<span class="number">100</span>后拒绝处理</span><br></pre></td></tr></table></figure><h3 id="3-2-SpringBoot内嵌tomcat线程优化"><a href="#3-2-SpringBoot内嵌tomcat线程优化" class="headerlink" title="3.2 SpringBoot内嵌tomcat线程优化"></a>3.2 SpringBoot内嵌tomcat线程优化</h3><p>在<code>application.properties</code>里面进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.accept-count=1000</span><br><span class="line">server.tomcat.max-threads=800</span><br><span class="line">server.tomcat.min-spare-threads=100</span><br><span class="line"># 取默认值</span><br><span class="line">server.tomcat.max-connections=8192</span><br></pre></td></tr></table></figure><p><strong>等待队列不是越大越好</strong>，一是受到内存的限制，二是大量的出队入队操作耗费CPU性能。</p><p><strong>最大线程数不是越大越好</strong>，因为线程越多，CPU上下文切换的开销越大，存在一个“阈值”，对于一个4核8G的服务器，经验值是800。</p><p>而最小线程数设为100，则是为了应付一些<strong>突发情况</strong>。</p><p>spring boot内嵌的tomcat线程优化后，再次压测，效果不是特别明显</p><table><thead><tr><th>序号</th><th>请求</th><th>平均耗时(ms)</th><th>tps(s)</th></tr></thead><tbody><tr><td>1</td><td>2000*100</td><td>595</td><td>2958</td></tr></tbody></table><h3 id="3-3-SpringBoot内嵌Tomcat网络连接优化"><a href="#3-3-SpringBoot内嵌Tomcat网络连接优化" class="headerlink" title="3.3 SpringBoot内嵌Tomcat网络连接优化"></a>3.3 SpringBoot内嵌Tomcat网络连接优化</h3><p>当然Spring Boot并没有把内嵌Tomcat的所有配置都导出。一些配置需要通过<code>WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;</code>接口来定义。</p><p>这里需要自定义<code>KeepAlive</code>长连接的配置，减少客户端和服务器的连接请求次数，避免重复建立连接，提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerConfiguration</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用对应工厂类提供给我们的接口，定制化Tomcat connector</span></span><br><span class="line">        ((TomcatServletWebServerFactory) factory).addConnectorCustomizers(<span class="keyword">new</span> TomcatConnectorCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">                Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line">                <span class="comment">//定制化KeepAlive Timeout为30秒</span></span><br><span class="line">                protocol.setKeepAliveTimeout(<span class="number">30000</span>);</span><br><span class="line">                <span class="comment">//10000个请求则自动断开</span></span><br><span class="line">                protocol.setMaxKeepAliveRequests(<span class="number">8192</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springboot内嵌的tomcat网络连接优化，保持长连接，压测后效果</p><table><thead><tr><th>序号</th><th>请求</th><th>平均耗时(ms)</th><th>tps(s)</th></tr></thead><tbody><tr><td>1</td><td>2000*100</td><td>555</td><td>3223</td></tr></tbody></table><h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><ul><li>发现了Spring Boot内嵌Tomcat的<strong>线程容量问题</strong>。通过在Spring Boot配置文件中添加配置项，提高了Tomcat的等待队列长度、最大工作线程、最小工作线程，榨干服务器性能。</li><li>Spring Boot内嵌Tomcat默认使用<code>HTTP 1.0</code>的<strong>短连接</strong>，由于Spring Boot并没有把所有Tomcat配置都暴露出来，所以需要编写一个配置类使用<code>HTTP 1.1</code>的<strong>长连接</strong></li></ul><h3 id="3-5-接下来的优化方向"><a href="#3-5-接下来的优化方向" class="headerlink" title="3.5 接下来的优化方向"></a>3.5 接下来的优化方向</h3><ul><li>对服务器进行分布式扩展</li><li>优化SQL查询，比如添加索引</li></ul><h2 id="4-分布式扩展优化"><a href="#4-分布式扩展优化" class="headerlink" title="4. 分布式扩展优化"></a>4. 分布式扩展优化</h2><p><strong>部署图：</strong></p><p><img src="http://assets.processon.com/chart_image/5e5ba4dfe4b0541c5e15615c.png?_=1583073379976" alt></p><h3 id="4-1-nginx作用："><a href="#4-1-nginx作用：" class="headerlink" title="4.1 nginx作用："></a>4.1 nginx作用：</h3><ul><li>动静分离</li><li>反向代理、负载均衡</li></ul><h2 id="5-分布式会话"><a href="#5-分布式会话" class="headerlink" title="5. 分布式会话"></a>5. 分布式会话</h2><ul><li>基于cookie传输sessionID</li><li>基于token传输类似sessionID</li></ul><h2 id="6-查询优化之多级缓存"><a href="#6-查询优化之多级缓存" class="headerlink" title="6. 查询优化之多级缓存"></a>6. 查询优化之多级缓存</h2><p>多级缓存有两层含义，一个是<strong>缓存</strong>，一个是<strong>多级</strong>。我们知道，内存的速度是磁盘的成百上千倍，高并发下，从磁盘I/O十分影响性能。所谓缓存，就是将磁盘中的热点数据，暂时存到内存里面，以后查询直接从内存中读取，减少磁盘I/O，提高速度。所谓多级，就是在多个层次设置缓存，一个层次没有就去另一个层次查询。</p><h3>项目架构</h3><p><img src="http://assets.processon.com/chart_image/5e5ba4dfe4b0541c5e15615c.png" alt></p><h3 id="6-1-优化商品查询接口——单机版redis思路"><a href="#6-1-优化商品查询接口——单机版redis思路" class="headerlink" title="6.1 优化商品查询接口——单机版redis思路"></a>6.1 优化商品查询接口——单机版redis思路</h3><p>之前的<code>ItemController.getItem</code>接口，来一个<code>Id</code>，就调用<code>ItemService</code>去数据库查询一次。<code>ItemService</code>会查三张表，分别是商品信息表<code>item</code>表、商品库存<code>stock</code>表和活动信息表<code>promo</code>，十分影响性能。</p><p>所以修改<code>ItemController.getItem</code>接口，思路很简单，先从Redis服务器获取，若没有，则从数据库查询并存到Redis服务。有的话直接用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/get"</span>,method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getItem</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span>Integer id)</span>&#123;</span><br><span class="line">    ItemModel itemModel=(ItemModel)redisTemplate.opsForValue().get(<span class="string">"item_"</span>+id);</span><br><span class="line">    <span class="comment">//如果不存在，就执行下游操作，到数据查询</span></span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        itemModel=itemService.getItemById(id);</span><br><span class="line">        <span class="comment">//设置itemModel到redis服务器</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">        <span class="comment">//设置失效时间</span></span><br><span class="line">        redisTemplate.expire(<span class="string">"item_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    ItemVO itemVO=convertVOFromModel(itemModel);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(itemVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-优化商品查询接口——本地热点缓存"><a href="#6-2-优化商品查询接口——本地热点缓存" class="headerlink" title="6.2 优化商品查询接口——本地热点缓存"></a>6.2 优化商品查询接口——本地热点缓存</h3><p>Redis缓存虽好，但是有网络I/O，没有本地缓存快。我们可以在Redis的前面再添加一层<strong>“本地热点”</strong>缓存。所谓<strong>本地</strong>，就是利用<strong>本地JVM内存</strong>，由于JVM内存有限，仅存放<strong>多次查询</strong>的数据。</p><p>本地缓存，说白了就是一个<code>HashMap</code>，但是<code>HashMap</code>不支持并发读写，肯定是不行的。<code>j.u.c</code>包里面的<code>ConcurrentHashMap</code>虽然也能用，但是无法高效处理过期时限、没有淘汰机制等问题，所以这里使用了<code>Google</code>的<code>Guava Cache</code>方案。</p><p><code>Guava Cache</code>除了线程安全外，还可以控制超时时间，提供淘汰机制。</p><p>引用<code>google.guava</code>包后，在<code>service</code>包下新建一个<code>CacheService</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String,Object&gt; commonCache=<span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        commonCache= CacheBuilder.newBuilder()</span><br><span class="line">                <span class="comment">//初始容量</span></span><br><span class="line">                .initialCapacity(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//最大100个KEY，超过后会按照LRU策略移除</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                <span class="comment">//设置写缓存后多少秒过期，还有根据访问过期即expireAfterAccess</span></span><br><span class="line">                .expireAfterWrite(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommonCache</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">       commonCache.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFromCommonCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonCache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ItemController</code>里面，首先从本地缓存中获取，如果本地缓存没有，就去Redis里面获取，如果Redis也没有，就去数据库查询并存放到Redis里面。如果Redis里面有，将其获取后存到本地缓存里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getItem</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span>Integer id)</span>&#123;</span><br><span class="line">    ItemModel itemModel=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//第一级：先去本地缓存</span></span><br><span class="line">    itemModel=(ItemModel)cacheService.getFromCommonCache(<span class="string">"item_"</span>+id);</span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//第二级：从redis里面获取</span></span><br><span class="line">        itemModel=(ItemModel)redisTemplate.opsForValue().get(<span class="string">"item_"</span>+id);</span><br><span class="line">        <span class="comment">//如果不存在，就执行下游操作，到数据查询</span></span><br><span class="line">        <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">            itemModel=itemService.getItemById(id);</span><br><span class="line">            <span class="comment">//设置itemModel到redis服务器</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">            <span class="comment">//设置失效时间</span></span><br><span class="line">            redisTemplate.expire(<span class="string">"item_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//填充本地缓冲</span></span><br><span class="line">        cacheService.setCommonCache(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">    &#125;</span><br><span class="line">    ItemVO itemVO=convertVOFromModel(itemModel);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(itemVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-本地缓存缺点"><a href="#6-3-本地缓存缺点" class="headerlink" title="6.3 本地缓存缺点"></a>6.3 本地缓存缺点</h3><p>本地缓存虽然快，但是也有缺点：</p><ul><li>更新麻烦，容易产生脏数据</li><li>受到JVM容量的限制</li></ul><h3 id="6-4-Nginx缓存"><a href="#6-4-Nginx缓存" class="headerlink" title="6.4 Nginx缓存"></a>6.4 Nginx缓存</h3><h2 id="7-查询优化之页面静态化"><a href="#7-查询优化之页面静态化" class="headerlink" title="7.  查询优化之页面静态化"></a>7.  查询优化之页面静态化</h2><h3 id="7-1-CDN"><a href="#7-1-CDN" class="headerlink" title="7.1 CDN"></a>7.1 CDN</h3><h3 id="7-2-全页面静态化"><a href="#7-2-全页面静态化" class="headerlink" title="7.2 全页面静态化"></a>7.2 全页面静态化</h3><h2 id="8-交易优化之缓存库存"><a href="#8-交易优化之缓存库存" class="headerlink" title="8. 交易优化之缓存库存"></a>8. 交易优化之缓存库存</h2><h3 id="8-1-交易接口瓶颈"><a href="#8-1-交易接口瓶颈" class="headerlink" title="8.1 交易接口瓶颈"></a>8.1 交易接口瓶颈</h3><p>压测时发现<code>createOrder</code>接口压力很大，而数据库服务器的压力则要小很多。</p><p>原因在于，在<code>OrderService.createOrder</code>方法里面，首先要去数据库 <strong>查询商品信息，</strong>而在查询商品信息的过程中，又要去 <strong>查询秒杀活动消息</strong>，最后还要查询<strong>用户信息</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询商品信息的过程中，也会查询秒杀活动信息。</span></span><br><span class="line">ItemModel itemModel=itemService.getItemById(itemId);</span><br><span class="line"><span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR,<span class="string">"商品信息不存在"</span>);</span><br><span class="line"><span class="comment">//查询用户信息</span></span><br><span class="line">UserModel userModel=userService.getUserById(userId);</span><br></pre></td></tr></table></figure><p> 这还没完，最后还要对<code>stock</code><strong>库存表进行-1<code>update</code>操作</strong>，对<code>order_info</code><strong>订单信息表进行添加<code>insert</code>操作，</strong>对<code>item</code><strong>商品信息表进行销量+1<code>update</code>操作</strong>。仅仅一个下单，就有<strong>6次</strong>数据库I/O操作，此外，减库存操作还存在<strong>行锁阻塞</strong>，所以下单接口并发性很低。</p><h3 id="8-2-交易验证优化"><a href="#8-2-交易验证优化" class="headerlink" title="8.2 交易验证优化"></a>8.2 交易验证优化</h3><p>验证用户信息，是为了<strong>用户风控策略</strong>。判断用户信息是否存在是基本的策略，在企业级中，还可以判断用户状态是否异常，是否异地登录等。用户风控的信息，实际上可以缓存话，放到Redis里。</p><p>查询商品信息、活动信息，是为了<strong>活动校验策略</strong>。商品信息、活动信息，也可以存入缓存中。活动信息，由于具有<strong>时效性</strong>，需要具备紧急下线的接口，可以编写一个接口，清除活动信息的缓存。</p><h4 id="8-2-1-用户校验缓存化"><a href="#8-2-1-用户校验缓存化" class="headerlink" title="8.2.1 用户校验缓存化"></a>8.2.1 用户校验缓存化</h4><p>思路很简单，就是先从Redis里面获取用户信息，没有再去数据库查，并放到Redis里面。<code>UserService</code>新开一个<code>getUserByIdCache()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UserModel <span class="title">getUserByIdInCache</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    UserModel userModel= (UserModel) redisTemplate.opsForValue().get(<span class="string">"user_validate_"</span>+id);</span><br><span class="line">    <span class="keyword">if</span>(userModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        userModel=<span class="keyword">this</span>.getUserById(id);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"user_validate_"</span>+id,userModel);</span><br><span class="line">        redisTemplate.expire(<span class="string">"user_validate_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-2-活动校验缓存优化"><a href="#8-2-2-活动校验缓存优化" class="headerlink" title="8.2.2 活动校验缓存优化"></a>8.2.2 活动校验缓存优化</h4><p>跟用户校验类似，<code>ItemService</code>新开了一个<code>getItemByIdCache()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ItemModel <span class="title">getItemByIdInCache</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    ItemModel itemModel=(ItemModel)redisTemplate.opsForValue().get(<span class="string">"item_validate_"</span>+id);</span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        itemModel=<span class="keyword">this</span>.getItemById(id);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"item_validate_"</span>+id,itemModel);</span><br><span class="line">         redisTemplate.expire(<span class="string">"item_validate_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> itemModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-3-缓存优化后的效果"><a href="#8-2-3-缓存优化后的效果" class="headerlink" title="8.2.3 缓存优化后的效果"></a>8.2.3 缓存优化后的效果</h4><p>优化之后，tps和响应时间提升效果很好</p><h3 id="8-3-库存扣减优化"><a href="#8-3-库存扣减优化" class="headerlink" title="8.3 库存扣减优化"></a>8.3 库存扣减优化</h3><h4 id="8-3-1-索引优化"><a href="#8-3-1-索引优化" class="headerlink" title="8.3.1 索引优化"></a>8.3.1 索引优化</h4><p>之前扣减库存的操作，会执行<code>update stock set stock = stock - #{amount} where item_id = #{itemId} and stock &gt; #{amount}</code>这条SQL语句。如果<code>where</code>条件的<code>item_id</code>字段没有<strong>索引</strong>，那么会<strong>锁表</strong>，性能很低。所以先查看<code>item_id</code>字段是否有索引，没有的话，使用<code>alter table stock add UNIQUE INDEX item_id_index(item_id)</code>，为<code>item_id</code>字段添加一个<code>唯一索引</code>，这样在修改的时候，只会<strong>锁行</strong>。</p><h4 id="8-3-2-库存扣减缓存优化"><a href="#8-3-2-库存扣减缓存优化" class="headerlink" title="8.3.2 库存扣减缓存优化"></a>8.3.2 库存扣减缓存优化</h4><p>之前下单，是<strong>直接操作数据库</strong>，一旦秒杀活动开始，大量的流量涌入扣减库存接口，<strong>数据库压力很大</strong>。那么可不可以现在<strong>缓存中</strong>下单？答案是可以的。如果要在缓存中扣减库存，需要解决<strong>两个</strong>问题，第一个是活动开始前，将数据库的库存信息，同步到缓存中。第二个是下单之后，要将缓存中的库存信息同步到数据库中。这就需要用到<strong>异步消息队列</strong>——也就是<strong>RocketMQ</strong>。</p><h5 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h5><p>RocketMQ是阿里巴巴在RabbitMQ基础上改进的一个消息中间件。</p><p>只是要特别说明一下，默认的RocketMQ<strong>配置很坑</strong>（<code>Xms4g Xmx4g Xmn2g</code>），会导致Java<strong>内存不足</strong>的问题。需要修改<code>mqnamesrv.xml</code>，将<code>NewSize</code>、<code>MaxNewSize</code>、<code>PermSize</code>、<code>MaxPermSize</code>设置为自己服务器可承受值。</p><p>此外，<code>mqnamesrv</code>甚至不能用<code>localhost</code>启动，必须是本机公网IP，否则报<code>RemotingTooMuchRequestException</code>。</p><p><code>PromoService</code>新建一个<code>publishPromo()</code>方法，把数据库的缓存存到redis里去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishPromo</span><span class="params">(Integer promoId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过活动id获取活动</span></span><br><span class="line">    PromoDO promoDO=promoDOMapper.selectByPrimaryKey(promoId);</span><br><span class="line">    <span class="keyword">if</span>(promoDO.getItemId()==<span class="keyword">null</span> || promoDO.getItemId().intValue()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ItemModel itemModel=itemService.getItemById(promoDO.getItemId());</span><br><span class="line">    <span class="comment">//库存同步到Redis</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_"</span>+itemModel.getId(),itemModel.getStock());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意到的是，当我们把<strong>库存存到Redis的时候，商品可能被下单，</strong>这样数据库的库存和Redis的库存就 <strong>不一致</strong>了。解决方法就是活动<strong>未开始</strong>的时候，商品是<strong>下架状态</strong>，不能被下单。</p><p>最后，在<code>ItemService</code>里面修改<code>decreaseStock()</code>方法，在Redis里面扣减库存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 老方法，直接在数据库减</span></span><br><span class="line">    <span class="comment">// int affectedRow=itemStockDOMapper.decreaseStock(itemId,amount);</span></span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (affectedRow &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="同步缓存库存到数据库（异步扣减库存）"><a href="#同步缓存库存到数据库（异步扣减库存）" class="headerlink" title="同步缓存库存到数据库（异步扣减库存）"></a>同步缓存库存到数据库（异步扣减库存）</h5><p>引入RocketMQ相应<code>jar</code>包，在Spring Boot配置文件中添加MQ配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mq.nameserver.addr=IP:<span class="number">9876</span></span><br><span class="line">mq.topicname=stock</span><br></pre></td></tr></table></figure><p>新建一个<code>mq.MQProducer</code>类，编写<code>init</code>方法，初始化生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqProducer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> DefaultMQProducer producer;</span><br><span class="line">  <span class="comment">//即是IP:9867</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.nameserver.addr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameAddr;</span><br><span class="line">    <span class="comment">//即是stock</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.topicname&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String topicName;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">//Producer初始化，Group对于生产者没有意义，但是消费者有意义</span></span><br><span class="line">        producer=<span class="keyword">new</span> DefaultMQProducer(<span class="string">"producer_group"</span>);</span><br><span class="line">        producer.setNamesrvAddr(nameAddr);</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写<code>asyncReduceStock()</code>方法，实现异步扣减库存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">asyncReduceStock</span><span class="params">(Integer itemId, Integer amount)</span>  </span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; bodyMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    bodyMap.put(<span class="string">"itemId"</span>,itemId);</span><br><span class="line">    bodyMap.put(<span class="string">"amount"</span>,amount);</span><br><span class="line">    <span class="comment">//创建消息</span></span><br><span class="line">    Message message=<span class="keyword">new</span> Message(topicName,<span class="string">"increase"</span>,</span><br><span class="line">                JSON.toJSON(bodyMap).toString().getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        producer.send(message);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">      ···</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个<code>mq.MqConsumer</code>类，与<code>MqProducer</code>类类似，也有一个<code>init</code>方法，实现<strong>异步扣减库存</strong>的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DefaultMQPushConsumer consumer;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.nameserver.addr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameAddr;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.topicname&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String topicName;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ItemStockDOMapper itemStockDOMapper;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        consumer=<span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"stock_consumer_group"</span>);</span><br><span class="line">        <span class="comment">//监听名为topicName的话题</span></span><br><span class="line">        consumer.setNamesrvAddr(nameAddr);</span><br><span class="line">        <span class="comment">//监听topicName话题下的所有消息</span></span><br><span class="line">        consumer.subscribe(topicName,<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">//这个匿名类会监听消息队列中的消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//实现缓存数据真正到数据库扣减的逻辑</span></span><br><span class="line">                <span class="comment">//从消息队列中获取消息</span></span><br><span class="line">                Message message=list.get(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//反序列化消息</span></span><br><span class="line">                String jsonString=<span class="keyword">new</span> String(message.getBody());</span><br><span class="line">                Map&lt;String,Object&gt; map=JSON.parseObject(jsonString, Map.class);</span><br><span class="line">                Integer itemId= (Integer) map.get(<span class="string">"itemId"</span>);</span><br><span class="line">                Integer amount= (Integer) map.get(<span class="string">"amount"</span>);</span><br><span class="line">                <span class="comment">//去数据库扣减库存</span></span><br><span class="line">                itemStockDOMapper.decreaseStock(itemId,amount);</span><br><span class="line">                <span class="comment">//返回消息消费成功</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ItemService.decreaseStock()</code>方法也要做更改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//&gt;0，表示Redis扣减成功</span></span><br><span class="line">    <span class="keyword">if</span>(affectedRow&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//发送消息到消息队列，准备异步扣减</span></span><br><span class="line">        <span class="keyword">boolean</span> mqResult = mqProducer.asyncReduceStock(itemId,amount);</span><br><span class="line">        <span class="keyword">if</span> (!mqResult)&#123;</span><br><span class="line">            <span class="comment">//消息发送失败，需要回滚Redis</span></span><br><span class="line">          redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Redis扣减失败，回滚</span></span><br><span class="line">        redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异步扣减库存存在的问题"><a href="#异步扣减库存存在的问题" class="headerlink" title="异步扣减库存存在的问题"></a>异步扣减库存存在的问题</h5><ul><li>如果发送消息失败，只能回滚Redis</li><li>消费端从数据库扣减操作执行失败，如何处理（这里默认成功）？</li><li>下单失败无法正确回补库存（比如用户取消订单）。</li></ul><p>所以需要引入<strong>事务型消息</strong>。</p><h3 id="8-4-小结"><a href="#8-4-小结" class="headerlink" title="8.4 小结"></a>8.4 小结</h3><ul><li>首先对<strong>交易验证</strong>进行了优化，把对用户、商品、活动的查询从数据库转移到了缓存中，优化效果明显。</li><li>随后，优化了减库存的逻辑<ul><li>一是添加了索引，从锁表变成了锁行；</li><li>二是将减库存的操作也移到了缓存中，先从缓存中扣，再从数据库中扣。这就涉及到了<strong>异步减库存</strong>，所以需要引入<strong>消息中间件</strong>。</li></ul></li></ul><h2 id="9-交易优化之事务型优化"><a href="#9-交易优化之事务型优化" class="headerlink" title="9. 交易优化之事务型优化"></a>9. 交易优化之事务型优化</h2><h3 id="9-1-异步消息发送时机问题"><a href="#9-1-异步消息发送时机问题" class="headerlink" title="9.1 异步消息发送时机问题"></a>9.1 异步消息发送时机问题</h3><p>目前扣减库存的事务<code>ItemService.decreaseStock()</code>是封装在<code>OrderService()</code>事务里面的。在扣减Redis库存、发送异步消息之后，还有订单入库、增加销量的操作。如果这些操作失败，那么<code>createOrder()</code><strong>事务会回滚</strong>，<code>decreaseStock()</code><strong>事务也回滚</strong>，但是Redis的<strong>扣减操作却不能回滚，</strong>这会导致数据不一致。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>解决方法就是在订单入库、增加销量成功之后，再发生异步消息，<code>ItemService.decreaseStock()</code>只<strong>负责扣减Redis库存，不发送异步消息</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//&gt;0，表示Redis扣减成功</span></span><br><span class="line">    <span class="keyword">if</span>(affectedRow&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//抽离了发送异步消息的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Redis扣减失败，回滚</span></span><br><span class="line">        increaseStock(itemId, amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将发送异步消息的逻辑抽出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ItemService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">asyncDecreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mqProducer.asyncReduceStock(itemId, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在<code>OrderService.createOrder()</code>里面调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="comment">//订单入库</span></span><br><span class="line">orderDOMapper.insertSelective(orderDO);</span><br><span class="line"><span class="comment">//销量增加</span></span><br><span class="line">itemService.increaseSales(itemId,amount);</span><br><span class="line"><span class="comment">//执行完最后一步才发送异步消息</span></span><br><span class="line"><span class="keyword">boolean</span> mqResult=itemService.asyncDecreaseStock(itemId,amount);</span><br><span class="line">    <span class="keyword">if</span>(!mqResult)&#123;</span><br><span class="line">        <span class="comment">//回滚redis库存</span></span><br><span class="line">        itemService.increaseStock(itemId,amount);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.MQ_SEND_FAIL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样，就算订单入库失败、销量增加失败、消息发送失败，都能保证缓存和数据库的一致性。</p><h3 id="9-2-事务提交问题"><a href="#9-2-事务提交问题" class="headerlink" title="9.2 事务提交问题"></a>9.2 事务提交问题</h3><p>但是这么做，仍然有问题。Spring的<code>@Transactional</code>标签，会在<strong>事务方法返回后才提交</strong>，如果提交的过程中，发生了异常，则数据库回滚，但是Redis库存已扣，还是无法保证一致性。我们需要在<strong>事务提交成功后，再发生异步消息</strong>。</p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>Spring给我们提供了<code>TransactionSynchronizationManager.registerSynchronization()</code>方法，这个方法传入一个<code>TransactionSynchronizationAdapter</code>的匿名类，通过<code>afterCommit()</code>方法，在<strong>事务提交成功后，</strong>执行<strong>发送消息操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> mqResult=itemService.asyncDecreaseStock(itemId,amount);</span><br><span class="line">    <span class="keyword">if</span>(!mqResult)&#123;</span><br><span class="line">        itemService.increaseStock(itemId,amount);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.MQ_SEND_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-事务型消息"><a href="#9-3-事务型消息" class="headerlink" title="9.3 事务型消息"></a>9.3 事务型消息</h3><p>上面的做法，依然不能保证万无一失。假设现在<strong>事务提交成功了</strong>，等着执行 <code>afterCommit()</code>方法，这个时候<strong>突然宕机了</strong>，那么<strong>订单已然入库，销量已然增加，</strong>但是<strong>去数据库扣减库存的这条消息</strong>却<strong>“丢失”</strong>了。这里就需要引入RocketMQ的事务型消息。</p><p>所谓事务型消息，也会被发送到消息队列里面，这条消息处于<code>prepared</code>状态，<code>broker</code>会接收到这条消息，<strong>但是不会把这条消息给消费者消费</strong>。</p><p>处于<code>prepared</code>状态的消息，会执行<code>TransactionListener</code>的<code>executeLocalTransaction()</code>方法，根据执行结果，<strong>改变事务型消息的状态，让消费端消费或是不消费</strong>。</p><p>在<code>mq.MqProducer</code>类里面新注入一个<code>TransactionMQProducer</code>类，与<code>DefaultMQProducer</code>类似，也需要设置服务器地址、命名空间等。</p><p>新建一个<code>transactionAsyncReduceStock</code>的方法，该方法使用<code>事务型消息</code>进行异步扣减库存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务型消息同步库存扣减消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transactionAsyncReduceStock</span><span class="params">(Integer userId, Integer itemId, Integer promoId, Integer amount, String stockLogId)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; bodyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    bodyMap.put(<span class="string">"itemId"</span>, itemId);</span><br><span class="line">    bodyMap.put(<span class="string">"amount"</span>, amount);</span><br><span class="line">    <span class="comment">//用于执行orderService.createOrder的传参</span></span><br><span class="line">    Map&lt;String, Object&gt; argsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    argsMap.put(<span class="string">"itemId"</span>, itemId);</span><br><span class="line">    argsMap.put(<span class="string">"amount"</span>, amount);</span><br><span class="line">    argsMap.put(<span class="string">"userId"</span>, userId);</span><br><span class="line">    argsMap.put(<span class="string">"promoId"</span>, promoId);</span><br><span class="line"></span><br><span class="line">    Message message = <span class="keyword">new</span> Message(topicName, <span class="string">"increase"</span>,</span><br><span class="line">                JSON.toJSON(bodyMap).toString().getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注意，发送的是sendMessageInTransaction</span></span><br><span class="line">        transactionMQProducer.sendMessageInTransaction(message, argsMap);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就会发送一个事务型消息到<code>broke</code>，而处于<code>prepared</code>状态的事务型消息，会执行<code>TransactionListener</code>的<code>executeLocalTransaction</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">transactionMQProducer.setTransactionListener(<span class="keyword">new</span> TransactionListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message message, Object args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在事务型消息中去进行下单</span></span><br><span class="line">    Integer itemId = (Integer) ((Map) args).get(<span class="string">"itemId"</span>);</span><br><span class="line">    Integer promoId = (Integer) ((Map) args).get(<span class="string">"promoId"</span>);</span><br><span class="line">    Integer userId = (Integer) ((Map) args).get(<span class="string">"userId"</span>);</span><br><span class="line">    Integer amount = (Integer) ((Map) args).get(<span class="string">"amount"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用下单接口</span></span><br><span class="line">        orderService.createOrder(userId, itemId, promoId, amount);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BizException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//发生异常就回滚消息</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在<strong>事务型消息中去执行下单操作，</strong>下单失败，则消息回滚，<strong>不会去数据库扣减库存</strong>。下单成功，则消息被消费，<strong>扣减数据库库存</strong>。</p><h4 id="更新下单流程"><a href="#更新下单流程" class="headerlink" title="更新下单流程"></a>更新下单流程</h4><p>之前的下单流程是：<code>OrderController</code>里面调用<code>OrderService.createOrder()</code>方法，然后在该方法最后发送了异步消息，会导致异步消息丢失的问题。所以我们引入了<strong>事务型消息</strong>。</p><p>现在的下单流程是：<code>OrderController</code>里面直接调用<code>MqProducer.transactionAsyncReduceStock()</code>方法，发送一个事务型消息，然后在<strong>事务型消息中调用<code>OrderService.createOrder()</code>方法</strong>，进行下单。</p><h3 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4 小结"></a>9.4 小结</h3><ul><li>首先解决了<strong>发送异步消息时机</strong>的问题，之前是在<code>ItemService.decreaseStock()</code>，当在Redis里面扣减成功之后，发送异步消息。这样会导致数据库回滚，但Redis无法回滚的问题。所以我们把发送异步消息提到所有下单操作操作完成之后。</li><li>其次，由于Spring的<code>@Transactional</code>标签是在方法返回之后，才提交事务，如果返回阶段出了问题，那么数据库回滚了，但是缓存的库存却扣了。所以我们使用了<code>afterCommit()</code>方法。</li><li>最后，如果在执行<code>afterCommit()</code>的时候，发生了异常，那么消息就发不出去，又会导致数据一致性问题。所以我们通过使用<strong>事务型消息</strong>，把<strong>下单操作包装在异步扣减消息里面</strong>，让下单操作和扣减消息<strong>同生共死</strong>。</li></ul><h3 id="9-5-接下来的优化方向"><a href="#9-5-接下来的优化方向" class="headerlink" title="9.5 接下来的优化方向"></a>9.5 接下来的优化方向</h3><p>上述流程还有一个漏掉，就是当执行<code>orderService.createOrder()</code>后，突然<strong>又宕机</strong>了，根本没有返回，这个时候事务型消息就会进入<code>UNKNOWN</code>状态，我们需要处理这个状态。</p><p>在匿名类<code>TransactionListener</code>里面，还需要覆写<code>checkLocalTransaction()</code>方法，这个方法就是用来处理<code>UNKNOWN</code>状态的。应该怎么处理？这需要引入<strong>库存流水</strong>。</p><h2 id="10-库存流水"><a href="#10-库存流水" class="headerlink" title="10. 库存流水"></a>10. 库存流水</h2><p>数据库新建一张<code>stock_log</code>的表，用来记录库存流水，添加一个<code>ItemService.initStockLog</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">initStockLog</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    StockLogDO stockLogDO = <span class="keyword">new</span> StockLogDO();</span><br><span class="line">    stockLogDO.setItemId(itemId);</span><br><span class="line">    stockLogDO.setAmount(amount);</span><br><span class="line">    stockLogDO.setStockLogId(UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">    <span class="comment">//1表示初始状态，2表示下单扣减库存成功，3表示下单回滚</span></span><br><span class="line">    stockLogDO.setStatus(<span class="number">1</span>);</span><br><span class="line">    stockLogDOMapper.insertSelective(stockLogDO);</span><br><span class="line">    <span class="keyword">return</span> stockLogDO.getStockLogId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户请求后端<code>OrderController.createOrder()</code>接口，我们先初始化库存流水的状态，再调用事务型消息去下单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OrderController</span></span><br><span class="line"><span class="comment">//先检验用户登录信息</span></span><br><span class="line">String token = httpServletRequest.getParameterMap().get(<span class="string">"token"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.USER_NOT_LOGIN, <span class="string">"用户还未登录，不能下单"</span>);</span><br><span class="line">&#125;</span><br><span class="line">UserModel userModel = (UserModel) redisTemplate.opsForValue().get(token);</span><br><span class="line"><span class="keyword">if</span> (userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.USER_NOT_LOGIN, <span class="string">"登录过期，请重新登录"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化库存流水</span></span><br><span class="line">String stockLogId = itemService.initStockLog(itemId, amount);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送事务型消息，完成下单逻辑</span></span><br><span class="line"><span class="keyword">if</span> (!mqProducer.transactionAsyncReduceStock(userModel.getId(), itemId, promoId, amount, stockLogId)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.UNKNOWN_ERROR, <span class="string">"下单失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务型消息会调用<code>OrderService.createOrder()</code>方法，执行Redis扣减库存、订单入库、销量增加的操作，当这些操作都完成后，就说明下单完成了，<strong>等着异步更新数据库了</strong>。那么需要修改订单流水状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OrderService.createOrder</span></span><br><span class="line"><span class="comment">//订单入库</span></span><br><span class="line">orderDOMapper.insertSelective(orderDO);</span><br><span class="line"><span class="comment">//增加销量</span></span><br><span class="line">itemService.increaseSales(itemId, amount);</span><br><span class="line">StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line"><span class="keyword">if</span> (stockLogDO == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.UNKNOWN_ERROR);</span><br><span class="line"><span class="comment">//设置库存流水状态为成功</span></span><br><span class="line">stockLogDO.setStatus(<span class="number">2</span>);</span><br><span class="line">stockLogDOMapper.updateByPrimaryKeySelective(stockLogDO);</span><br></pre></td></tr></table></figure><h3 id="10-1-下单操作的处理"><a href="#10-1-下单操作的处理" class="headerlink" title="10.1 下单操作的处理"></a>10.1 下单操作的处理</h3><p>异步更新数据库，需要事务型消息从<code>prepare</code>状态编程<code>commit</code>状态。假设此时<code>orderService。createOrder()</code> <strong>本身发生了异常</strong>，那么就回滚事务型消息，并且返回<code>LocalTransactionState.ROLLBACK_MESSAGE</code>，这个下单操作就会被取消。</p><p>如果<strong>本身没有发生异常</strong>，那么就返回<code>LocalTransactionState.COMMIT_MESSAGE</code>，此时事务型消息会从<code>prepare</code>状态变为<code>commit</code>状态，接着被消费端消费，异步扣减库存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MqProducer.TransactionListener().executeLocalTransaction()</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    orderService.createOrder(userId, itemId, promoId, amount, stockLogId);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BizException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//如果发生异常，createOrder已经回滚，此时要回滚事务型消息。</span></span><br><span class="line">    <span class="comment">//设置stockLog为回滚状态</span></span><br><span class="line">    StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line">    stockLogDO.setStatus(<span class="number">3</span>);</span><br><span class="line">    stockLogDOMapper.updateByPrimaryKeySelective(stockLogDO);</span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br></pre></td></tr></table></figure><h3 id="10-2-UNKNOWN状态处理"><a href="#10-2-UNKNOWN状态处理" class="headerlink" title="10.2 UNKNOWN状态处理"></a>10.2 UNKNOWN状态处理</h3><p>如上节结尾所述，如果在执行<code>createOrder()</code>的时候，突然宕机了，此时事务型消息的状态是<code>UNKNOWN</code>，需要在<code>TransactionListener.checkLocalTransaction()</code>方法中处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据是否扣减库存成功，来判断要返回COMMIT，ROLLBACK还是UNKNOWN</span></span><br><span class="line">    String jsonString = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">    Map&lt;String, Object&gt; map = JSON.parseObject(jsonString, Map.class);</span><br><span class="line">    String stockLogId = (String) map.get(<span class="string">"stockLogId"</span>);</span><br><span class="line">    StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line">    <span class="keyword">if</span> (stockLogDO == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    <span class="comment">//订单操作已经完成，等着异步扣减库存，那么就提交事务型消息</span></span><br><span class="line">    <span class="keyword">if</span> (stockLogDO.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    <span class="comment">//订单操作还未完成，需要执行下单操作，那么就维持为prepare状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stockLogDO.getStatus() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就回滚</span></span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-库存售罄处理"><a href="#10-3-库存售罄处理" class="headerlink" title="10.3 库存售罄处理"></a>10.3 库存售罄处理</h3><p>现在是用户请求一次<code>OrderController.createOrder()</code>就初始化一次流水，但是如果10000个用户抢10个商品，就会初始化10000次库存流水，这显然是不行的。</p><p>解决的办法是在<code>ItemService.decreaseStock()</code>中，如果库存没有了，就打上<strong>“售罄标志”</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ublic <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow = redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span> + itemId, amount.intValue() * -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (affectedRow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (affectedRow == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//打上售罄标识</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_invalid_"</span> + itemId, <span class="string">"true"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        increaseStock(itemId, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>OrderController.createOrder()</code>初始化流水之前，先判断一下是否售罄，售罄了就直接抛异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否售罄</span></span><br><span class="line"><span class="keyword">if</span> (redisTemplate.hasKey(<span class="string">"promo_item_stock_invalid_"</span>+itemId))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.STOCK_NOT_ENOUGH);</span><br><span class="line">String stockLogId = itemService.initStockLog(itemId, amount);</span><br></pre></td></tr></table></figure><h3 id="10-4-小节"><a href="#10-4-小节" class="headerlink" title="10.4 小节"></a>10.4 小节</h3><p>这一节通过引入库存流水，来记录库存的状态，以便在<strong>事务型消息处于不同状态时进行处理</strong>。</p><p>事务型消息提交后，会在<code>broker</code>里面处于<code>prepare</code>状态，也即是<code>UNKNOWN</code>状态，等待被消费端消费，或者回滚。<code>prepare</code>状态下，会执行<code>OrderService.createOrder</code>方法。</p><p>此时有两种情况：</p><ol><li><code>createOrder()</code>执行完<strong>没有宕机</strong>，要么<strong>执行成功</strong>，要么<strong>抛出异常</strong>。<strong>执行成功</strong>，那么说明下单成功了，订单入库了，Redis里的库存扣了，销量增加了，<strong>等待着异步扣减库存</strong>，所以将事务型消息的状态，从<code>UNKNOWN</code>变为<code>COMMIT</code>，这样消费端就会消费这条消息，异步扣减库存。抛出异常，那么订单入库、Redis库存、销量增加，就会被数据库回滚，此时去异步扣减的消息，就应该”丢弃”，所以发回<code>ROLLBACK</code>，进行回滚。</li><li><code>createOrder()</code>执行完<strong>宕机了</strong>，那么这条消息会是<code>UNKNOWN</code>状态，这个时候需要在<code>checkLocalTransaction</code>进行处理。如果<code>createOrder()</code>执行完毕，此时<code>stockLog.status == 2</code>，就说明下单成功，需要去异步扣减库存，所以返回<code>COMMIT</code>。如果<code>status == 1</code>，说明下单还未完成，还需要继续执行下单操作，所以返回<code>UNKNOWN</code>。如果<code>status == 3</code>，说明下单失败，需要回滚，不需要异步扣减库存，所以返回<code>ROLLBACK</code>。</li></ol><h4 id="可以改进的地方"><a href="#可以改进的地方" class="headerlink" title="可以改进的地方"></a>可以改进的地方</h4><p>目前只是扣减库存异步化，实际上销量逻辑和交易逻辑都可以异步化，这里就不赘述了。</p><h4 id="接下来的优化方向"><a href="#接下来的优化方向" class="headerlink" title="接下来的优化方向"></a>接下来的优化方向</h4><p>目前下单接口会被脚本不停的刷，影响用户的正常体验。此外，验证逻辑和下单逻辑强关联，耦合度比较高。最后，验证逻辑也比较复杂。接下来会引入流量削峰技术。</p><h2 id="11-流量削峰"><a href="#11-流量削峰" class="headerlink" title="11. 流量削峰"></a>11. 流量削峰</h2><p>秒杀秒杀，就是在活动开始的一瞬间，有大量流量涌入，优化不当，会导致服务器停滞，甚至宕机。所以引入流量削峰技术十分有必要。</p><h3 id="11-1-业务解耦——秒杀令牌"><a href="#11-1-业务解耦——秒杀令牌" class="headerlink" title="11.1 业务解耦——秒杀令牌"></a>11.1 业务解耦——秒杀令牌</h3><p>之前的<strong>验证逻辑</strong>和<strong>下单逻辑</strong>都耦合在<code>OrderService.createOrder</code>里面，现在利用秒杀令牌，使校验逻辑和下单逻辑分离。</p><p><code>PromoService</code>新开一个<code>generateSecondKillToken()</code>里面，将活动、商品、用户信息校验逻辑封装在里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSecondKillToken</span><span class="params">(Integer promoId,Integer itemId,Integer userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断库存是否售罄，若Key存在，则直接返回下单失败</span></span><br><span class="line">    <span class="keyword">if</span>(redisTemplate.hasKey(<span class="string">"promo_item_stock_invalid_"</span>+itemId))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    PromoDO promoDO=promoDOMapper.selectByPrimaryKey(promoId);</span><br><span class="line">    PromoModel promoModel=convertFromDataObj(promoDO);</span><br><span class="line">    <span class="keyword">if</span>(promoModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(promoModel.getStartDate().isAfterNow()) &#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(promoModel.getEndDate().isBeforeNow())&#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断活动是否正在进行</span></span><br><span class="line">    <span class="keyword">if</span>(promoModel.getStatus()!=<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断item信息是否存在</span></span><br><span class="line">    ItemModel itemModel=itemService.getItemByIdInCache(itemId);</span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断用户是否存在</span></span><br><span class="line">    UserModel userModel=userService.getUserByIdInCache(userId);</span><br><span class="line">    <span class="keyword">if</span>(userModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//生成Token，并且存入redis内，5分钟时限</span></span><br><span class="line">    String token= UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_token_"</span>+promoId+<span class="string">"_userid_"</span>+userId+<span class="string">"_itemid_"</span>+itemId,token);</span><br><span class="line">    redisTemplate.expire(<span class="string">"promo_token_"</span>+promoId+<span class="string">"_userid_"</span>+userId+<span class="string">"_itemid_"</span>+itemId, <span class="number">5</span>,TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>OrderService.createOrder</code>的校验逻辑就可以删掉了。</p><p><code>OrderController</code>新开了一个<code>generateToken()</code>接口，以便前端请求时，返回令牌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/generatetoken"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">generateToken</span><span class="params">(···)</span> <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">    <span class="comment">//用户登录状态校验</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//获取秒杀访问令牌</span></span><br><span class="line">    String promoToken = promoService.generateSecondKillToken(promoId, itemId, userModel.getId());</span><br><span class="line">    <span class="keyword">if</span> (promoToken == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"生成令牌失败"</span>);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(promoToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端在点击<strong>“下单”</strong>后，首先会请求<code>generateToken()</code>接口，返回秒杀令牌。然后将秒杀令牌<code>promoToken</code>作为参数，再去请求后端<code>createOrder()</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/createorder"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">createOrder</span><span class="params">(··· @RequestParam(name = <span class="string">"promoToken"</span>, required = <span class="keyword">false</span>)</span> String promoToken) <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//校验秒杀令牌是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (promoId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String inRedisPromoToken = (String) redisTemplate.opsForValue().</span><br><span class="line">                    get(<span class="string">"promo_token_"</span> + promoId + <span class="string">"_userid_"</span> + userModel.getId() + <span class="string">"_itemid_"</span> + itemId);</span><br><span class="line">    <span class="keyword">if</span> (inRedisPromoToken == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"令牌校验失败"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.equals(promoToken, inRedisPromoToken)) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"令牌校验失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就彻底完成了校验逻辑和下单逻辑的分离。现在的问题是，假设有1E个用户请求下单，那么就会生成1E的令牌，这是十分消耗性能的，所以接下来引入<strong>秒杀大闸进行限流</strong>.</p><h3 id="11-2-限流——令牌大闸"><a href="#11-2-限流——令牌大闸" class="headerlink" title="11.2 限流——令牌大闸"></a>11.2 限流——令牌大闸</h3><p>大闸的意思就是<strong>令牌的数量是有限的</strong>，当令牌用完时，就不再发放令牌了，那么下单将无法进行。之前我们通过<code>PromoService.publishPromo()</code>将库存发布到了Redis上，现在我们将令牌总数也发布到Redis上，这里我们设定令牌总量是库存的5倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishPromo</span><span class="params">(Integer promoId)</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//库存同步到Redis</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_"</span> + itemModel.getId(), itemModel.getStock());</span><br><span class="line">    <span class="comment">//大闸限制数量设置到redis内</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_door_count_"</span> + promoId, itemModel.getStock().intValue() * <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，在<code>PromoService.generateSecondKillToken()</code>方法中，在生成令牌之前，首先将Redis里的令牌总量减1，然后再判断是否剩余，如果 &lt;0，直接返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取大闸数量</span></span><br><span class="line"><span class="keyword">long</span> result = redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_door_count_"</span> + promoId, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (result &lt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//令牌生成</span></span><br></pre></td></tr></table></figure><p>这样，当令牌总量为0时，就不再发放令牌了，也就无法下单了。</p><h4 id="令牌大闸限流缺点"><a href="#令牌大闸限流缺点" class="headerlink" title="令牌大闸限流缺点"></a>令牌大闸限流缺点</h4><p>当商品种类少、库存少的时候，令牌大闸效果还不错。但是一旦参与活动的商品库存太大，比如1W个，那么一秒钟也有上十万的流量涌入，限制能力是很弱的。所以需要<strong>队列泄洪</strong>。</p><h3 id="11-3-限流——队列泄洪"><a href="#11-3-限流——队列泄洪" class="headerlink" title="11.3 限流——队列泄洪"></a>11.3 限流——队列泄洪</h3><p>队列泄洪，就是让多余的请求<strong>排队等待</strong>。<strong>排队</strong>有时候比<strong>多线程</strong>并发效率更高，多线程毕竟有锁的竞争、上下文的切换，很消耗性能。而排队是无锁的，单线程的，某些情况下效率更高。</p><p>比如Redis就是<strong>单线程模型</strong>，多个用户同时执行<code>set</code>操作，只能一一等待。</p><p>比如MySQL的<code>insert</code>和<code>update</code>语句，会维护一个行锁。阿里SQL就不会，而是让多个SQL语句排队，然后依次执行。</p><p>像支付宝就使用了队列泄洪，双十一的时候，支付宝作为网络科技公司，可以承受很高的TPS，但是下游的各个银行，无法承受这么高的TPS。支付宝维护了一个”拥塞窗口”，慢慢地向下游银行发送流量，保护下游。</p><p>那对于我们的项目，什么时候引入”队列泄洪”呢？在<code>OrderController</code>里面，之前拿到秒杀令牌后，就要开始执行下单的业务了。现在我们把<strong>下单业务</strong>封装到一个<strong>固定大小的线程池中，</strong>一次<strong>只处理固定大小的请求</strong>。</p><p>在<code>OrderController</code>里面引入<code>j.u.c.ExecutorService</code>，创建了一个<code>init</code>方法，初始化线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//20个线程的线程池</span></span><br><span class="line">    executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在拿到秒杀令牌后，使用线程池来处理下单请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String stockLogId = itemService.initStockLog(itemId, amount);</span><br><span class="line">        <span class="keyword">if</span> (!mqProducer.transactionAsyncReduceStock(userModel.getId(), itemId, promoId, amount, stockLogId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.UNKNOWN_ERROR, <span class="string">"下单失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就算转瞬间涌入再多流量，得到处理的也就20个，其他全部等待。</p><h3 id="11-4-小结"><a href="#11-4-小结" class="headerlink" title="11.4 小结"></a>11.4 小结</h3><p>这一章我们</p><ul><li>使用秒杀令牌，实现了校验业务和下单业务的分离。同时为秒杀大闸做了铺垫</li><li>使用秒杀大闸，实现了限流的第一步，限制了流量的总量</li><li>使用队列泄洪，实现了限流的第二步，同一时间只有部分请求得到处理。</li></ul><h3 id="11-5-接下来的优化方向"><a href="#11-5-接下来的优化方向" class="headerlink" title="11.5 接下来的优化方向"></a>11.5 接下来的优化方向</h3><p>接下来会引入防刷限流技术，比如验证码技术等。</p><h2 id="12-防刷限流"><a href="#12-防刷限流" class="headerlink" title="12. 防刷限流"></a>12. 防刷限流</h2><h3 id="12-1-验证码技术"><a href="#12-1-验证码技术" class="headerlink" title="12.1 验证码技术"></a>12.1 验证码技术</h3><p>之前的流程是，用户点击下单后，会直接拿到令牌然后执行下单流程。现在，用户点击下单后，前端会弹出一个”验证码“，用户输入之后，才能请求下单接口。</p><p><code>OrderController</code>新开一个<code>generateVerifyCode()</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/generateverifycode"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateVerifyCode</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> BizException, IOException </span>&#123;</span><br><span class="line">    ···验证</span><br><span class="line">    <span class="comment">//验证用户信息</span></span><br><span class="line">    Map&lt;String, Object&gt; map = CodeUtil.generateCodeAndPic();</span><br><span class="line">    <span class="comment">//生成的验证码存到Redis里，并设置过期时间</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"verify_code_"</span> + userModel.getId(), map.get(<span class="string">"code"</span>));</span><br><span class="line">    redisTemplate.expire(<span class="string">"verify_code_"</span> + userModel.getId(), <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//生成的图片，响应到前端页面</span></span><br><span class="line">    ImageIO.write((RenderedImage) map.get(<span class="string">"codePic"</span>), <span class="string">"jpeg"</span>, response.getOutputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前获取秒杀令牌的<code>generateToken()</code>接口，需要添加验证码校验逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">generateToken</span><span class="params">(··· @RequestParam(name = <span class="string">"verifyCode"</span>)</span> String verifyCode) <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">    <span class="comment">//验证用户登录信息</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//验证验证码的有效性</span></span><br><span class="line">    String redisVerifyCode = (String) redisTemplate.opsForValue().get(<span class="string">"verify_code_"</span> + userModel.getId());</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(redisVerifyCode))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"请求非法"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!redisVerifyCode.equalsIgnoreCase(verifyCode))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"请求非法"</span>);</span><br><span class="line">    <span class="comment">//获取秒杀访问令牌</span></span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就实现了在下单之前，添加一个验证码，限制部分流量的功能。</p><h3 id="12-2-限流方案——限并发"><a href="#12-2-限流方案——限并发" class="headerlink" title="12.2 限流方案——限并发"></a>12.2 限流方案——限并发</h3><p>限制并发量意思就是同一时间<strong>只有一定数量的线程去处理请求</strong>，实现也比较简单，维护一个<strong>全局计数器</strong>，当请求进入接口时，计数器-1，并且判断计数器是否&gt;0，大于0则处理请求，小于0则拒绝等待。</p><p>但是一般衡量并发性，是用TPS或者QPS，而该方案由于限制了线程数，自然不能用TPS或者QPS衡量。</p><h3 id="12-3-限流方案——令牌桶-漏桶"><a href="#12-3-限流方案——令牌桶-漏桶" class="headerlink" title="12.3 限流方案——令牌桶/漏桶"></a>12.3 限流方案——令牌桶/漏桶</h3><h4 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h4><p>客户端请求接口，必须先从令牌桶中获取令牌，令牌是由一个”定时器“定期填充的。在一个时间内，令牌的数量是有限的。令牌桶的大小为100，那么TPS就为100。</p><p><img src="https://raw.githubusercontent.com/MaJesTySA/miaosha_Shop/master/imgs/tokenBucket.png" alt></p><h4 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h4><p>客户端请求接口，会向漏桶里面”加水“。漏桶每秒漏出一定数量的”水“，也就是处理请求。只有当漏桶不满时，才能请求。</p><p><img src="https://raw.githubusercontent.com/MaJesTySA/miaosha_Shop/master/imgs/leekBucket.png" alt></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>漏桶无法应对<strong>突发流量</strong>，比如突然来10个请求，只能处理一个。但是令牌桶，可以一次性处理10个。所以令牌桶用得比较多。</p><h3 id="12-4-限流力度"><a href="#12-4-限流力度" class="headerlink" title="12.4 限流力度"></a>12.4 限流力度</h3><p>分为<strong>接口维度</strong>和<strong>总维度</strong>，很好理解。接口维度就是限制某个接口的流量，而总维度是限制所有接口的流量。</p><h3 id="12-5-限流范围"><a href="#12-5-限流范围" class="headerlink" title="12.5 限流范围"></a>12.5 限流范围</h3><p>分为<strong>集群限流</strong>和<strong>单机限流</strong>，集群限流顾名思义就是限制整个集群的流量，需要用Redis或者其他中间件技术来做统一计数器，往往会产生性能瓶颈。单机限流在负载均衡的前提下效果更好。</p><h3 id="12-6-RateLimiter限流实现"><a href="#12-6-RateLimiter限流实现" class="headerlink" title="12.6 RateLimiter限流实现"></a>12.6 RateLimiter限流实现</h3><p><code>google.guava.RateLimiter</code>就是令牌桶算法的一个实现类，<code>OrderController</code>引入这个类，在<code>init</code>方法里面，初始令牌数量为200。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//20个线程的线程池</span></span><br><span class="line">    executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//200个令牌，即200TPS</span></span><br><span class="line">    orderCreateRateLimiter = RateLimiter.create(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求<code>createOrder()</code>接口之前，会调用<code>RateLimiter.tryAcquire()</code>方法，看当前令牌是否足够，不够直接抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f (!orderCreateRateLimiter.tryAcquire())</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.RATELIMIT);</span><br></pre></td></tr></table></figure><h3 id="12-7-防刷技术"><a href="#12-7-防刷技术" class="headerlink" title="12.7 防刷技术"></a>12.7 防刷技术</h3><p>排队、限流、令牌只能控制总流量，无法控制黄牛流量。</p><h4 id="传统防刷技术"><a href="#传统防刷技术" class="headerlink" title="传统防刷技术"></a>传统防刷技术</h4><ul><li>限制一个会话(Session、Token)一定时间内请求接口的次数。多会话接入绕开无效，比如黄牛可以开启多个会话。</li><li>限制一个IP一定时间内请求接口的次数。容易误伤，某个局域网内的正常用户共享一个IP进行访问。而且IP可以被伪造。</li></ul><h4 id="黄牛为什么难防"><a href="#黄牛为什么难防" class="headerlink" title="黄牛为什么难防"></a>黄牛为什么难防</h4><ul><li>模拟硬件设备，比如手机。一个看似正常的用户，可能是用模拟器模拟出来的。</li><li>设备牧场，一屋子手机刷接口</li><li>人工作弊，这个最难防，情真人刷接口</li></ul><h4 id="防黄牛方案"><a href="#防黄牛方案" class="headerlink" title="防黄牛方案"></a>防黄牛方案</h4><ul><li><strong>设备指纹方式：</strong>采集终端设备各项数据，启动应用时生成一个唯一设备指纹。根据对应设备的指纹参数，估计是可疑设备的概率。</li><li><strong>凭证系统：</strong>根据设备指纹下发凭证，在关键业务链路上带上凭证并有凭证服务器验证。凭证服务器根据设备指纹参数和风控系统判断凭证的可疑程度。若凭证分数低于设定值，则开启验证</li></ul><h3 id="12-8-小结"><a href="#12-8-小结" class="headerlink" title="12.8 小结"></a>12.8 小结</h3><ul><li>通过引入验证码技术，在发送秒杀令牌之前，再做一层限流</li><li>介绍了三种限流方案，使用<code>RateLimiter</code>实现了令牌桶限流</li><li>介绍了常见的防刷技术以及它们的缺点。介绍了黄牛为什么难防，应该怎样防。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-业务&quot;&gt;&lt;a href=&quot;#1-业务&quot; class=&quot;headerlink&quot; title=&quot;1.业务&quot;&gt;&lt;/a&gt;1.业务&lt;/h2&gt;&lt;h3 id=&quot;用户业务：&quot;&gt;&lt;a href=&quot;#用户业务：&quot; class=&quot;headerlink&quot; title=&quot;用户业务：&quot;&gt;&lt;/a&gt;用户业务：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;短信发送业务&lt;/li&gt;
&lt;li&gt;注册业务&lt;/li&gt;
&lt;li&gt;登录业务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;商品业务：&quot;&gt;&lt;a href=&quot;#商品业务：&quot; class=&quot;headerlink&quot; title=&quot;商品业务：&quot;&gt;&lt;/a&gt;商品业务：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;查询商品&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;交易业务：&quot;&gt;&lt;a href=&quot;#交易业务：&quot; class=&quot;headerlink&quot; title=&quot;交易业务：&quot;&gt;&lt;/a&gt;交易业务：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;下单业务&lt;/li&gt;
&lt;li&gt;订单ID的生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;秒杀业务：&quot;&gt;&lt;a href=&quot;#秒杀业务：&quot; class=&quot;headerlink&quot; title=&quot;秒杀业务：&quot;&gt;&lt;/a&gt;秒杀业务：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;活动商品下单业务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://2.bp.blogspot.com/-Sl6wdO704eo/Tbl_cbCIAbI/AAAAAAAACFw/nlP414H6CLo/s1600/96d8e440a7dd5501977e686709a8ee60.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="秒杀系统" scheme="http://yoursite.com/tags/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux 五种IO模型</title>
    <link href="http://yoursite.com/2020/03/25/Linux%20%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/03/25/Linux 五种IO模型/</id>
    <published>2020-03-24T16:00:00.000Z</published>
    <updated>2020-03-25T11:30:46.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念说明"><a href="#1-概念说明" class="headerlink" title="1. 概念说明"></a>1. 概念说明</h2><p>在进行解释前，首先说明几个概念：</p><blockquote><p>用户空间和内核空间</p><p>进程切换</p><p>进程的阻塞</p><p>文件描述符</p><p>缓存IO</p></blockquote><h3 id="1-1-用户空间和内核空间"><a href="#1-1-用户空间和内核空间" class="headerlink" title="1.1 用户空间和内核空间"></a>1.1 用户空间和内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对于32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。<strong>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限</strong>。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，<strong>操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</strong>针对linux操作系统而言，将最高的1G字节（从虚拟地址<code>0xC0000000</code>到<code>0xFFFFFFF</code>），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址<code>0x00000000</code>到<code>0xBFFFFFFF</code>），供各个进程使用，称为用户空间。</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1920x1200c5/g5/M00/01/04/ChMkJlg2YRGIXrtCABy9qCTYS60AAYB1AAAAAAAHL3A605.png" alt><br><a id="more"></a></p><h3 id="1-2-进程切换"><a href="#1-2-进程切换" class="headerlink" title="1.2 进程切换"></a>1.2 进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><blockquote><ol><li>保存处理机上下文，包括程序计数器和其他寄存器</li><li>更新PCB（<code>Process Control Block</code> 进程处理块）信息</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列</li><li>选择另一个进程执行，并更新其PCB</li><li>更新内存管理的数据结构</li><li>恢复处理机上下文</li></ol></blockquote><p>注：总而言之就是很耗资源</p><h3 id="1-3-进程的阻塞"><a href="#1-3-进程的阻塞" class="headerlink" title="1.3 进程的阻塞"></a>1.3 进程的阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达</p><p>或无新工作做等，则由系统自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种自主行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p><h3 id="1-4-文件描述符fd"><a href="#1-4-文件描述符fd" class="headerlink" title="1.4 文件描述符fd"></a>1.4 文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，<strong>是一个用于表述指向文件的引用的抽象化概念</strong>。</p><p>文件描述符在形式上是一个非负整数。实际上，<strong>它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h3 id="1-5-缓存IO"><a href="#1-5-缓存IO" class="headerlink" title="1.5 缓存IO"></a>1.5 缓存IO</h3><p><strong>缓存IO又被称为标准IO，大多数文件系统的默认IO操作都是缓存IO</strong>。在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存（page cache）中，也就是说， <strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。</p><p><strong>缓存IO的缺点：</strong></p><p><strong>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作</strong>，这些数据拷贝带来的CPU以及内存开销是非常大的。</p><h2 id="2-Linux-IO模型"><a href="#2-Linux-IO模型" class="headerlink" title="2.Linux IO模型"></a>2.Linux IO模型</h2><p><strong>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作</strong>。刚才说了，对于一次IO访问（以read举例），<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。所以说，当一个read操作发生时，它会经历两个阶段：</p><blockquote><ol><li>第一阶段：等待数据准备</li><li>第二阶段：将数据从内核拷贝到进程中</li></ol></blockquote><p>对于socket流而言，</p><blockquote><ol><li>第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区</li><li>第二步：把数据从内核缓冲区复制到应用进程缓冲区</li></ol></blockquote><p>网络应用需要处理的无非就是两大类问题：<strong>网络IO、数据计算</strong>。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。网络IO的模型大致有如下几种：</p><blockquote><ul><li>同步模型（synchronous IO）</li><li>阻塞IO (blocking IO )</li><li>非阻塞IO（non-blocking IO）</li><li>多路复用IO（multiplexing IO）</li><li>信号驱动式IO（signal-driven IO）</li><li>异步IO（asynchronous IO）</li></ul></blockquote><p><strong>注：由于signal driven  IO在实际中并不常用，所以下面只提及剩下的四种IO模型</strong>。</p><p>在深入介绍Linux IO各种模型之前，让我们先来探索一下基本 Linux IO 模型的简单矩阵。如下图所示：</p><p><img src="https://static.oschina.net/uploads/img/201604/20144245_Wtld.png" alt></p><p>每个 IO 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。本节将简要对其一一进行介绍。<strong>常见的IO模型有阻塞、非阻塞、IO多路复用，异步</strong>。以一个生动形象的例子来说明这四个概念。周末我和女友去逛街，中午饿了，我们准备去吃饭。周末人多，吃饭需要排队，我和女友有以下几种方案。</p><h3 id="2-1-同步阻塞IO（blocking-IO）"><a href="#2-1-同步阻塞IO（blocking-IO）" class="headerlink" title="2.1 同步阻塞IO（blocking IO）"></a>2.1 同步阻塞IO（blocking IO）</h3><h4 id="2-1-1-场景描述"><a href="#2-1-1-场景描述" class="headerlink" title="2.1.1 场景描述"></a>2.1.1 场景描述</h4><blockquote><p>我和女友点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。女友本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。<strong>这就是典型的阻塞</strong>。</p></blockquote><h4 id="2-1-2-网络模型"><a href="#2-1-2-网络模型" class="headerlink" title="2.1.2 网络模型"></a>2.1.2 网络模型</h4><p><strong>同步阻塞IO模型是最常用的一个模型，也是最简单的模型</strong>。在linux中，<strong>默认情况下所有的socket都是blocking</strong>。它最符合人们最常见的逻辑。<strong>阻塞就是进程”被”休息，CPU处理其他进程去了</strong>。</p><p>在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，<strong>在等待数据到处理数据的两个阶段，</strong>整个进程都被阻塞，不能处理别的网络IO。<strong>调用应用程序处于一种不再消费CPU，而只是简单等待响应的状态</strong>，因此从处理的角度看，这是非常有效的。在调用recv()/recvfrom()函数时，发生在内核中等待数据和复制数据的过程，大致如下图：</p><p><img src="https://static.oschina.net/uploads/img/201604/20150405_VKYH.png" alt></p><h4 id="2-1-3-流程描述"><a href="#2-1-3-流程描述" class="headerlink" title="2.1.3 流程描述"></a>2.1.3 流程描述</h4><p>当用户进程调用了recv()/recvfrom()这个系统调用，<strong>kernel就开始了IO的第一个阶段：准备数据</strong>对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。<strong>第二个阶段：当kernel一只等到数据准备好了，它就会把数据从kernel拷贝到用户内存</strong>，然后kernel返回结果，用户进程才能解除blocking的状态，重新运行起来。</p><blockquote><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了</p></blockquote><p>优点:</p><blockquote><ol><li>能够及时返回数据，无延迟</li><li>对内核开发者来说这是省钱了</li></ol></blockquote><p>缺点：</p><blockquote><ol><li>对用来说处于等待就要付出性能的代价了</li></ol></blockquote><h3 id="2-同步非阻塞IO（nonblocking-IO）"><a href="#2-同步非阻塞IO（nonblocking-IO）" class="headerlink" title="2.同步非阻塞IO（nonblocking IO）"></a>2.同步非阻塞IO（nonblocking IO）</h3><h4 id="2-2-1-场景描述"><a href="#2-2-1-场景描述" class="headerlink" title="2.2.1 场景描述"></a>2.2.1 场景描述</h4><blockquote><p>我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。<strong>这就是非阻塞</strong>。需要不断的询问，是否准备好了。</p></blockquote><h4 id="2-2-2-网络模型"><a href="#2-2-2-网络模型" class="headerlink" title="2.2.2 网络模型"></a>2.2.2 网络模型</h4><p><strong>同步非阻塞就是”每隔一会儿瞄一眼进度条”的轮询（polling）方式</strong>。在这种模型中，<strong>设备是以非阻塞的形式打开的</strong>。这意味着 IO 操作不会立即完成，read 操作可能会返回一个错误代码，说明这个命令不能立即满足（EAGAIN 或 EWOULDBLOCK）。</p><p>在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。</p><p><strong>也就是说非阻塞的recvform系统调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error</strong>。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。 重复上面的过程，循环往复的进行recvform系统调用。<strong>这个过程通常被称之为轮询</strong>。轮询检查内核数据，知道数据准备好，再拷贝到进程，进行数据处理。<strong>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态</strong>。</p><p>在linux下，可以通过设置socket使其变为non-blocking。<strong>当对一个non-blocking socket执行读操作时</strong>，流程如图所示：</p><p><img src="https://static.oschina.net/uploads/img/201604/20152818_DXcj.png" alt></p><h4 id="2-2-3-流程描述"><a href="#2-2-3-流程描述" class="headerlink" title="2.2.3 流程描述"></a>2.2.3 流程描述</h4><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><blockquote><p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p></blockquote><p><strong>同步非阻塞方式相比同步阻塞方式：</strong></p><blockquote><p>优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。</p><p>缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</p></blockquote><h3 id="2-3-IO多路复用（IO-multiplexing）"><a href="#2-3-IO多路复用（IO-multiplexing）" class="headerlink" title="2.3 IO多路复用（IO multiplexing）"></a>2.3 IO多路复用（IO multiplexing）</h3><h4 id="2-3-1-场景描述"><a href="#2-3-1-场景描述" class="headerlink" title="2.3.1 场景描述"></a>2.3.1 场景描述</h4><blockquote><p>与第二个方案差不多，餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，<strong>这就是典型的IO多路复用</strong>。</p></blockquote><h4 id="2-3-2-网络模型"><a href="#2-3-2-网络模型" class="headerlink" title="2.3.2 网络模型"></a>2.3.2 网络模型</h4><p>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。<strong>那么这就是所谓的”IO多路复用“</strong>。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。</p><p><strong>IO多路复用有几个特别的系统调用select、poll、epoll、函数</strong>。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于——<strong>前者可以等待多个socket，能实现同时对多个IO端口进行监听</strong>，当其中任何一个socket的数据准备好了，<strong>就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。</strong>select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，<strong>此时的select不是等到socket数据全部到达再处理，而是有了一部分数据就会调用用户进程来处理</strong>。如何知道有一部分数据到达了呢？<strong>监视的事情交给了内核，内核负责数据到达的处理。也可以理解为”非阻塞”吧</strong>。</p><p><strong>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作</strong>。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p><p>对于多路复用，也就是轮询多个socket。<strong>多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了</strong>，当然也可以针对不同的编号。具体流程，如下图所示：</p><p><img src="https://static.oschina.net/uploads/img/201604/20164149_LD8E.png" alt></p><h4 id="2-3-3-流程描述"><a href="#2-3-3-流程描述" class="headerlink" title="2.3.3 流程描述"></a>2.3.3 流程描述</h4><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为<code>event driven IO。</code> <strong>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO</strong>。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p><strong>当用户进程调用了select，那么整个进程会被block</strong>，而同时，kernel会“监视”所有select负责的socket，<strong>当任何一个socket中的数据准备好了，select就会返回</strong>。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><blockquote><p>多路复用的特点是<strong>通过一种机制一个进程能同时等待多个IO文件描述符</strong>，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。</p></blockquote><p>上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。<strong>因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)</strong>。但是，<strong>用select的优势在于它可以同时处理多个connection</strong>。</p><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p><p>在IO multiplexing Model中，<strong>实际中，对于每一个socket，一般都设置成为non-blocking</strong>，但是，如上图所示，整个用户的process其实是一直被block的。<strong>只不过process是被select这个函数block，而不是被socket IO给block</strong>。所以<strong>IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</strong></p><p>在I/O编程过程中，<strong>当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理</strong>。I/O多路复用技术<strong>通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求</strong>。与传统的多线程/多进程模型比，<strong>I/O多路复用的最大优势是系统开销小</strong>，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源，I/O多路复用的主要应用场景如下：</p><blockquote><p>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</p><p>服务器需要同时处理多种网络协议的套接字。</p></blockquote><p>了解了前面三种IO模式，在用户进程进行系统调用的时候，<strong>它们在等待数据到来的时候，处理的方式不一样，直接等待、轮询、select或poll轮询</strong>，两个阶段过程：</p><blockquote><p>第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。</p><p>第二个阶段都是阻塞的。</p></blockquote><p><strong>从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态。（重要！！！）</strong></p><p><strong>高并发的程序一般使用同步非阻塞方式而非多线程+同步阻塞方式</strong>。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，<strong>办事大厅里的人数就是并发数，而窗口个数就是并行度</strong>。也就是说<strong>并发数是指同时进行的任务数（如同时服务的Http请求），而并行数是可以同时工作的物理资源数量（如CPU核数）</strong>。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。<strong>而同步非阻塞方式可以把多个IO请求丢到后台去，这就可以在一个进程里服务大量的并发IO请求</strong>。</p><p><strong>注意：IO多路复用是同步阻塞模型还是异步阻塞模型，在此给大家分析下：</strong></p><blockquote><p>此处仍然不太清楚的，强烈建议大家再细究<a href="https://link.jianshu.com/?t=http://my.oschina.net/xianggao/blog/661085" target="_blank" rel="noopener">《聊聊同步、异步、阻塞与非阻塞》</a>中讲同步与异步的根本性区别，<strong>同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程为阻塞。</strong>所以，<strong>把IO多路复用归为同步阻塞模式</strong>。</p></blockquote><h3 id="2-4-信号驱动式IO（signal-driven-IO）"><a href="#2-4-信号驱动式IO（signal-driven-IO）" class="headerlink" title="2.4 信号驱动式IO（signal-driven IO）"></a>2.4 信号驱动式IO（signal-driven IO）</h3><p>信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。过程如下图所示：</p><p><img src="https://static.oschina.net/uploads/img/201604/21091434_DsZb.png" alt></p><h3 id="2-5-异步非阻塞IO-asynchronous-IO"><a href="#2-5-异步非阻塞IO-asynchronous-IO" class="headerlink" title="2.5 异步非阻塞IO(asynchronous IO)"></a>2.5 异步非阻塞IO(asynchronous IO)</h3><h4 id="2-5-1-场景描述"><a href="#2-5-1-场景描述" class="headerlink" title="2.5.1 场景描述"></a>2.5.1 场景描述</h4><blockquote><p>女友不想逛街，又嫌餐厅太吵了，回家好好休息一下。于是我们叫外卖，打个电话点餐，然后我和女友可以在家好好休息一下，饭好了送货员送到家里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了。</p></blockquote><h4 id="2-5-2-网络模型"><a href="#2-5-2-网络模型" class="headerlink" title="2.5.2 网络模型"></a>2.5.2 网络模型</h4><p>相对于同步IO，异步IO不是顺序执行。<strong>用户进程进行aio_read系统调用后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。</strong>等到socket数据准备好了，内核直接复制数据给进程，<strong>然后从内核向进程发送通知，IO的两个阶段，进程都是非阻塞的。</strong></p><p>Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示：</p><p><img src="https://static.oschina.net/uploads/img/201604/20175459_gtgw.png" alt></p><h4 id="2-5-3-流程描述"><a href="#2-5-3-流程描述" class="headerlink" title="2.5.3 流程描述"></a>2.5.3 流程描述</h4><p>用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，<strong>首先它会立刻返回，所以不会对用户进程产生任何block</strong>。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，<strong>当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次IO处理过程</strong>，告诉他read操作完成了。</p><p><strong>在 Linux 中，通知的方式是 “信号”：</strong></p><blockquote><p><strong>如果这个进程正在用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数</strong>，这个函数可以决定何时以及如何处理这个异步任务。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，<strong>一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事</strong>。</p><p><strong>如果这个进程正在内核态忙着做别的事</strong>，例如以同步阻塞方式读写磁盘，<strong>那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知</strong>。</p><p><strong>如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒</strong>，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。</p></blockquote><p>异步 API 说来轻巧，做来难，这主要是对 API 的实现者而言的。Linux 的异步 IO（AIO）支持是 2.6.22 才引入的，还有很多系统调用不支持异步 IO。Linux 的异步 IO 最初是为数据库设计的，<strong>因此通过异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制</strong>。</p><p><strong>很多人把 Linux 的 O_NONBLOCK 认为是异步方式，但事实上这是前面讲的同步非阻塞方式。</strong>需要指出的是，虽然 Linux 上的 IO API 略显粗糙，但每种编程框架都有封装好的异步 IO 实现。操作系统少做事，把更多的自由留给用户，正是 UNIX 的设计哲学，也是 Linux 上编程框架百花齐放的一个原因。</p><p>从前面 IO 模型的分类中，我们可以看出 AIO 的动机</p><blockquote><p>同步阻塞模型需要在 IO 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 IO 操作。</p><p>同步非阻塞模型允许处理和 IO 操作重叠进行，但是这需要应用程序根据重现的规则来检查 IO 操作的状态。</p><p>这样就剩下异步非阻塞 IO 了，它允许处理和 IO 操作重叠进行，包括 IO 操作完成的通知</p></blockquote><p>IO多路复用除了需要阻塞之外，<strong>select 函数所提供的功能（异步阻塞 IO）与 AIO 类似</strong>。不过，<strong>它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞</strong>。</p><h3 id="2-6-异步阻塞"><a href="#2-6-异步阻塞" class="headerlink" title="2.6 异步阻塞"></a>2.6 异步阻塞</h3><p>有时我们的 API 只提供异步通知方式，例如在 node.js 里，<strong>但业务逻辑需要的是做完一件事后做另一件事</strong>，例如数据库连接初始化后才能开始接受用户的 HTTP 请求。这样的业务逻辑就需要调用者是以阻塞方式来工作。</p><p><strong>另外一种使用阻塞方式的理由是降低响应延迟</strong>。如果采用非阻塞方式，一个任务 A 被提交到后台，就开始做另一件事 B，但 B 还没做完，A 就完成了，这时要想让 A 的完成事件被尽快处理（比如 A 是个紧急事务），要么丢弃做到一半的 B，要么保存 B 的中间状态并切换回 A，任务的切换是需要时间的（不管是从磁盘载入到内存，还是从内存载入到高速缓存），这势必降低 A 的响应速度。<strong>因此，对实时系统或者延迟敏感的事务，有时采用阻塞方式比非阻塞方式更好</strong>。</p><h2 id="3-五种IO模型总结"><a href="#3-五种IO模型总结" class="headerlink" title="3. 五种IO模型总结"></a>3. 五种IO模型总结</h2><h3 id="3-1-blocking和non-blocking-区别"><a href="#3-1-blocking和non-blocking-区别" class="headerlink" title="3.1 blocking和non-blocking 区别"></a>3.1 blocking和non-blocking 区别</h3><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><h3 id="3-2-synchronousIO-和-asynchronous-IO区别"><a href="#3-2-synchronousIO-和-asynchronous-IO区别" class="headerlink" title="3.2 synchronousIO 和 asynchronous IO区别"></a>3.2 synchronousIO 和 asynchronous IO区别</h3><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p><blockquote><p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p><p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p></blockquote><p><strong>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞</strong>。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p><p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，<strong>定义中所指的”IO operation”是指真实的IO操作</strong>，就是例子中的recvfrom这个system call。nonblocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，<strong>当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了</strong>，在这段时间内，进程是被block的。</p><p>而asynchronous IO则不一样，<strong>当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成</strong>。在这整个过程中，进程完全没有被block。</p><p><strong>各个IO Model的比较如图所示：</strong></p><p><img src="https://static.oschina.net/uploads/img/201604/21095604_vhHX.png" alt></p><p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。<strong>在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check</strong>，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。<strong>它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知</strong>。在此期间，<strong>用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概念说明&quot;&gt;&lt;a href=&quot;#1-概念说明&quot; class=&quot;headerlink&quot; title=&quot;1. 概念说明&quot;&gt;&lt;/a&gt;1. 概念说明&lt;/h2&gt;&lt;p&gt;在进行解释前，首先说明几个概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用户空间和内核空间&lt;/p&gt;
&lt;p&gt;进程切换&lt;/p&gt;
&lt;p&gt;进程的阻塞&lt;/p&gt;
&lt;p&gt;文件描述符&lt;/p&gt;
&lt;p&gt;缓存IO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-1-用户空间和内核空间&quot;&gt;&lt;a href=&quot;#1-1-用户空间和内核空间&quot; class=&quot;headerlink&quot; title=&quot;1.1 用户空间和内核空间&quot;&gt;&lt;/a&gt;1.1 用户空间和内核空间&lt;/h3&gt;&lt;p&gt;现在操作系统都是采用虚拟存储器，那么对于32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。&lt;strong&gt;操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限&lt;/strong&gt;。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，&lt;strong&gt;操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。&lt;/strong&gt;针对linux操作系统而言，将最高的1G字节（从虚拟地址&lt;code&gt;0xC0000000&lt;/code&gt;到&lt;code&gt;0xFFFFFFF&lt;/code&gt;），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址&lt;code&gt;0x00000000&lt;/code&gt;到&lt;code&gt;0xBFFFFFFF&lt;/code&gt;），供各个进程使用，称为用户空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1920x1200c5/g5/M00/01/04/ChMkJlg2YRGIXrtCABy9qCTYS60AAYB1AAAAAAAHL3A605.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程状态及切换</title>
    <link href="http://yoursite.com/2020/03/24/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%88%87%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/03/24/Java线程状态及切换/</id>
    <published>2020-03-23T16:00:00.000Z</published>
    <updated>2020-03-25T11:30:46.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、线程的几个重要方法"><a href="#一、线程的几个重要方法" class="headerlink" title="一、线程的几个重要方法"></a>一、线程的几个重要方法</h2><ul><li>start()方法，开始执行该线程</li><li>stop()方法，强制结束该线程执行</li><li>join()方法，等待该线程结束</li><li>sleep()方法，线程进入等待</li><li>run()方法，直接执行线程的run()方法，但是线程调用start()方法时也会运行run()方法，区别就是一个是由线程调度运行run()方法，一个是直接调用了线程中的run()方法</li></ul><p><img src="http://pic1.win4000.com/wallpaper/0/57f86946b178d.jpg" alt><br><a id="more"></a></p><p>至于wait()和notify()他们是Objetc的方法，不是Thread的方法，同时wait()与notify()会配合使用，分别表示线程挂起和线程恢复。</p><p>wait()和sleep()的区别，<strong>wait()会释放对象锁资源，而sleep()不会释放对象锁资源。但是wait和sleep都会释放cpu资源。</strong></p><h2 id="二、Java线程的生命周期"><a href="#二、Java线程的生命周期" class="headerlink" title="二、Java线程的生命周期"></a>二、Java线程的生命周期</h2><ol><li><p>新建(NEW):新建了一个线程对象，并没有调用start()之前</p></li><li><p>可运行(Runnable):就绪状态，<strong>调用start()之后线程就进入就绪状态，但是并不是说只要调用start()线程马上变为当前线程，在变为当前线程之前都是为就绪状态。线程在睡眠和挂起中恢复的时候也会进入就绪状态。</strong> 线程对象创建后，其他线程（比如main线程)调用了该对象的start()方法，该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPI的使用权。</p></li><li><p>运行(Running):可运行状态的线程获得了CPU时间片，执行程序代码。线程被设置为当前线程，开始执行run()方法，就是线程进入了运行状态</p></li><li><p>阻塞(Blocked):阻塞是指线程因为某种原因放弃了cpu使用权，即让出了cpu 时间片，暂时停止运行。知道线程进入可运行状态，才有机会再次获得cpu 时间片转到运行状态。线程被暂停，比如调用sleep()方法后，线程就进入阻塞状态。</p><p>阻塞分为三种情况：</p><ul><li>等待阻塞：运行的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中</li><li>其他阻塞：运行的线程执行Thread.sleep(long ms)或者t.join()方法，或者放出了I/O请求，JVM会把线程设置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行状态</li></ul></li><li><p>死亡(Dead):线程执行结束，线程run()、main()方法执行结束，或者异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ol><p><img src="https://s1.ax1x.com/2020/03/23/8H2gIg.png" alt="8H2gIg.png"></p><h2 id="三、具体状态"><a href="#三、具体状态" class="headerlink" title="三、具体状态"></a>三、具体状态</h2><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态</p><h3 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h3><ol><li>可运行状态只是说你有资格运行，调度程序没有挑选到你，你就永远是可运行状态。</li><li>调用线程的start()方法，此线程进入可运行状态</li><li>当前线程sleep()方法结束、其他线程join()方法结束、等待用户输入完毕、某个线程拿到对象锁，这些线程也将进入可运行状态</li><li>当前线程时间片用完了、调用当前线程的yield()方法，当前线程进入可运行状态</li><li>锁池里的线程拿到对象锁后，进入可运行状态</li></ol><h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一方式</p><h3 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h3><ol><li>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。 <strong>线程一旦死亡，就不能复生</strong></li><li>在一个死去的线程上调用start()方法，会抛出<code>java.lang.IllegalThreadStateException</code>异常</li></ol><h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><ol><li>当前线程T调用Thread.sleep()方法，当前线程进入阻塞状态</li><li>运行在当前线程里的其他线程t2调用join方法，当前线程进入阻塞状态</li><li>等待用户输入时，当前线程进入阻塞状态</li></ol><h3 id="等待队列（本是Object里的方法，但影响了线程）"><a href="#等待队列（本是Object里的方法，但影响了线程）" class="headerlink" title="等待队列（本是Object里的方法，但影响了线程）"></a>等待队列（本是Object里的方法，但影响了线程）</h3><ol><li>调用obj的wait()、notify()方法前，必须获得obj锁，也就是必须写在<code>synchronized(obj)</code>代码段内。</li><li>等待队列相关的步骤和图</li></ol><p><img src="https://s1.ax1x.com/2020/03/23/8H4Kjs.png" alt="8H4Kjs.png"></p><h2 id="四、几个方法的比较"><a href="#四、几个方法的比较" class="headerlink" title="四、几个方法的比较"></a>四、几个方法的比较</h2><ul><li><p>sleep：Thread类的方法，必须带一个时间参数。 <strong>会让当前线程休眠进入阻塞状态并释放CPU( sleep释放cpu，wait也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段)</strong>，提供其他线程运行的机会且不考虑优先级，但如果有同步锁，则sleep不会释放锁，即其他线程无法获得同步锁，可通过调用interrupt()方法来唤醒休眠线程。（interrupt()的作用是，在线程收到阻塞时，抛出一个中断信号，这样线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait，Thread.join和Thread.sleep三种方法之一阻塞，那么它将接收到一个中断异常(<code>InterruptedException</code>)，从而提早终结被阻塞状态）</p></li><li><p>yield：<strong>让出CPU调度</strong>，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间，并且yield()方法 <strong>只能让同优先级的线程</strong>有执行的机会。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入 <strong>可执行状态后</strong>马上又被执行。调用yield()方法只是一个建议，告诉线程调度器，我的工作已经做的差不多了，可以让别的相同优先级的线程使用cpu了，没有任何机制保证采纳</p></li><li><p>wait: Object类的方法(notify()、notifyAll())，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程池等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)，即放入锁池中竞争同步锁</p></li><li><p>join:一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态，直到另一个线程运行结束，等待该线程终止。注意该方法也需要捕捉异常。</p><p>等待调用join方法的线程结束，再继续执行。</p><p><img src="https://s1.ax1x.com/2020/03/23/8H4UgJ.png" alt="8H4UgJ.png"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、线程的几个重要方法&quot;&gt;&lt;a href=&quot;#一、线程的几个重要方法&quot; class=&quot;headerlink&quot; title=&quot;一、线程的几个重要方法&quot;&gt;&lt;/a&gt;一、线程的几个重要方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;start()方法，开始执行该线程&lt;/li&gt;
&lt;li&gt;stop()方法，强制结束该线程执行&lt;/li&gt;
&lt;li&gt;join()方法，等待该线程结束&lt;/li&gt;
&lt;li&gt;sleep()方法，线程进入等待&lt;/li&gt;
&lt;li&gt;run()方法，直接执行线程的run()方法，但是线程调用start()方法时也会运行run()方法，区别就是一个是由线程调度运行run()方法，一个是直接调用了线程中的run()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://pic1.win4000.com/wallpaper/0/57f86946b178d.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>同步异步与阻塞非阻塞</title>
    <link href="http://yoursite.com/2020/03/24/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>http://yoursite.com/2020/03/24/同步异步阻塞非阻塞/</id>
    <published>2020-03-23T16:00:00.000Z</published>
    <updated>2020-03-25T11:30:46.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-同步与异步"><a href="#1-同步与异步" class="headerlink" title="1 同步与异步"></a>1 同步与异步</h2><p><strong>首先来解释下同步和异步的概念，这两个概念和消息的通知机制有关。也就是同步和异步主要是从消息通知机制角度来说的。</strong></p><h3 id="1-1-概念描述"><a href="#1-1-概念描述" class="headerlink" title="1.1 概念描述"></a>1.1 概念描述</h3><p><strong>所谓同步就是一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才算完成，这是一种可靠的任务序列。</strong>要么成功都成功，要么失败都失败，这两个任务的状态可以一致。</p><p><strong>所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。</strong>至于依赖的任务最终是否真正完成，依赖它的任务无法确定，<strong>所以它是不可靠的任务序列。</strong></p><p><img src="http://img3.51tietu.net/pic/2016-060411/20160604110705phmiwo32jbb329772.jpg" alt><br><a id="more"></a></p><h3 id="1-2-消息通知"><a href="#1-2-消息通知" class="headerlink" title="1.2 消息通知"></a>1.2 消息通知</h3><p><strong>异步的概念和同步相对</strong>。当一个同步调用发出后，<strong>调用者要一直等待返回消息(结果)通知后</strong>，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。<strong>实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者</strong>。</p><p>这里提到的执行部件和调用者通过三种途径返回结果：<code>状态、通知和回调</code>。使用哪一种通知机制，<code>依赖于执行部件的实现</code>，除非执行部件提供多种选择，<code>否则不受调用者控制</code>。</p><blockquote><p>1.如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误。</p><p>2.如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</p></blockquote><h3 id="1-3-场景比喻"><a href="#1-3-场景比喻" class="headerlink" title="1.3 场景比喻"></a>1.3 场景比喻</h3><p>举个例子，比如我去银行办理业务，可能会用两种方式：</p><blockquote><ol><li>选择排队等候</li><li>另外一种选择，取号，等到排到我这一号时由柜台的人通知我去办理业务</li></ol></blockquote><p>第一种：<strong>前者（排队等候）就是同步等待消息通知</strong>，也就是我要一直在等待银行办理业务情况；</p><p>第二种：<strong>后者（等待别人通知）就是异步等待消息通知</strong>，在异步消息处理中，<strong>等待消息通知者（等待办理业务的人）往往注册一个回调机制</strong>。在所等待的事件被触发时由触发机制（柜台的人）通过某种机制（写在小纸条上的号码，喊号）找到等待该事件的人。</p><h2 id="2-阻塞非阻塞"><a href="#2-阻塞非阻塞" class="headerlink" title="2. 阻塞非阻塞"></a>2. 阻塞非阻塞</h2><p><strong>阻塞和非阻塞这两个概念与程序（线程）等待消息通知（无所谓同步或者异步）时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</strong></p><h3 id="2-1-概念描述"><a href="#2-1-概念描述" class="headerlink" title="2.1 概念描述"></a>2.1 概念描述</h3><p><strong>阻塞调用是指调用结果返回前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务</strong>。函数只有在得到结果之后才会返回。</p><p><strong>有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。</strong></p><ol><li><strong>对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已。此时，这个线程可能也会处理其他的消息。</strong>扩展点：</li></ol><blockquote><p>(a)如果这个线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫作同步非阻塞</p><p>(b)如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做同步阻塞</p></blockquote><p><strong>所以同步的实现方式会有两种：同步阻塞、同步非阻塞；同理，异步也会有两种实现：异步阻塞、异步非阻塞</strong>。</p><ol><li><p>对于阻塞调用来说，则当前线程就会被挂起等待当前函数返回</p><p>非阻塞和阻塞的概念相对于，<strong>指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</strong>虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，<strong>但是也带来了另外一种后果就是系统的线程切换增加，增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。</strong></p></li></ol><h3 id="2-2-场景比喻"><a href="#2-2-场景比喻" class="headerlink" title="2.2 场景比喻"></a>2.2 场景比喻</h3><p>继续上面的例子，不论是排队还是取号等待通知，<strong>如果在这个等待的过程中，等待者除了等待消息通知之外不能做其他事情，那么该机制就是阻塞的</strong>。表现在程序中，也就是该程序一直阻塞在该函数调用处不能继续往下执行。</p><p>相反，<strong>有的人喜欢在银行办理这些业务的时候，一边打电话发短信一边等待，这样的状态就是非阻塞的</strong>，因为等待者没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</p><p>但是需要注意的是，<strong>同步非阻塞形式实际上是效率低下的</strong>，想象一下你一边打着电话，一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而<strong>异步非阻塞形式却没有这样的问题，</strong>因为打电话是等待者的事情，而通知你则是柜台（消息触发机制）的事情，程序没有在两种不同的操作中来回切换。</p><h2 id="3-同步-异步与阻塞-非阻塞"><a href="#3-同步-异步与阻塞-非阻塞" class="headerlink" title="3 同步/异步与阻塞/非阻塞"></a>3 同步/异步与阻塞/非阻塞</h2><h3 id="3-1-同步阻塞形式"><a href="#3-1-同步阻塞形式" class="headerlink" title="3.1. 同步阻塞形式"></a>3.1. 同步阻塞形式</h3><p>效率最低，以上面的例子举例，就是你专心排队，什么别的事情都不做</p><p><strong>实际程序中：</strong>就是未对fd设置<code>O_NONBLOCK</code>标志位的 read/write操作</p><h3 id="3-2-异步阻塞形式"><a href="#3-2-异步阻塞形式" class="headerlink" title="3.2. 异步阻塞形式"></a>3.2. 异步阻塞形式</h3><p>如果是在银行等待办理业务的人，<strong>采用的是异步的方式去等待消息被触发（通知）</strong>，也就是领了一张小纸条，假如在这段时间里他不能离开银行去做其他的事情，那么很显然，这个人被阻塞在了这个等待的操作上面</p><p><strong>异步操作是可以被阻塞的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</strong></p><p>比如select函数，假如传入的最后一个timeout参数为NULL，<strong>那么如果所关注的事件没有一个被触发，程序就会一直阻塞在这个select调用处</strong></p><h3 id="3-3-同步非阻塞形式"><a href="#3-3-同步非阻塞形式" class="headerlink" title="3.3. 同步非阻塞形式"></a>3.3. 同步非阻塞形式</h3><p>实际上效率低下的，2.2已解释了效率低下的原因。很多人会写阻塞的read/write操作，<strong>但是可以对fd设置O_NONBLOCK标志位，这样就可以将同步操作变成非阻塞的了</strong>。</p><h3 id="3-4-异步非阻塞形式"><a href="#3-4-异步非阻塞形式" class="headerlink" title="3.4.异步非阻塞形式"></a>3.4.异步非阻塞形式</h3><p>效率更高，因为打电话是等待者的事情，而通知你是柜台（消息触发机制）的事情，<strong>程序没有在两种不同的操作中来回切换</strong>。</p><p>比如说，这个人突然想出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下(注册一个回调函数)，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p><p>如果使用异步非阻塞的情况，比如aio_<em>组的操作，当发起一个aio_read操作时，<em>*函数会马上返回不会被阻塞，当所关注的事件被触发时会调用之前注册的回调函数进行处理。</em></em></p><blockquote><p>很多人会把同步和阻塞混淆，我想是因为<strong>很多时候同步操作会以阻塞的形式表现出来，但最根本是因为没有区分这两个概念。</strong>比如阻塞的read/write操作中，<strong>其实是把消息通知机制和等待消息通知的状态结合在了一起，</strong>在这里<strong>所关注的消息就是fd是否可读/写，</strong>而<strong>等待消息通知的状态则是对fd可读/写等待过程中程序（线程）的状态</strong>。如果我们将这个fd设置为非阻塞的时候，read/write操作就不会在等待消息通知这里阻塞，如果fd不可读/写,则操作立即返回。</p><p>同样的，很多人也会把异步和非阻塞混淆，<strong>因为异步操作一般都不会在真正的IO操作处被阻塞，</strong>比如如果用select函数，<strong>当select返回可读时再去read一般不会被阻塞，而是在select函数调用处阻塞</strong>。</p></blockquote><h2 id="4-小明的故事"><a href="#4-小明的故事" class="headerlink" title="4.小明的故事"></a>4.小明的故事</h2><p>对上面所讲的概念再次进行一个场景梳理，上面已经明确说过了，<strong>同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序(线程)等待消息通知的状态</strong>。以小明下载文件打个比方，从这两个关注点来再次说明这两组概念，希望能更好的促进大家的理解。</p><p><strong>同步阻塞：小明一直盯着下载进度条，到100%的时候完成</strong></p><blockquote><p>同步体现在：等待下载完成通知</p><p>阻塞体现在：等待下载完成通知的过程中，不能做其他任务处理</p></blockquote><p><strong>同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到100%就完成</strong></p><blockquote><p>同步体现在：等待下载完成通知</p><p>非阻塞体现在：等待下载完成通知的过程中，去干别的任务了，只是时不时会瞄一眼进度条（小明必须要在两个任务间切换，关注下载进度）</p></blockquote><p><strong>异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就”叮”一声，不过小明仍然一直在等待”叮“的声音（看起来很傻）</strong></p><blockquote><p>异步体现在：下载完成”叮”一声通知</p><p>阻塞体现在：等待下载完成后”叮”一声通知中，不能做其他任务处理</p></blockquote><p><strong>异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了</strong></p><blockquote><p>异步体现在：下载完成”叮”一声通知</p><p>阻塞体现在：等待下载完成后”叮”一声通知中，去干别的任务了，只需要接收”叮”的一声通知即可，（软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件”叮”的通知即可</p></blockquote><p>也就是说，<strong>同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务）</strong>，在不同的场景下，同步/异步、阻塞/非阻塞的四种组合都有应用。</p><p>所以综上所述，<strong>同步和异步仅仅是关注的消息如何通知的机制，而阻塞与非阻塞关注的是等待消息通知时的状态。</strong>也就是说，<strong>同步的情况下，是由处理消息者自己去等待消息是否被触发，而异步的情况下是由触发机制来通知处理消息者，</strong>所以在异步机制中，<strong>处理消息和触发机制之间就需要一个连接的桥梁:</strong></p><blockquote><p>银行的例子中，这个桥梁就是小纸条上的号码</p><p>小明的例子中，这个桥梁就是软件”叮”的声音</p></blockquote><p><strong>最后，大家注意理解”消息通知机制”和”等待消息通知时的状态”这两个概念，这是理解四个概念的关键所在。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-同步与异步&quot;&gt;&lt;a href=&quot;#1-同步与异步&quot; class=&quot;headerlink&quot; title=&quot;1 同步与异步&quot;&gt;&lt;/a&gt;1 同步与异步&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;首先来解释下同步和异步的概念，这两个概念和消息的通知机制有关。也就是同步和异步主要是从消息通知机制角度来说的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-1-概念描述&quot;&gt;&lt;a href=&quot;#1-1-概念描述&quot; class=&quot;headerlink&quot; title=&quot;1.1 概念描述&quot;&gt;&lt;/a&gt;1.1 概念描述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;所谓同步就是一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才算完成，这是一种可靠的任务序列。&lt;/strong&gt;要么成功都成功，要么失败都失败，这两个任务的状态可以一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。&lt;/strong&gt;至于依赖的任务最终是否真正完成，依赖它的任务无法确定，&lt;strong&gt;所以它是不可靠的任务序列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.51tietu.net/pic/2016-060411/20160604110705phmiwo32jbb329772.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java秒杀系统方案优化 高性能高并发实战</title>
    <link href="http://yoursite.com/2019/06/16/Java%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/06/16/Java秒杀系统方案优化/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2020-03-25T11:30:46.260Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIBt6YAAvmGfwhdgwAALGfwFf6LcAC-Yx733.jpg" alt></p><h2><br>  项目安排<br></h2><h3>1.项目搭建</h3><ul><li><code>SpringBoot</code> 环境搭建</li><li>集成<code>Thymeleaf</code>,<code>Result</code>结果封装</li><li>集成<code>Mybatis</code> + <code>Druid</code></li><li>集成<code>Jedis</code> +<code>Redis</code>安装 + 通用缓存<code>Key</code>封装</li></ul><a id="more"></a><h3>2.实现登录功能</h3><ul><li>数据库设计</li><li>明文密码两次<code>MD5</code>处理</li><li><code>JSR303</code>参数校验 + 全局异常处理器</li><li>分布式<code>Session</code></li></ul><h3>3.实现秒杀功能</h3><ul><li>数据库设计</li><li>商品列表页</li><li>商品详情页</li><li>订单详情页 </li></ul><h4>4.JMeter压测</h4><ul><li><code>JMeter</code>入门</li><li>自定义多变量模拟多用户</li><li><code>JMeter</code>命令行使用</li><li><code>SpringBoot</code>打<code>War</code>包</li></ul><h3>5.页面优化技术</h3><ul><li>页面缓存 + <code>URL</code>缓存 + 对象缓存</li><li>页面静态化 ，前后端分离</li><li>静态资源优化</li><li><code>CDN</code>优化</li></ul><h3>6.接口优化</h3><ul><li><code>Redis</code>预减库存减少数据库访问</li><li>内存标记减少<code>Redis</code>访问</li><li><code>RabbitMQ</code>队列缓冲，异步下单，增强用户体验</li><li><code>RabbitMQ</code>安装与<code>SpringBoot</code>集成</li><li>访问<code>Nginx</code>水平扩展</li><li>分库分表（<code>Mycat</code>)</li><li>压测</li></ul><h3>7.安全优化</h3><ul><li>秒杀接口地址隐藏</li><li>数学公式验证码</li><li>接口防刷</li></ul><hr><h2>1.项目搭建</h2><h3>集成Redis中的问题和笔记</h3><h4>1.Spring注入</h4><p><code>Spring</code>通过<code>DI</code>（依赖注入）实现<code>IOC</code>（控制反转)，常用的注入方式主要有以下三种:</p><ul><li>构造方法注入</li><li><code>setter</code>方法注入</li><li>基于注解的注入</li></ul><h4>构造方法注入</h4><p>在spring的配置文件中注册UserService，将UserDaoJdbc通过constructor-arg标签注入到UserService的<strong>某个</strong>有参数的构造方法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册userService --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.lyu.spring.service.impl.UserService"</span>&gt;</span><br><span class="line">&lt;constructor-arg ref="userDaoJdbc"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册jdbc实现的dao --&gt;</span><br><span class="line">&lt;bean id="userDaoJdbc" class="com.lyu.spring.dao.impl.UserDaoJdbc"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>如果只有一个有参数的构造方法并且参数类型与注入的bean的类型匹配，那就会注入到该构造方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(IUserDao userDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDao.loginUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">// 获取bean对象</span></span><br><span class="line">UserService userService = ac.getBean(UserService.class, <span class="string">"userService"</span>);</span><br><span class="line"><span class="comment">// 模拟用户登录</span></span><br><span class="line">userService.loginUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><h4>setter注入</h4><p>配置文件如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册userService --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.lyu.spring.service.impl.UserService"</span>&gt;</span><br><span class="line">&lt;!-- 写法一 --&gt;</span><br><span class="line">&lt;!-- &lt;property name="UserDao" ref="userDaoMyBatis"&gt;&lt;/property&gt; --&gt;</span><br><span class="line">&lt;!-- 写法二 --&gt;</span><br><span class="line">&lt;property name="userDao" ref="userDaoMyBatis"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册mybatis实现的dao --&gt;</span><br><span class="line">&lt;bean id="userDaoMyBatis" class="com.lyu.spring.dao.impl.UserDaoMyBatis"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>注：上面这两种写法都可以,spring会将name值的每个单词首字母转换成大写，然后再在前面拼接上”set”构成一个方法名,然后去对应的类中查找该方法,通过反射调用,实现注入。</strong></p><p><em>切记：name属性值与类中的成员变量名以及set方法的参数名都无关，只与对应的set方法名有关，下面的这种写法是可以运行成功的</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IUserDao userDao1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(IUserDao userDao1)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao1 = userDao1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDao1.loginUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>还有一点需要注意：如果通过set方法注入属性，那么spring会通过默认的空参构造方法来实例化对象，所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上，否则spring没有办法实例化对象，导致报错。</strong></p><h4>基于注解的注入</h4><p>在介绍注解注入的方式前，先简单了解<code>bean</code>的一个属性<code>autowire</code>，<code>autowire</code>主要有三个属性值：<code>constructor</code>，<code>byName</code>，<code>byType</code>。</p><ul><li><p><code>constructor</code>：通过构造方法进行自动注入，<code>spring</code>会匹配与构造方法参数类型一致的<code>bean</code>进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的<code>bean</code>，那么<code>spring</code>会优先将<code>bean</code>注入到多参数的构造方法中。</p></li><li><p><code>byName</code>：被注入<code>bean</code>的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。</p></li><li><p><code>byType</code>：查找所有的set方法，将符合符合参数类型的bean注入。</p></li></ul><hr><p>主要有四种注解可以注册bean，每种注解可以任意使用，只是语义上有所差异：</p><ul><li><code>@Component</code>：可以用于注册所有bean</li><li><code>@Repository</code>：主要用于注册dao层的bean</li><li><code>@Controller</code>：主要用于注册控制层的bean</li><li><code>@Service</code>：主要用于注册服务层的bean</li></ul><p>描述依赖关系主要有两种：</p><ul><li><code>@Resource</code>：java的注解，默认以byName的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（spring注解）指定某个具体名称的bean。</li><li><code>@Autowired</code>：spring注解，<strong>默认是以byType的方式去匹配类型相同的bean</strong>，如果只匹配到一个，那么就直接注入该bean，无论要注入的 bean 的 name 是什么；如果匹配到多个，就会调用就会调用 <strong><code>DefaultListableBeanFactory</code></strong> 的 <strong><code>determineAutowireCandidate</code></strong> 方法来决定具体注入哪个bean</li></ul><blockquote><p>determineAutowireCandidate 方法的逻辑是：</p><ol><li>先找 Bean 上有@Primary 注解的，有则直接返回 bean 的 name。</li><li>再找 Bean 上有 @Order，@PriorityOrder 注解的，有则返回 bean 的 name。</li><li>最后再以名称匹配（ByName）的方式去查找相匹配的 bean</li></ol></blockquote><p>虽然有这么多的注入方式，但是实际上开发的时候自己编写的类一般用注解的方式注册类，用@Autowired描述依赖进行注入，一般实现类也只有一种（jdbc or hibernate or mybatis），除非项目有大的变动，所以@Qualifier标签用的也较少；但是在使用其他组件的API的时候用的是通过xml配置文件来注册类，描述依赖，因为你不能去改人家源码嘛。</p><h4>2.</h4><p><a href="https://postimg.cc/tYCsYJ80" target="_blank" rel="noopener"><img src="https://i.postimg.cc/Pr1YV84q/WX20190519-182215-2x.png" alt="WX20190519-182215-2x.png"></a></p><h3>2.实现登录</h3><h4>1.两次MD5</h4><ol><li>用户端：PASS = MD5（明文 + 固定Salt)</li><li>服务端：PASS = MD5（用户输入 + 随机Salt）</li></ol><h4>2.数据库三大范式</h4><ul><li>1NF：要求有主键，并且要求每一个字段原子性不可再分</li></ul><blockquote><p>1NF是对属性的<strong>原子性</strong>，要求属性具有原子性，不可再分解；</p><p>表：字段1、 字段2(字段2.1、字段2.2)、字段3 ……</p><p>如学生（学号，姓名，性别，出生年月日），如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不是一范式了，否则就是。</p></blockquote><ul><li>2NF：要求所有非主键字段完全依赖主键，不能产生部分依赖</li></ul><blockquote><p>2NF是对记录的<strong>惟一性</strong>，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；</p><p>表：学号、课程号、姓名、学分;</p><p>这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里<strong>学分依赖课程号</strong>，<strong>姓名依赖与学号</strong>，所以不符合二范式。</p><p><strong>可能会存在问题：</strong></p><ul><li><code>数据冗余:</code>，每条记录都含有相同信息；</li><li><code>删除异常：</code>删除所有学生成绩，就把课程信息全删除了；</li><li><code>插入异常：</code>学生未选课，无法记录进数据库；</li><li><code>更新异常：</code>调整课程学分，所有行都调整。</li></ul><p><strong>正确做法:</strong><br>学生：<code>Student</code>(学号, 姓名)；<br>课程：<code>Course</code>(课程号, 学分)；<br>选课关系：<code>StudentCourse</code>(学号, 课程号, 成绩)。</p></blockquote><ul><li>3NF：所有非主键字段和主键字段之间不能传递依赖</li></ul><blockquote><p>3NF是对字段的<strong>冗余性</strong>，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</p><p>表: 学号, 姓名, 年龄, 学院名称, 学院电话</p><p>因为存在<strong>依赖传递</strong>: (学号) → (学生)→(所在学院) → (学院电话) 。</p><p><strong>可能会存在问题：</strong></p><ul><li><code>数据冗余:</code>有重复值；</li><li><code>更新异常：</code>有重复的冗余信息，修改时需要同时修改多条记录，否则会出现<strong>数据不一致的情况</strong> 。</li></ul><p><strong>正确做法：</strong></p><p>学生：(学号, 姓名, 年龄, 所在学院)；</p><p>学院：(学院, 电话)。</p></blockquote><h4>反范式</h4><p><strong>一般说来，数据库只需满足第三范式（3NF）就行了。</strong></p><blockquote><p>没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余，<strong>达到以空间换时间的目的</strong>。</p><p>〖例〗：有一张存放商品的基本表，如表1所示。“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以<strong>提高查询统计的速度</strong>，这就是以<strong>空间换时间</strong>的作法。</p></blockquote><h4>范式化设计和反范式化设计的优缺点</h4><p><strong>范式化</strong></p><p><strong>优点</strong></p><ul><li>可以尽可能的减少数据冗余</li><li>数据表更新快，体积小</li></ul><p><strong>缺点</strong></p><ul><li>对于查询需要对多个表进行关联，导致性能低</li><li>更难进行索引优化</li></ul><p><strong>反范式化</strong></p><p><strong>优点</strong></p><ul><li>可以减少表的关联</li><li>可以更好进行索引优化</li></ul><p><strong>缺点</strong></p><ul><li>存在数据冗余及数据维护异常</li><li>对数据的修改需要更多的成本</li></ul><h3>五、页面优化</h3><h4>页面缓存</h4><ol><li>取缓存</li><li>手动渲染模板</li><li>结果输出</li></ol><h4>静态资源优化</h4><ol><li>JS/CSS压缩，减少流量</li><li>多个JS/CSS组合，减少连接数</li><li>CDN就近访问</li></ol><h3>六、秒杀接口优化</h3><p><strong>思路：减少数据库访问 </strong></p><ol><li>系统初始化，把商品库存数量加载到Redis</li><li>收到请求，Redis预减库存，库存不足，直接返回，否则进入3</li><li>请求入队，立即返回排队中</li><li>请求出队，生成订单，减少库存</li><li>客户端轮询，是否秒杀成功</li></ol><p><strong>1.<code>SpringBoot</code>集成<code>RabbitMQ</code></strong></p><ol><li>添加依赖<code>spring-boot-starter-amqp</code></li><li>创建消息接受者</li><li>创建消息发送者</li></ol><h3>7.安全优化</h3><ul><li>秒杀接口地址隐藏</li><li>数学公式验证码</li><li>接口防刷</li></ul><p><strong>1.秒杀接口地址隐藏</strong></p><p><strong>思路：秒杀开始之前，先去请求接口获取秒杀地址</strong></p><ol><li>接口改造，带上PathVariable参数</li><li>添加生成地址的接口</li><li>秒杀收到请求，先验证PathVariable</li></ol><p><strong>2.数学公式验证码</strong></p><p><strong>思路：点击秒杀之前，先输入验证码，分散用户的请求</strong></p><ol><li>添加生成验证码的接口</li><li>在获取秒杀路径的时候，验证验证码</li><li>ScriptEngine使用 </li></ol><p><strong>3.接口限流</strong></p><p>把用户访问次数写入缓存，并加上有效时间。（可以用拦截器减少对业务代码的侵入）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIBt6YAAvmGfwhdgwAALGfwFf6LcAC-Yx733.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2&gt;&lt;br&gt;  项目安排&lt;br&gt;&lt;/h2&gt;

&lt;h3&gt;1.项目搭建&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SpringBoot&lt;/code&gt; 环境搭建&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Thymeleaf&lt;/code&gt;,&lt;code&gt;Result&lt;/code&gt;结果封装&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Mybatis&lt;/code&gt; + &lt;code&gt;Druid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Jedis&lt;/code&gt; +&lt;code&gt;Redis&lt;/code&gt;安装 + 通用缓存&lt;code&gt;Key&lt;/code&gt;封装&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="秒杀" scheme="http://yoursite.com/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>并发编程与高并发入门</title>
    <link href="http://yoursite.com/2019/06/11/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/06/11/并发编程入门与高并发笔记/</id>
    <published>2019-06-11T09:15:53.000Z</published>
    <updated>2020-03-25T11:30:46.267Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://996.icu" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/link-996.icu-red.svg"></a></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIFY_6AA3VjT9w7FMAALGfwFCj8AADdWl862.jpg" alt></p><h3>4.线程安全性</h3><br>定义：当多个线程访问某个类时，不管运行时环境采用<b>何种调度方式</b>或者这些进程将如何交替执行，并且在主调代码中<b>不需要任何额外的同步或协同</b>，这个类都能表现出<b>正确的行为</b>，那么就称这个类是线程安全的。<br><br><em> 原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。</em> 可见性：一个线程对主内存的修改可以及时的被其他线程观察到。<br><em> 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。<br><br><a id="more"></a><br><br><b>原子性——Atomic包</b><br><br>- AtomicXXX：CAS、Unsafe.compareAndSwapInt<br>- AtomicLong、LongAdder<br>- AtomicReference、AtomicReferenceFieldUpdater<br>- AtomicStampReference：CAS的ABA问题<br><br><b>原子性——锁</b></em> synchronized：依赖JVM<br><em> Lock：依赖特殊的CPU指令，代码实现，ReentrantLock<br><br><b>原子性——synchronize</b></em> 修饰代码块：大括号括起来的代码，作用于<b>调用对象</b><br><em> 修饰方法：整个方法，作用于<b>调用的对象</b></em> 修饰静态方法：整个静态方法，作用于这个<b>类的所有对象</b><br><em> 修饰类：括号括起来的部分，作用于这个<b>类的所有对象</b><br><br><b>原子性——对比</b></em> Synchronized：不可中断锁，适合竞争不激烈，可读性好<br><em> Lock：可中断锁，多样化同步，竞争激烈时能维持常态</em> Atomic：竞争激烈时能维持常态，比Lock性能好；只能同步一个值<br><br><b>可见性</b><br><br><em> 线程交叉执行</em> 重排序结合线程交叉执行<br><em> 共享变量更新后的值没有在工作内存及主存空间及时更新<br><br><b>可见性</b><br><br><b>JMM(Java Memory Model) 关于synchorized 的两条规定:</b></em> 线程解锁前，必须把共享变量的最新值刷新到主内存<br><em> 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读区最新的值（注意，加锁与解锁是同一把锁)<br><br><b>可见性——volatile</b><br><br>通过加入<b>内存屏障</b>和<b>禁止重排序</b>优化来实现</em> 对volatile变量写操作时，会在写操作后加入一条store 屏障指令，将本地内存中的共享变量值刷新到主内存<br><em> 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量<br><br><b>可见性——volatile使用（适合作为状态标识量）</b><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">context = loadContext();</span><br><span class="line">inited = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="keyword">while</span>(!inited)&#123;</span><br><span class="line">  sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure><br><br><b>有序性</b></em> java内存模型中，允许编译器和处理器对指令进行<b>重排序</b>，但是重排序过程不会影响到<b>单线程</b>程序的执行，却会影响到多线程并发执行的正确性<br><em> volatile、synchronized、Lock<br><br><b>有序性-happens-before原则</b><br><br><b>较重要的原则</b></em> 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br><em> 锁定原则：一个unLock操作先行发生于后面对同一个锁的lock操作</em> volatile变量规则：对一个变量的写操作先行发生于后面这个变量的读操作<br><em> 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br><br><b>显而易见的原则</b></em> 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作<br><em> 线程中断规则：对线程的interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</em> 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br><em> 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br><br><br><br><h3>线程安全性——总结</h3></em> 原子性：Atomic包、CAS算法、synchronized、Lock<br><em> 可见性：synchronized、volatile</em> 有序性：happens-before<br><br><h3>5.安全发布对象</h3><br><a href="https://postimg.cc/sBjb8q95" target="_blank" rel="noopener"><img src="https://i.postimg.cc/3wm7yHkf/WX20190707-225115-2x.png" alt="WX20190707-225115-2x.png"></a><br><br><br><br><strong>UnsafePublish.java</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafePublish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] states = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafePublish unsafePublis = <span class="keyword">new</span> UnsafePublish();</span><br><span class="line">        System.out.println(Arrays.toString(unsafePublis.getStates()));</span><br><span class="line"></span><br><span class="line">        unsafePublis.getStates()[<span class="number">0</span>] = <span class="string">"d"</span>;</span><br><span class="line">        System.out.println(Arrays.toString(unsafePublis.getStates()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>Console</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c]</span><br><span class="line">[d, b, c]</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><br><br><strong>Escape.java（对象溢出）</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Escape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thisCanBeEscape = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Escape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerClass();   <span class="comment">//在构造函数运行时，启动了一个新线程去实例化InnerClass</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"&#123;&#125;"</span>, Escape.<span class="keyword">this</span>.thisCanBeEscape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Escape();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>Console</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 [main] INFO com.interview.concurrency.publish.Escape - 0</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><br><br><strong>安全发布对象</strong><br><br><em>  在静态初始化函数中初始化一个对象引用</em> 将对象的引用保存到<code>volatile</code>类型域或者<code>AtomicReference</code>对象中<br><em> 将对象的引用保存到某个正确构造对象的final类域中</em> 将对象的引用保存到一个由锁保护的域中<br><br><br><br> <strong>（1）线程不安全的单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annotion.NotThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;     <span class="comment">//此处线程不安全</span></span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 并发情况下，两个线程都同时通过if判断，就会导致实例化两个不同的对象。<br><br><br><br><strong>（2）线程安全的单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 饿汉模式————单例实例类装载使用时创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; ​     饿汉模式是线程安全的，当类的构造方法中没有包含过多的操作处理，饿汉模式是可以接受的。<br>&gt;<br>&gt; ​    但他的不足之处在于：当类的构造方法中包含过多的操作处理时， 会导致类加载时特别慢。 因此可能会引    起性能问题；如果使用饿汉模式只进行类的加载，却没有实际调用的话，会造成资源的浪费。<br><br><br><br><strong>（3）线程安全的“懒汉”模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotRecommend;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@NotRecommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonExample3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 加了<code>synchronized</code>关键字，同一时刻只有一个线程可以访问这个方法，保证了线程安全性。<br>&gt;<br>&gt; 通过使用同一时刻只能有一个线程访问的方式来保证线程安全，但是会带来性能的开销。而这个开销是我们所不希望的，所以不建议这种方式。<br><br><strong>（4）双重同步锁单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> * 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. memory = allocate()分配对象内寸空间</span></span><br><span class="line">    <span class="comment">//2. ctorInstance()初始化对象</span></span><br><span class="line">    <span class="comment">//3. instance = memory 设置instance指向刚才分配的内存空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//JVM和cpu优化，发生了指令重排</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. memory = allocate()分配对象内寸空间、</span></span><br><span class="line">    <span class="comment">//3. instance = memory 设置instance指向刚才分配的内存空间</span></span><br><span class="line">    <span class="comment">//2. ctorInstance()初始化对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//双重检测机制          B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4.class) &#123;  <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4(); <span class="comment">//A-3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 在指令重排的情况，（A-3) 未初始化对象带来的线程不安全问题<br><br><br><br><strong>（5）正确的线程安全的懒汉式单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> * 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象  volatile + 双重检测机制 -&gt; 禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonExample5 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. memory = allocate()分配对象内寸空间</span></span><br><span class="line">    <span class="comment">//2. ctorInstance()初始化对象</span></span><br><span class="line">    <span class="comment">//3. instance = memory 设置instance指向刚才分配的内存空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//双重检测机制          B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample5.class) &#123;  <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample5(); <span class="comment">//A-3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>（6）最安全的枚举模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.Recommend;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:23:13</span></span><br><span class="line"><span class="comment"> * 枚举模式————最安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JVM保证这个方法只调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h3>11.高并发解决思路之扩容思路</h3><p><a href="https://postimg.cc/1f6nzJMw" target="_blank" rel="noopener"><img src="https://i.postimg.cc/m2pQ8nHX/WX20190704-215857-2x.png" alt="WX20190704-215857-2x.png"></a></p><p><a href="https://postimg.cc/2bZbBGms" target="_blank" rel="noopener"><img src="https://i.postimg.cc/bJ6QWV5w/WX20190704-220347-2x.png" alt="WX20190704-220347-2x.png"></a></p><h3>13.高并发解决思路之消息队列</h3><br><strong>特性</strong><br><br><em> 业务无关：只做消息分发</em> FIFO：先投递先到达<br><em> 容灾：节点的动态增删和消息的持久化</em> 性能：吞吐量提升，系统内部通信效率提高<br><br><br><br><strong>为什么需要消息队列</strong><br><br>&gt; 【生产】和【消费】的速度或稳定性等因素不一致<br><br><br><br><strong>消息队列好处</strong><br><br><em> 业务解耦</em> 最终一致性<br><em> 广播</em> 错峰与流控<br><br><br><br><strong>消息队列举例</strong><br><br><em> Kafka<br><br><a href="https://postimg.cc/TpHcT5dg" target="_blank" rel="noopener"><img src="https://i.postimg.cc/mgTpN7KX/WX20190515-221556-2x.png" alt="WX20190515-221556-2x.png"></a></em> RabbitMQ<br><br><a href="https://postimg.cc/yggHrZ8j" target="_blank" rel="noopener"><img src="https://i.postimg.cc/KzQ8j7X6/WX20190515-221940-2x.png" alt="WX20190515-221940-2x.png"></a><br><br><br><br><br><br><br><br><h3>14.高并发解决思路之应用拆分</h3><br><a href="https://postimg.cc/GB5Msxn0" target="_blank" rel="noopener"><img src="https://i.postimg.cc/50xDTsPt/WX20190626-220947-2x.png" alt="WX20190626-220947-2x.png"></a><br><br><br><br><a href="https://postimg.cc/nM0L3NrH" target="_blank" rel="noopener"><img src="https://i.postimg.cc/qMdCvTdC/WX20190704-213601-2x.png" alt="WX20190704-213601-2x.png"></a><br><br><a href="https://postimg.cc/LJvv596c" target="_blank" rel="noopener"><img src="https://i.postimg.cc/yNCGfWq8/WX20190704-213815-2x.png" alt="WX20190704-213815-2x.png"></a><br><br><a href="https://postimg.cc/xJmKvnnT" target="_blank" rel="noopener"><img src="https://i.postimg.cc/gJSNP27R/WX20190704-213920-2x.png" alt="WX20190704-213920-2x.png"></a><br><br><br><br><a href="https://postimg.cc/c62JqwRj" target="_blank" rel="noopener"><img src="https://i.postimg.cc/pXX5FBp2/WX20190704-213959-2x.png" alt="WX20190704-213959-2x.png"></a><br><br><a href="https://postimg.cc/yDJ5M3Tf" target="_blank" rel="noopener"><img src="https://i.postimg.cc/GmzCskT1/WX20190704-214449-2x.png" alt="WX20190704-214449-2x.png"></a><br><br><a href="https://postimg.cc/CRfPPTFX" target="_blank" rel="noopener"><img src="https://i.postimg.cc/T3tzPfBd/WX20190704-214535-2x.png" alt="WX20190704-214535-2x.png"></a><br><br><h3>15.高并发之应用限流思路</h3><p><a href="https://postimg.cc/k2FXL5vt" target="_blank" rel="noopener"><img src="https://i.postimg.cc/sgbQQQBK/WX20190704-221013-2x.png" alt="WX20190704-221013-2x.png"></a></p><p><a href="https://postimg.cc/HrJgHkmL" target="_blank" rel="noopener"><img src="https://i.postimg.cc/13B5G8YD/WX20190704-221221-2x.png" alt="WX20190704-221221-2x.png"></a></p><p><a href="https://postimg.cc/HrB1Q8t3" target="_blank" rel="noopener"><img src="https://i.postimg.cc/KYychn3X/WX20190704-222107-2x.png" alt="WX20190704-222107-2x.png"></a></p><p><a href="https://postimg.cc/S2z0FTbt" target="_blank" rel="noopener"><img src="https://i.postimg.cc/wvw9NZfH/WX20190704-222138-2x.png" alt="WX20190704-222138-2x.png"></a></p><p><a href="https://postimg.cc/Z9BsCWsW" target="_blank" rel="noopener"><img src="https://i.postimg.cc/JhKfYJb5/WX20190704-222258-2x.png" alt="WX20190704-222258-2x.png"></a></p><p><a href="https://postimg.cc/bdDnWQDD" target="_blank" rel="noopener"><img src="https://i.postimg.cc/QNSqBmjb/WX20190704-222545-2x.png" alt="WX20190704-222545-2x.png"></a></p><p></p><h3>16.高并发之服务降级与服务熔断思路</h3><br><img src="https://i.postimg.cc/J0hYqZdq/WX20190707-205833-2x.png" alt><p></p><p><a href="https://postimg.cc/JD4GgdQb" target="_blank" rel="noopener"><img src="https://i.postimg.cc/tTFWsKZm/WX20190707-210322-2x.png" alt="WX20190707-210322-2x.png"></a></p><p><a href="https://postimg.cc/dLv8V9vp" target="_blank" rel="noopener"><img src="https://i.postimg.cc/kXRwwjHJ/WX20190707-213457-2x.png" alt="WX20190707-213457-2x.png"></a></p><p><a href="https://postimg.cc/2bRxFNR8" target="_blank" rel="noopener"><img src="https://i.postimg.cc/d1DSFJ5d/WX20190707-213551-2x.png" alt="WX20190707-213551-2x.png"></a></p><p><a href="https://postimg.cc/hJFmN8C2" target="_blank" rel="noopener"><img src="https://i.postimg.cc/vmTvg35w/WX20190707-213654-2x.png" alt="WX20190707-213654-2x.png"></a></p><p></p><h3>17.高并发之数据库切库分库分表思路</h3><br><a href="https://postimg.cc/mh0mNnMn" target="_blank" rel="noopener"><img src="https://i.postimg.cc/3Jwz75w3/WX20190707-222739-2x.png" alt="WX20190707-222739-2x.png"></a><p></p><p><a href="https://postimg.cc/3WCZmw8k" target="_blank" rel="noopener"><img src="https://i.postimg.cc/pV31N93J/WX20190707-222913-2x.png" alt="WX20190707-222913-2x.png"></a></p><p><a href="https://postimg.cc/TyVKFpHm" target="_blank" rel="noopener"><img src="https://i.postimg.cc/s285BWYn/WX20190707-223004-2x.png" alt="WX20190707-223004-2x.png"></a></p><p><a href="https://postimg.cc/Hj4fnHF2" target="_blank" rel="noopener"><img src="https://i.postimg.cc/CMWYvxNW/WX20190707-223138-2x.png" alt="WX20190707-223138-2x.png"></a></p><p><a href="https://postimg.cc/5XNHT4Wk" target="_blank" rel="noopener"><img src="https://i.postimg.cc/htV9Jvyg/WX20190707-223929-2x.png" alt="WX20190707-223929-2x.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://996.icu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/link-996.icu-red.svg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIFY_6AA3VjT9w7FMAALGfwFCj8AADdWl862.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3&gt;4.线程安全性&lt;/h3&gt;&lt;br&gt;定义：当多个线程访问某个类时，不管运行时环境采用&lt;b&gt;何种调度方式&lt;/b&gt;或者这些进程将如何交替执行，并且在主调代码中&lt;b&gt;不需要任何额外的同步或协同&lt;/b&gt;，这个类都能表现出&lt;b&gt;正确的行为&lt;/b&gt;，那么就称这个类是线程安全的。&lt;br&gt;&lt;br&gt;&lt;em&gt; 原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。
&lt;/em&gt; 可见性：一个线程对主内存的修改可以及时的被其他线程观察到。&lt;br&gt;&lt;em&gt; 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="高并发" scheme="http://yoursite.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下shadowsocks 配合SwitchyOmega科学上网</title>
    <link href="http://yoursite.com/2017/11/03/Ubuntu%E4%B8%8B%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://yoursite.com/2017/11/03/Ubuntu下科学上网/</id>
    <published>2017-11-02T16:00:00.000Z</published>
    <updated>2020-03-25T11:30:46.264Z</updated>
    
    <content type="html"><![CDATA[<p>最近重新装起了阔别已久的ubuntu，第一件事当然是科学上网啊。大概需要下面几步</p><h3 id="1-一个代理服务账号"><a href="#1-一个代理服务账号" class="headerlink" title="1.一个代理服务账号"></a>1.一个代理服务账号</h3><p>&nbsp;&nbsp;这里我推荐 <a href="https://jikess.org/" target="_blank" rel="noopener">jikess</a>，一个月只需要12大洋，200G代理流量，速度也很客观。自行注册购买，或者也可以先领几十M先体验下。</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/02/08/ChMkJlbKzWGIZIhdAAQNZj09ufQAALJAQMP9cYABA1-499.jpg" alt></p><a id="more"></a><h3 id="2-ubuntu使用shadowsocks"><a href="#2-ubuntu使用shadowsocks" class="headerlink" title="2. ubuntu使用shadowsocks"></a>2. ubuntu使用shadowsocks</h3><p> <b>1.安装shadowsocks命令行程序，配置命令。</b></p><p> 2.安装shadowsocks GUI图形界面程序，配置。<br></p><h4 id="第一种安装shadowsocks命令行程序"><a href="#第一种安装shadowsocks命令行程序" class="headerlink" title="第一种安装shadowsocks命令行程序"></a>第一种安装shadowsocks命令行程序</h4><p>用PIP安装很简单</p><pre><code>sudo apt-get updatesudo apt-get install python-pipsudo apt-get install python-setuptools m2crypto</code></pre><p>接着安装shadowsocks</p><pre><code>pip install shadowsocks</code></pre><p>如果是ubuntu16.04 直接 (16.04 里可以直接用apt 而不用 apt-get 这是一项改进）</p><pre><code>sudo apt install shadowsocks</code></pre><p>当然你在安装时候肯定有提示需要安装一些依赖比如<code>python-setuptools m2crypto</code> ，依照提示安装然后再安装就好。也可以网上搜索有很多教程的。</p><h4>启动shadowsocks</h4><p>安装好后，在本地我们要用到sslocal ，终端输入sslocal –help 可以查看帮助，像这样</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-04%2017-03-17%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>通过帮助提示我们知道各个参数怎么配置，比如 sslocal -c 后面加上我们的json配置文件，或者像下面这样直接命令参数写上运行。</p><p>比如</p><pre><code>sslocal -s 11.22.33.44 -p 50003 -k &quot;123456&quot; -l 1080 -t 600 -m aes-256-cfb</code></pre><p> -s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加””）, -t超时默认300,-m是加密方法默认<code>aes-256-cfb</code>，</p><p> <b>为了方便我推荐直接用sslcoal -c 配置文件路径 这样的方式，简单好用。</b></p><p>我们可以在/home/{user}/ 下新建个文件shadowsocks.json  ({user}是你自己电脑上的用户名)。内容是这样：</p><pre><code>{    &quot;server&quot;:&quot;11.22.33.44&quot;,    &quot;server_port&quot;:50003,    &quot;local_port&quot;:1080,    &quot;password&quot;:&quot;123456&quot;,    &quot;timeout&quot;:600,    &quot;method&quot;:&quot;aes-256-cfb&quot;}</code></pre><p>server  你服务端的IP<br>servier_port  你服务端的端口<br>local_port  本地端口，一般默认1080<br>passwd  ss服务端设置的密码<br>timeout  超时设置 和服务端一样<br>method  加密方法 和服务端一样</p><p>确定上面的配置文件没有问题，然后我们就可以在终端输入 <code>sslocal -c /home/{user}/shadowsocks.json</code> 回车运行。如果没有问题的话，下面会是这样…</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-04%2017-11-06%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h4 id="第二种-安装图形界面"><a href="#第二种-安装图形界面" class="headerlink" title="第二种 安装图形界面"></a>第二种 安装图形界面</h4><p><b>在 Ubuntu下 通过PPA源安装，仅支持Ubuntu 14.04或更高版本。</b></p><pre><code>sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5</code></pre><p>由于是图形界面，配置和windows基本没啥差别就不赘述了。</p><p>经过上面两种方式的配置，你只是启动了sslocal 但是要上网你还需要配置下浏览器到指定到代理端口比如1080才可以正式上网。你可以去系统的代理设置按照说明设置代理，但一般是全局的，然而我们访问baidu,taobao等着些网站如果用代理就有点绕了，而且还会浪费服务器流量。我们最好配置我们的浏览器让它可以自动切换，该用代理用代理该直接连接自动直接连接。所以请看配置浏览器。</p><h3 id="3-配置浏览器（chrome"><a href="#3-配置浏览器（chrome" class="headerlink" title="3.配置浏览器（chrome)"></a>3.配置浏览器（chrome)</h3><p>我们需要给chrome安装SwitchyOmega插件，但是没有代理之前是不能从谷歌商店安装这个插件的，但是我们可以从Github上直接下载最新版 <a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases/</a> （这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。</p><p><b>上面也是我之前一直用的方法，屡试不爽。但是这次不知道为啥在拖进chrome后始终没反应，无法离线安装。于是我决定先配置全局代理，这样chrome可以直接访问谷歌商店，然后再直接在线安装SwitchyOmega，实现代理自动切换的目的。</b></p><h4>先配置全局代理</h4><p>1、安装GenPAC<br>GenPAC 是基于gfwlist的代理自动配置（Proxy Auto-config）文件生成工具，支持自定义规则。在多数情况下，我们更希望使用PAC模式的代理，让我们访问国内网站时不再先绕地球跑一圈，在Windows和Mac上的shadowsocks客户端可以轻松切换到PAC模式，而在Ubuntu上我们需要使用pac文件来设置系统代理以达到相同的效果</p><pre><code>sudo pip install genpacpip install --upgrade genpac</code></pre><p>2、使用GenPAC生成pac文件</p><pre><code>genpac -p &quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output=&quot;autoproxy.pac&quot;</code></pre><p>3、设置全局代理</p><p>点击：System settings &gt; Network &gt; Network Proxy，选择 Method 为 Automatic，设置 Configuration URL 为 autoproxy.pac 文件的路径，点击 Apply System Wide。<br>格式如：<code>file:///home/{user}/autoproxy.pac</code></p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-28-09%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>4、安装switchyOmega<br>  此时应该可以按照一定过滤规则访问外网了，但仍配置下浏览器（毕竟善始善终）</p><p>  <img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-32-26%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h4> 配置switchyOmega</h4><p>1.配置代理地址</p><p>安装好插件会自动跳到设置选项，有提示你可以跳过。左边新建情景模式-选择代理服务器-比如命名为proxy（叫什么无所谓）其他默认之后创建，之后在代理协议选择SOCKS5，地址为127.0.0.1,端口默认1080 。然后保存即应用选项。</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-35-17%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>2.设置自动切换</p><p>接着点击自动切换 ( Auto switch）上面的不用管，在按照规则列表匹配请求后面选择刚才新建的proxy，默认情景模式选择直接连接。点击应用选项保存。再往下规则列表设置选择AutoProxy 然后将这个地址(<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>) 填进去，点击下面的立即更新情景模式，会有提示更新成功！</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-37-58%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p><b>点击浏览器右上角的SwitchyOmega图标，下面选择自动切换，然后打开google.com试试，其他的就不在这贴图了。</b></p><h4>至此shadowsocks搭建完成，天高任鸟飞，海阔任鱼跃。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近重新装起了阔别已久的ubuntu，第一件事当然是科学上网啊。大概需要下面几步&lt;/p&gt;
&lt;h3 id=&quot;1-一个代理服务账号&quot;&gt;&lt;a href=&quot;#1-一个代理服务账号&quot; class=&quot;headerlink&quot; title=&quot;1.一个代理服务账号&quot;&gt;&lt;/a&gt;1.一个代理服务账号&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;这里我推荐 &lt;a href=&quot;https://jikess.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jikess&lt;/a&gt;，一个月只需要12大洋，200G代理流量，速度也很客观。自行注册购买，或者也可以先领几十M先体验下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/02/08/ChMkJlbKzWGIZIhdAAQNZj09ufQAALJAQMP9cYABA1-499.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ShadowSocks" scheme="http://yoursite.com/tags/ShadowSocks/"/>
    
  </entry>
  
  <entry>
    <title>SSH整合过程中的问题</title>
    <link href="http://yoursite.com/2017/01/13/SSH%E6%95%B4%E5%90%88%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/01/13/SSH整合出现的一些异常/</id>
    <published>2017-01-12T16:00:00.000Z</published>
    <updated>2020-03-25T11:30:46.262Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="首先介绍下博主的工作环境"><a href="#首先介绍下博主的工作环境" class="headerlink" title="首先介绍下博主的工作环境"></a>首先介绍下博主的工作环境</h2><p><strong></strong></p><ul><li>系统：<code>Ubuntu 16.04 LTS</code></li><li>IDE: <code>Myeclispe 2015</code></li><li>Server: <code>Myeclipse2015</code>自带的<code>Myeclipse Tomcat v7.0</code></li><li>框架版本: <code>Struts 2.1</code>  <code>Spring 4.1</code> <code>Hibernate 4.1.4</code></li></ul><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g2/M00/01/0E/Cg-4WlU4niOIChfEAAtm0dNCMiIAACHugPmzzsAC2bp782.jpg" alt></p><a id="more"></a><h2 id="先介绍下-SSH-经典架构（大神请跳过"><a href="#先介绍下-SSH-经典架构（大神请跳过" class="headerlink" title="先介绍下 SSH 经典架构（大神请跳过)"></a>先介绍下 <code>SSH</code> 经典架构（大神请跳过)</h2><p>首先，SSH不是一个框架，而是多个框架（struts+spring+hibernate）的集成，是目前较流行的一种Web应用程序开源集成框架，用于构建灵活、易于扩展的多层Web应用程序。</p><p>集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层（实体层）。</p><p>Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，控制业务跳转，利用Hibernate框架对持久层提供支持。Spring一方面作为一个轻量级的IoC容器，负责查找、定位、创建和管理对象及对象之间的依赖关系，另一方面能使Struts和Hibernate更好地工作。</p><h2 id="以下是最近做项目时遇到的一些问题"><a href="#以下是最近做项目时遇到的一些问题" class="headerlink" title="以下是最近做项目时遇到的一些问题"></a>以下是最近做项目时遇到的一些问题</h2><h3 id="1-Struts2自带的antlr-2-7-2-jar与Hibernate4-1-4自带的antlr-2-7-7-jar发生冲突"><a href="#1-Struts2自带的antlr-2-7-2-jar与Hibernate4-1-4自带的antlr-2-7-7-jar发生冲突" class="headerlink" title="1.Struts2自带的antlr-2.7.2.jar与Hibernate4.1.4自带的antlr-2.7.7.jar发生冲突"></a>1.Struts2自带的<code>antlr-2.7.2.jar</code>与Hibernate4.1.4自带的<code>antlr-2.7.7.jar</code>发生冲突</h3><p>  <strong> 报错内容如下: </strong></p><pre><code>java.lang.NoSuchMethodError: antlr.collections.AST.getLine()I</code></pre><h3 id="这是一个ssh整合的经典bug-解决方案是"><a href="#这是一个ssh整合的经典bug-解决方案是" class="headerlink" title="这是一个ssh整合的经典bug ,解决方案是:"></a>这是一个ssh整合的经典bug ,解决方案是:</h3><p>  <strong> 在Myeclipse2015中打开<code>window -&gt; perference -&gt; project libraries</code>在里面找到<code>struts2.1 Libraries-&gt; core-&gt;  antlr-2.7.2.jar</code> 点击取消勾选这个jar包， 然后点击Apply ，最后重新部署下工程就ok了</strong></p><h3 id="2-Spring事务管理出错"><a href="#2-Spring事务管理出错" class="headerlink" title="2.Spring事务管理出错"></a>2.Spring事务管理出错</h3><p>   <strong> 报错内容如下: </strong></p><pre><code>Write operations are not allowed in read-only mode (FlushMode.MANUAL): Turn your Session into FlushMode.COMMIT/AUTO or remove &apos;readOnly&apos; markerfrom transaction definition.</code></pre><p><strong> 大意是：只读模式下(FlushMode.NEVER/MANUAL)写操作不被允许：把你的Session改成FlushMode.COMMIT/AUTO或者清除事务定义中的readOnly标记。</strong></p><h3 id="解决方案是-配置Spring的事务管理"><a href="#解决方案是-配置Spring的事务管理" class="headerlink" title="解决方案是:配置Spring的事务管理"></a>解决方案是:配置Spring的事务管理</h3><p>  在applicationContext.xml中加入</p><pre><code>&lt;tx:advice id=&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;&lt;tx:attributes&gt;  &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;modify*&quot; propagation=&quot;REQUIRED&quot;    rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt;&lt;aop:pointcut id=&quot;daoMethod&quot; expression=&quot;execution(* com.muke.employee.daoImpl.*.*(..))&quot; /&gt;&lt;aop:advisor pointcut-ref=&quot;daoMethod&quot; advice-ref=&quot;txadvice&quot; /&gt;&lt;/aop:config&gt;</code></pre><ul><li><code>expression=&quot;execution( com.dao..(..))&quot;</code>其中第一个<em>代表返回值，第二代表daoImpl下子包，第三个代表方法名，“（..）”代表方法参数。</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;首先介绍下博主的工作环境&quot;&gt;&lt;a href=&quot;#首先介绍下博主的工作环境&quot; class=&quot;headerlink&quot; title=&quot;首先介绍下博主的工作环境&quot;&gt;&lt;/a&gt;首先介绍下博主的工作环境&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统：&lt;code&gt;Ubuntu 16.04 LTS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;IDE: &lt;code&gt;Myeclispe 2015&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Server: &lt;code&gt;Myeclipse2015&lt;/code&gt;自带的&lt;code&gt;Myeclipse Tomcat v7.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;框架版本: &lt;code&gt;Struts 2.1&lt;/code&gt;  &lt;code&gt;Spring 4.1&lt;/code&gt; &lt;code&gt;Hibernate 4.1.4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g2/M00/01/0E/Cg-4WlU4niOIChfEAAtm0dNCMiIAACHugPmzzsAC2bp782.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="http://yoursite.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架整合</title>
    <link href="http://yoursite.com/2017/01/10/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
    <id>http://yoursite.com/2017/01/10/SSM框架整合/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2020-03-25T11:30:46.263Z</updated>
    
    <content type="html"><![CDATA[<hr><b>这里的SSM指的是（<code>Spring-Springmvc-Mybatis</code>)三大框架</b><h4>前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;我们看招聘信息的时候，经常会看到这一点，需要具备<code>SSH</code>(<code>Struts-Spring-Hibernate</code>)框架的技能；而且在大部分教学课堂中，也会把<code>SSH</code>作为最核心的教学内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;但是，我们在实际应用中发现，<code>SpringMVC</code>可以完全替代<code>Struts</code>，配合注解的方式，编程非常快捷，而且通过restful风格定义url，让地址看起来非常优雅。<br>&nbsp;&nbsp;&nbsp;&nbsp;另外，<code>MyBatis</code>也可以替换<code>hibernate</code>，正因为<code>MyBatis</code>的半自动特点，我们程序猿可以完全掌控SQL，这会让有数据库经验的程序猿能开发出高效率的SQL语句，而且XML配置管理起来也非常方便。<br>&nbsp;&nbsp;&nbsp;&nbsp;下面我们开始进行SSM框架的整合。</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIJK4PAAfFWxl1L9IAALJAQM0wFQAB8Vz309.jpg" alt></p><a id="more"></a><p></p><h4>介绍</h4><br>在整合之前先介绍一下这三个框架，之前有了解的可以跳过.这里尽量通俗易懂的简单讲解一下。<p></p><ul><li><p>Springmvc<br>  &nbsp;&nbsp;&nbsp;&nbsp;它用于web层，相当于controller（等价于传统的servlet和struts的action），用来处理用户请求。举个例子，用户在地址栏输入<a href="http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法，（中间可能包含验证用户名和密码的业务逻辑，以及查询数据库操作，但这些都不是springmvc的职责），最终把结果返回给用户，并且返回相应的页面（当然也可以只反馈josn/xml等格式数据）。springmvc就是做前面和后面过程的活，与用户打交道！！" target="_blank" rel="noopener">http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法，（中间可能包含验证用户名和密码的业务逻辑，以及查询数据库操作，但这些都不是springmvc的职责），最终把结果返回给用户，并且返回相应的页面（当然也可以只反馈josn/xml等格式数据）。springmvc就是做前面和后面过程的活，与用户打交道！！</a></p></li><li><p>Spring<br>&nbsp;&nbsp;&nbsp;&nbsp; 太强大了，以至于我无法用一个词或一句话来概括它。但与我们平时开发接触最多的估计就是IOC容器，它可以装载bean（也就是我们Java中的类，当然也包括service dao里面的），有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。</p></li></ul><ul><li>Mybatis<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你问我它跟鼎鼎大名的Hibernate有什么区别？我只想说，他更符合我的需求。第一，它能自由控制sql，这会让有数据库经验的人编写的代码能搞提升数据库访问的效率。第二，它可以使用xml的方式来组织管理我们的sql，因为一般程序出错很多情况下是sql出错，别人接手代码后能快速找到出错地方，甚至可以优化原来写的sql。</li></ul><p></p><h4>SSM框架整合配置</h4><br>&nbsp;&nbsp;&nbsp;&nbsp;首先在Myeclipse中建立一个<code>Maven Web</code>工程。(对这步有疑问的可以看我之前的博客<a href="http://blog.pockerface.cn/2016/10/20/使用项目管理利器Maven/" target="_blank" rel="noopener">使用项目管理工具 <code>Maven</code></a>)<br>这是相应的项目目录<p></p><center><br><img src="http://7xta11.com1.z0.glb.clouddn.com/SSM.png" alt><br></center><br><strong>这里介绍下Maven目录规范下各目录的作用</strong><br><del>====</del><br><br>| 文件名           | 作用          |<br>| ————- |:————-:|<br>|src           |根目录，没什么好说的，下面有main和test |<br>|main    |主要目录，可以放java代码和一些资源文件|<br>|java    |存放我们的java代码 |<br>|resources    | 存放资源文件，譬如各种的spring，mybatis，log配置文件|<br>mapper    |存放dao中每个方法对应的sql，在这里配置，无需写daoImpl|<br>|spring        |这里当然是存放spring相关的配置文件，有dao service web三层|<br>|test    |这里是测试分支|<br>|java    |测试java代码，应遵循包名相同的原则，这个文件夹同样要使用Build Path -&gt; Use as Source Folder，这样看包结构会方便很多|<br>|resources    |没什么好说的，好像也很少用到，但这个是maven的规范|<br>webapp    |用来存放我们前端的静态资源，如jsp js css|<br>|resources    |这里的资源是指项目的静态资源，如js css images等|<br>|WEB-INF    |很重要的一个目录，外部浏览器无法访问，只有羡慕内部才能访问，可以把jsp放在这里，另外就是web.xml了。你可能有疑问了，为什么上面java中的resources里面的配置文件不妨在这里，那么是不是会被外部窃取到？你想太多了，部署时候基本上只有webapp里的会直接输出到根目录，其他都会放入WEB-INF里面，项目内部依然可以使用classpath:XXX来访问，好像IDE里可以设置部署输出目录|<br><br><strong>讲解几个必要的包，顺便讲解一下每个包的作用.</strong><br><center><br><img src="http://7xta11.com1.z0.glb.clouddn.com/SSM2.png" alt><br></center><table><thead><tr><th>包名</th><th style="text-align:center">名称</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td>dao</td><td style="text-align:center">数据访问层（接口）</td><td style="text-align:right">与数据打交道，可以是数据库操作，也可以是文件读写操作，甚至是redis缓存操作，总之与数据操作有关的都放在这里，也有人叫做dal或者数据持久层都差不多意思。为什么没有daoImpl，因为我们用的是mybatis，所以可以直接在配置文件中实现接口的每个方法。</td></tr><tr><td>entity</td><td style="text-align:center">实体类</td><td style="text-align:right">一般与数据库的表相对应，封装dao层取出来的数据为一个对象，也就是我们常说的pojo，一般只在dao层与service层之间传输</td></tr><tr><td>dto</td><td style="text-align:center">数据传输层</td><td style="text-align:right">刚学框架的人可能不明白这个有什么用，其实就是用于service层与web层之间传输，为什么不直接用entity（pojo）？其实在实际开发中发现，很多时候一个entity并不能满足我们的业务需求，可能呈现给用户的信息十分之多，这时候就有了dto，也相当于vo，记住一定不要把这个混杂在entity里面</td></tr><tr><td>service</td><td style="text-align:center">业务逻辑（接口）</td><td style="text-align:right">写我们的业务逻辑，也有人叫bll，在设计业务接口时候应该站在“使用者”的角度</td></tr><tr><td>impl</td><td style="text-align:center">业务逻辑（实现）</td><td style="text-align:right">实现我们业务接口，一般事务控制是写在这里</td></tr><tr><td>web</td><td style="text-align:center">控制器</td><td style="text-align:right">springmvc就是在这里发挥作用的，一般人叫做controller控制器，相当于struts中的action</td></tr></tbody></table><p><strong>添加依赖</strong><br>    SSM整合需要导入相应的jar包,我们使用maven来管理我们的jar，所以只需要在<code>pom.xml</code>中加入相应的依赖。如果没有使用maven的话,可以自己去官网下载相应的jar包，然后放到项目的WEB-INF/lib目录下.</p><p><b>三个主要框架版本</b></p><ul><li><code>Spring---4.3.3.RELEASE</code><ul><li><code>spring mvc ---- 4.3.3.RELEASE</code></li><li><code>mybatis ---- 3.2.5</code></li></ul></li></ul><p><b>其他</b></p><ul><li><p><code>junit ---- 4.8.1</code></p></li><li><p><code>MySQL ---- 5.1.38</code></p></li><li><p><code>log4j ---- 1.2.17</code></p></li><li><p><code>c3p0 ---- 0.9.2.1</code></p></li><li><p><code>mybatis-spring ---- 1.3.0</code>  </p></li><li><p><code>jstl ---- 1.2</code></p></li></ul><p><b>pom.xml文件如下</b></p><pre><code>  &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.fendo.ssm&lt;/groupId&gt;    &lt;artifactId&gt;fendo-SSM&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;fendo-SSM Maven Webapp&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;      &lt;!-- 初始化框架的版本号 --&gt;      &lt;properties&gt;          &lt;spring.version&gt;4.3.3.RELEASE&lt;/spring.version&gt;      &lt;/properties&gt;    &lt;dependencies&gt;      &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;3.8.1&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;      &lt;/dependency&gt;           &lt;!-- 加入ServletAPI --&gt;          &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;          &lt;dependency&gt;              &lt;groupId&gt;javax.servlet&lt;/groupId&gt;              &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;              &lt;version&gt;2.3&lt;/version&gt;              &lt;scope&gt;provided&lt;/scope&gt;          &lt;/dependency&gt;          &lt;!-- MySQL依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;mysql&lt;/groupId&gt;              &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;              &lt;version&gt;5.1.38&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- MySQL依赖 end --&gt;          &lt;!-- 加入MyBatis 依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.mybatis&lt;/groupId&gt;              &lt;artifactId&gt;mybatis&lt;/artifactId&gt;              &lt;version&gt;3.2.5&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 加入MyBatis 依赖 end --&gt;          &lt;!-- Log4j start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;log4j&lt;/groupId&gt;              &lt;artifactId&gt;log4j&lt;/artifactId&gt;              &lt;version&gt;1.2.17&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- Log4j end --&gt;             &lt;!-- 引入Spring(包含SpringMVC) 依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-core&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-web&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-test&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 引入Spring 依赖 end --&gt;          &lt;!-- 引用c3p0 依赖 start--&gt;          &lt;dependency&gt;              &lt;groupId&gt;com.mchange&lt;/groupId&gt;              &lt;artifactId&gt;c3p0&lt;/artifactId&gt;              &lt;version&gt;0.9.2.1&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 引用c3p0 依赖 end--&gt;          &lt;!-- 引用插件依赖：MyBatis整合Spring --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.mybatis&lt;/groupId&gt;              &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;              &lt;version&gt;1.3.0&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- JSTL --&gt;          &lt;dependency&gt;              &lt;groupId&gt;jstl&lt;/groupId&gt;              &lt;artifactId&gt;jstl&lt;/artifactId&gt;              &lt;version&gt;1.2&lt;/version&gt;          &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;      &lt;finalName&gt;fendo-SSM&lt;/finalName&gt;      &lt;plugins&gt;        &lt;!-- 加入Tomcat插件 --&gt;          &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;                  &lt;configuration&gt;                       &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt;                      &lt;username&gt;admin&lt;/username&gt;                        &lt;password&gt;admin&lt;/password&gt;                  &lt;/configuration&gt;           &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/build&gt;  &lt;/project&gt;</code></pre><p>   </p><h4>编码配置文件</h4><br>      <b>第一步：</b>我们先在spring文件夹里新建<code>spring-dao.xml</code>文件，因为spring的配置太多，我们这里分三层，分别是dao, service , web.<p></p><ol><li>读入数据库连接相关参数（可选）</li><li><p>配置数据连接池</p><ol><li>配置连接属性，可以不读配置项文件直接在这里写死</li><li>配置c3p0，只配了几个常用的</li></ol></li><li><p>配置SqlSessionFactory对象（mybatis）</p></li><li><p>扫描dao层接口，动态实现dao接口，也就是说不需要daoImpl，sql和参数都写在xml文件上</p><p><b>spring-dao.xml</b></p></li></ol><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     &quot;&gt;     &lt;context:annotation-config /&gt;    &lt;!-- 配置整合MyBatis过程 --&gt;    &lt;!-- 1.配置数据库相关参数properties的属性:${url} --&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;    &lt;!--2.数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!-- 配置连接池属性 --&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;        &lt;!-- c3p0私有属性 --&gt;        &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;&gt;&lt;/property&gt;        &lt;!-- 关闭连接后不自动commit --&gt;        &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;&gt;&lt;/property&gt;        &lt;!-- 获取连接超时时间 --&gt;        &lt;property name=&quot;checkoutTimeout&quot; value=&quot;1000&quot;&gt;&lt;/property&gt;        &lt;!-- 当获取连接失败重试次数 --&gt;        &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 3.配置sqlSessionFactory对象 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 注入数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;        &lt;!-- 配置MyBatis全局配置文件:myBatis-config.xml --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;        &lt;!-- 扫描entity包，使用别名 --&gt;        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;org.seckill.entity&quot;&gt;&lt;/property&gt;        &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!-- 注入sqlSessionFactory --&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;        &lt;!-- 给出需要扫描的Dao接口包 --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.blog.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>&nbsp;&nbsp;因为数据库配置相关参数是读取配置文件，所以在resources文件夹里新建一个jdbc.properties文件，存放我们4个最常见的数据库连接属性，这是我本地的，大家记得修改.如果大家上传github时记得删掉密码，不然别人就很容易得到你服务器的数据库配置信息.    </p><p><b>jdbc.properties</b></p><pre><code>jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://127.0.0.1\:3306/personBlogjdbc.username=rootjdbc.password=</code></pre><p><b>友情提示：</b>配置文件中的jdbc.username，如果写成username，可能会与系统环境中的username变量冲突，所以到时候真正连接数据库的时候，用户名就被替换成系统中的用户名（有得可能是administrator），那肯定是连接不成功的，这里有个小坑,需要大家注意.</p><p>这里用到了mybatis,所以接下来需要配置mybatis核心文件,在<code>resources</code>文件夹下新建<code>mybatis-config.xml</code>文件</p> <li>  使用自增主键</li><br><li> 使用列别名</li><br> <li>   开启驼峰命名转换 create_time -&gt; createTime</li><p><b>mybatis-config.xml</b></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 配置全局属性 --&gt;    &lt;settings&gt;        &lt;!-- 使用jdbc的getGenerateKeys获取数据库自增主键 --&gt;        &lt;setting name=&quot;useGererateKeys&quot; value=&quot;true&quot; /&gt;        &lt;!-- 使用列别名替换列名 默认：true --&gt;        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt;        &lt;!-- 开启驼峰命名转换 --&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt;    &lt;/settings&gt;&lt;/configuration&gt;</code></pre><p><b>第二步:</b>刚弄好dao层，接下来到service层了。在spring文件夹里新建<code>spring-service.xml</code>文件。    </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;                 xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans             http://    www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     &quot;&gt;    &lt;!-- 扫描service包下所有使用注解的类型 --&gt;    &lt;context:component-scan base-package=&quot;com.blog.service&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 注入事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot;        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!-- 注入数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置基于注解的声明式事务 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt;</code></pre><p><b>第三步:</b>配置web层，在spring文件夹里新建spring-web.xml文件.</p><ol><li><p>开启SpringMVC注解模式，可以使用@RequestMapping，@PathVariable，@ResponseBody等</p><ol><li>对静态资源处理，如js，css，jpg等</li><li>配置jsp 显示ViewResolver，例如在controller中某个方法返回一个string类型的 “login”，实际上会返回”/WEB-INF/login.jsp”</li><li>扫描web层 @Controller</li></ol><p><b>spring-web.xml</b></p></li></ol><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     http://www.springframework.org/schema/mvc     http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd     &quot;&gt;    &lt;!-- 配置springMVC --&gt;    &lt;!-- 1:开启springMVC注解模式 --&gt;    &lt;!-- 简化配置： （1）自动注册DefaultAnnotationHandlerMapping,AnnotationMethodHandlerAdapter         (2)提供一系列：数据绑定，数字和日期的format @NumberFormat ,@DataTimeFormat ,xml ,json默认读写支持 --&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!-- 2.静态资源默认servlet配置        1：允许加入对静态资源的处理：js,gif,png        2:允许使用&quot;/&quot;做整体映射     --&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!--3：配置jsp 显示ViewResolver--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 4:扫描web相关的bean --&gt;    &lt;context:component-scan base-package=&quot;org.seckill.web&quot;/&gt;&lt;/beans&gt;</code></pre><p>  <b>第四步:</b>最后就是修改web.xml文件了，它在webapp的<code>WEB-INF</code>下。<br><b>web.xml</b></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;&lt;!-- maven命令创建的servlet版本较低，默认没有打开JSTL，所以更改servlet版本为3.0 --&gt;  &lt;!-- 配置DispatcherServlet --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;blog-dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- 配置springMVC需要加载的配置文件            spring-dao.xml ,spring-service.xml ,spring-web.xml            Mybatis -&gt;spring -&gt;springMVC         --&gt;         &lt;init-param&gt;             &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;             &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;         &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;blog-dispatcher&lt;/servlet-name&gt;        &lt;!-- 默认匹配所有请求 --&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>我们在项目中经常会使用到日志，所以这里还有配置日志xml，在<code>resources</code>文件夹里新建<code>logback.xml</code>文件，所给出的日志输出格式也是最基本的控制台呼出，大家有兴趣查看<code>logback官方文档</code>。</p><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;configuration debug=&quot;true&quot;&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!-- encoders are by default assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n            &lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=&quot;debug&quot;&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;&lt;/configuration&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;b&gt;这里的SSM指的是（&lt;code&gt;Spring-Springmvc-Mybatis&lt;/code&gt;)三大框架&lt;/b&gt;

&lt;h4&gt;前言&lt;/h4&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们看招聘信息的时候，经常会看到这一点，需要具备&lt;code&gt;SSH&lt;/code&gt;(&lt;code&gt;Struts-Spring-Hibernate&lt;/code&gt;)框架的技能；而且在大部分教学课堂中，也会把&lt;code&gt;SSH&lt;/code&gt;作为最核心的教学内容。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;但是，我们在实际应用中发现，&lt;code&gt;SpringMVC&lt;/code&gt;可以完全替代&lt;code&gt;Struts&lt;/code&gt;，配合注解的方式，编程非常快捷，而且通过restful风格定义url，让地址看起来非常优雅。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;另外，&lt;code&gt;MyBatis&lt;/code&gt;也可以替换&lt;code&gt;hibernate&lt;/code&gt;，正因为&lt;code&gt;MyBatis&lt;/code&gt;的半自动特点，我们程序猿可以完全掌控SQL，这会让有数据库经验的程序猿能开发出高效率的SQL语句，而且XML配置管理起来也非常方便。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下面我们开始进行SSM框架的整合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIJK4PAAfFWxl1L9IAALJAQM0wFQAB8Vz309.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb三大框架之Hibernate初识</title>
    <link href="http://yoursite.com/2017/01/01/JavaWeb%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8BHibernate%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2017/01/01/JavaWeb三大框架之Hibernate初识/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2020-03-25T11:30:46.259Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>ORM</strong><br>    <code>ORM (Object / Relationship Mapping)</code> : 对象/关系映射<br>    </p><p>它的好处是使让习惯于面向对象编程的开发人员少写于底层数据库有关的<code>sql</code>语句，方便了程序的维护与修改，及跨平台性。</p><p></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/0A/ChMkJ1bKzzSIOgDcAAj_4khgui4AALJSwDm3zIACP_6935.jpg" alt></p><a id="more"></a><hr><p><strong>Hibernate</strong><br>    <code>Hibernate</code>就是<code>Java</code>中一种成熟的基于<code>ORM</code>的框架</p><hr><p><strong>Hibernate开发的基本步骤</strong></p><ol><li>编写配置文档 <code>hibernate.cfg.xml</code></li><li>编写实体类 (需要遵循<code>JavaBean</code>的设计规范)</li><li>生成对应实体类的映射文件（如 <code>Student</code>类的映射文件<code>Student.hbm.xml</code>)并添加到配置文档<code>hibernate.cfg.xml</code>中 </li><li>调用<code>Hibernate API</code>进行测试</li></ol><hr><p><strong>Session</strong></p><p><code>Hibernate</code>对数据库的操作都需要使用到<code>Session</code>对象，就类似于<code>JDBC</code>开发中的<code>Connection</code>对象。本质上讲<code>Hibernate</code>操作数据库，就是通过调用<code>Session</code>对象的各种函数实现的。</p><p>单表操作的常用方法：<code>save . delete .  update .  get / load</code>对应相应的<code>增删查改</code></p><p>其中查询方法<code>get</code>与<code>load</code>的主要区别在于：<code>get</code>在使用的时候立即发送<code>sql</code>语句，且获得的就是实体类的对象类型。而<code>load</code>是在使用到对象的非主键属性时才会发送sql语句，且它返回的是一个代理对象.</p><pre><code>Writren on 6.April.2016 Rainday</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;ORM&lt;/strong&gt;&lt;br&gt;    &lt;code&gt;ORM (Object / Relationship Mapping)&lt;/code&gt; : 对象/关系映射&lt;br&gt;    &lt;/p&gt;&lt;p&gt;它的好处是使让习惯于面向对象编程的开发人员少写于底层数据库有关的&lt;code&gt;sql&lt;/code&gt;语句，方便了程序的维护与修改，及跨平台性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/0A/ChMkJ1bKzzSIOgDcAAj_4khgui4AALJSwDm3zIACP_6935.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate" scheme="http://yoursite.com/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 笔记</title>
    <link href="http://yoursite.com/2016/12/20/Mysql%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/12/20/Mysql笔记/</id>
    <published>2016-12-20T11:59:53.000Z</published>
    <updated>2020-03-25T11:30:46.262Z</updated>
    
    <content type="html"><![CDATA[<h4>外键(foreign key)</h4><p>定义:如果一个实体的某个字段指向另一个实体的主键,这个字段就是这个实体的外键.</p><p>&nbsp;&nbsp;被指向的实体，称之为主实体(主表),也叫父实体(父表).<br>&nbsp;&nbsp;负责指向的实体，称之为从实体(从表),也叫子实体(子表).</p><center><br><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIGD1xAAlbi8UmgHEAALJAQMblhoACVuj729.jpg" alt><br></center> <a id="more"></a><h4>一 : 外键约束</h4><p> MySQL通过外键约束来保证表与表之间的数据的<code>完整性</code>和<code>准确性</code>。</p> <h4>外键使用条件</h4><ul><li><p>两个表必须是InnoDB表，MyISAM表暂时不支持外键（据说以后的版本有可能支持，但至少目前不支持）</p><ul><li><p>外键列必须建立了索引，MySQL 4.1.2以后的版本在建立外键时会自动创建索引，但如果在较早的版本则需要显示建立</p></li><li><p>外键关系的两个表的列必须是数据类型相似，也就是可以相互转换类型的列，比如int和tinyint可以，而int和char则不可以</p></li></ul><p>外键的好处 : 可以使得两张表关联，保证数据的一致性和实现一些级联操作.</p><h4>创建外键语法:</h4><p>  [CONSTRAINT [symbol]] FOREIGN KEY<br>[index_name] (index_col_name, …)<br>REFERENCES tbl_name (index_col_name,…)<br>[ON DELETE reference_option]<br>[ON UPDATE reference_option]</p></li></ul><p>例如:</p><pre><code>&lt;!--Blog表  子表--&gt;   CREATE TABLE `t_blog` (  `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &apos;博客类型&apos;,  `title` VARCHAR(200) NOT NULL COMMENT &apos;博客题目&apos;,  `summary` VARCHAR(400) DEFAULT NULL COMMENT &apos;博客摘要&apos;,  `releaseDate` DATETIME DEFAULT NULL COMMENT &apos;发布日期&apos;,  `clickHit` INT(11) DEFAULT NULL COMMENT &apos;评论次数&apos;,  `replyHit` INT(11) DEFAULT NULL COMMENT &apos;回复次数&apos;,  `content` TEXT COMMENT &apos;博客内容&apos;,  `keyWord` VARCHAR(200) DEFAULT NULL COMMENT &apos;关键字&apos;,  `type_id` INT(11) DEFAULT NULL COMMENT &apos;外键关联博客类别&apos;,  PRIMARY KEY (`id`),  KEY `type_id` (`type_id`),  CONSTRAINT `t_blog_ibfk_1` FOREIGN KEY (`type_id`) REFERENCES `t_blogtype` (`id`)   //创建外键) ENGINE=INNODB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8;&lt;!--BlogType表  父表--&gt;  CREATE TABLE `t_blogtype` (  `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &apos;博客id&apos;,  `typeName` VARCHAR(30) DEFAULT NULL COMMENT &apos;博客类别&apos;,  `orderNum` INT(11) DEFAULT NULL COMMENT &apos;博客排序&apos;,  PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;</code></pre><p><b>注意:</b></p><p>&nbsp;&nbsp;如果子表试图创建一个在父表中不存在的外键值，InnoDB会拒绝任何<code>INSERT</code>或<code>UPDATE</code>操作。如果父表试图<code>UPDATE</code>或者<code>DELETE</code>任何子表中存在或匹配的外键值，最终动作取决于外键约束定义中的<code>ON UPDATE</code>和<code>ON DELETE</code>选项。InnoDB支持5种不同的动作，如果没有指定<code>ON DELETE</code>或者<code>ON UPDATE</code>，默认的动作为<code>RESTRICT</code>:</p><ol><li><p><code>CASCADE</code>:从父表中删除或更新对应的行，同时自动的删除或更新子表中匹配的行。<code>ON DELETE CANSCADE</code>和<code>ON UPDATE CANSCADE</code>都被InnoDB所支持。</p><ol><li><p><code>SET NULL</code>: 从父表中删除或更新对应的行，同时将子表中的外键列设为空。注意，这些在外键列没有被设为NOT NULL时才有效。<code>ON DELETE SET NULL</code>和<code>ON UPDATE SET SET NULL</code>都被InnoDB所支持。</p></li><li><p><code>NO ACTION</code>: InnoDB拒绝删除或者更新父表。</p></li><li><p><code>RESTRICT</code>: 拒绝删除或者更新父表。指定RESTRICT（或者NO ACTION）和忽略<code>ON DELETE</code>或者<code>ON UPDATE</code>选项的效果是一样的。</p></li><li><p><code>SET DEFAULT</code>: InnoDB目前不支持。</p></li></ol><p><b>外键约束使用最多的两种情况：</b></p><ol><li>父表更新时子表也更新，父表删除时如果子表有匹配的项，删除失败.</li></ol></li><li><p>父表更新时子表也更新，父表删除时子表匹配的项也删除。</p><p>前一种情况，在外键定义中，我们使用<code>ON UPDATE CASCADE ON DELETE RESTRICT</code>；</p><p>后一种情况，可以使用<code>ON UPDATE CASCADE ON DELETE CASCADE</code>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;外键(foreign key)&lt;/h4&gt;

&lt;p&gt;定义:如果一个实体的某个字段指向另一个实体的主键,这个字段就是这个实体的外键.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;被指向的实体，称之为主实体(主表),也叫父实体(父表).&lt;br&gt;&amp;nbsp;&amp;nbsp;负责指向的实体，称之为从实体(从表),也叫子实体(子表).&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIGD1xAAlbi8UmgHEAALJAQMblhoACVuj729.jpg&quot; alt&gt;&lt;br&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat绑定域名发布应用</title>
    <link href="http://yoursite.com/2016/10/30/tomcat%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%E5%8F%8A%E5%8F%91%E5%B8%83%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/10/30/tomcat绑定域名及发布应用/</id>
    <published>2016-10-30T11:59:53.000Z</published>
    <updated>2020-03-25T11:30:46.264Z</updated>
    
    <content type="html"><![CDATA[<hr><p><b>我们使用<code>Tomcat</code>发布应用时，默认是绑定在<code>8080</code>端口，这种情况一般在测试后使用。如果应用需要部署到服务器上则需要修改端口为<code>80</code>，并通过域名直接访问。具体如何做呢？<br></b></p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/ChMkJ1cghZGIbfOAAARV4Pwpv4QAAQsDQJ9YssABFX4485.jpg" alt></p><h4 id="打包应用为war"><a href="#打包应用为war" class="headerlink" title="打包应用为war"></a>打包应用为war</h4><p><b>首先打包应用为.war文件，具体步骤为在<code>Myeclipse</code>中点击<code>File-&gt;Export</code>选择<code>web-&gt;war file</code>下一步之后选择要打包的应用，重命名为发布名称，比如<code>test.war</code>确定之后即打包。</b></p><a id="more"></a><p><b>我们把War包传到主机上去，放到Tomcat的webapps下，启动tomcat的startup.bat，会自动解压项目；到了这里，还不够。我们只能通过 <a href="http://外网IP:8080/项目名称访问；" target="_blank" rel="noopener">http://外网IP:8080/项目名称访问；</a> (<a href="http://外网IP:8080/项目名称访问；" target="_blank" rel="noopener">http://外网IP:8080/项目名称访问；</a>)</b></p><p><strong>我们现在要干两个事情，第一个是去掉端口，第二个是去掉项目名称。</strong></p><h4 id="配置容器"><a href="#配置容器" class="headerlink" title="配置容器"></a>配置容器</h4><h4>1.这里是在本地调试时的修改，真正部署可以跳过这段，看下个段落</h4><p>修改tomcat安装目录下的conf下的server.xml</p><blockquote><p>找到Connector节点，将其port改为80后保存，结果如下：</p></blockquote><pre><code>&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;        connectionTimeout=&quot;20000&quot;        redirectPort=&quot;8443&quot; /&gt;</code></pre><blockquote><p>绑定域名</p></blockquote><p>这里博主假设域名是<code>testphoto.com</code><em>(注意域名没有大小写之分，就算是大写也会被浏览器解析成小写)</em> 要绑定的项目时WebPhoto</p><p><b>1.首先因为是在本地访问该域名，所以需要修改Hosts文件，ubuntu系统下修改/<code>etc/hosts</code>加上一条记录</b></p><pre><code>127.0.0.1      testphoto.com</code></pre><p><b>2.之后修改server.xml文件</b></p><p>  找到 Engine节点,在里面添加一个 Host 节点，Engine其中有一个默认的<code>Hostname=&quot;localhost&quot;</code>的Host 节点，增添的Host节点:</p><pre><code>&lt;Host name=&quot;testphoto.com&quot;   appBase=&quot;webapps&quot;      unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;&lt;/Host&gt;</code></pre><p>此时在启动tomcat后，输入绑定的域名<code>testphoto.com</code>就可以看到tomcat了，但是要访问我们的项目，还是要在后面加上项目名称，<br>如<code>testphoto.com/WebPhoto</code></p><p><b>3.绑定项目到域名</b></p><p>  在第二步的基础上，在<host>节点中加入下面的配置</host></p><pre><code>&lt;Context path=&quot;/&quot; docBase=&quot;/opt/tomcat7/webapps/WebPhoto&quot;&gt;&lt;/Context&gt;</code></pre><p>  <code>docBase</code>是你的应用的绝对路径。</p><h4 id="此时通过testphoto-com就可以访问你的页面了"><a href="#此时通过testphoto-com就可以访问你的页面了" class="headerlink" title="此时通过testphoto.com就可以访问你的页面了"></a>此时通过<code>testphoto.com</code>就可以访问你的页面了</h4><p><img src="http://7xta11.com1.z0.glb.clouddn.com/1.png" alt></p><h4>2.真正部署应用到网上的配置</h4><p>  和在本地调试配置步骤一样，只不过这里是在服务器上配置。</p><blockquote><p>修改端口，改成80端口</p></blockquote><pre><code>&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;        connectionTimeout=&quot;20000&quot;        redirectPort=&quot;8443&quot; /&gt;</code></pre><blockquote><p>绑定域名</p></blockquote><pre><code>&lt;Host name=&quot;top.pockerface.cn&quot;  appBase=&quot;webapps&quot;        unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;&lt;Context path=&quot;/&quot; docBase=&quot;/opt/tomcat7/webapps/WebPhoto&quot;&gt;&lt;/Context&gt;&lt;/Host&gt;</code></pre><p><b>这里的<code>top.pockerface.cn</code>是博主的二级域名，需要在DNS解析中，解析域名指向你的服务器。</b></p><h4 id="此时通过top-pockerface-cn就可以访问你的页面了"><a href="#此时通过top-pockerface-cn就可以访问你的页面了" class="headerlink" title="此时通过top.pockerface.cn就可以访问你的页面了"></a>此时通过<code>top.pockerface.cn</code>就可以访问你的页面了</h4><p><img src="http://7xta11.com1.z0.glb.clouddn.com/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;b&gt;我们使用&lt;code&gt;Tomcat&lt;/code&gt;发布应用时，默认是绑定在&lt;code&gt;8080&lt;/code&gt;端口，这种情况一般在测试后使用。如果应用需要部署到服务器上则需要修改端口为&lt;code&gt;80&lt;/code&gt;，并通过域名直接访问。具体如何做呢？&lt;br&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xta11.com1.z0.glb.clouddn.com/ChMkJ1cghZGIbfOAAARV4Pwpv4QAAQsDQJ9YssABFX4485.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;打包应用为war&quot;&gt;&lt;a href=&quot;#打包应用为war&quot; class=&quot;headerlink&quot; title=&quot;打包应用为war&quot;&gt;&lt;/a&gt;打包应用为war&lt;/h4&gt;&lt;p&gt;&lt;b&gt;首先打包应用为.war文件，具体步骤为在&lt;code&gt;Myeclipse&lt;/code&gt;中点击&lt;code&gt;File-&amp;gt;Export&lt;/code&gt;选择&lt;code&gt;web-&amp;gt;war file&lt;/code&gt;下一步之后选择要打包的应用，重命名为发布名称，比如&lt;code&gt;test.war&lt;/code&gt;确定之后即打包。&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>解决Ubuntu下搜狗输入法无法输入中文问题</title>
    <link href="http://yoursite.com/2016/10/20/%E8%A7%A3%E5%86%B3ubuntu%E4%B8%8B%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/10/20/解决ubuntu下搜狗输入法无法输入中文问题/</id>
    <published>2016-10-20T11:59:53.000Z</published>
    <updated>2020-03-25T11:30:46.267Z</updated>
    
    <content type="html"><![CDATA[<h1>解决ubuntu16.04下搜狗输入法无法输入中文问题</h1><p>今天打开电脑,突然发现一直正常使用的搜狗输入法无法无法输入中文(<b>具体现象是，可以呼出搜狗输入法界面，但是候选词列表无显示</b>).在查阅了别人的博客后解决了这个问题，下面是解决方案.</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/0D/06/ChMkJ1ojqAGISeb1AAexeXbMtcgAAiwQAPGnzMAB7GR200.jpg" alt></p><a id="more"></a><p>我的版本号:</p><ul><li>OS：<code>Ubuntu16.04LST</code></li><li>搜狗版本:<code>sogoupinyin_2.1.0.0082_amd64.deb</code><br><center><br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1490240967&amp;di=a8c79abaa880c6efe8cd7a471576e4b1&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fwww.xiazaizhijia.com%2Fuploads%2Fallimg%2F140217%2F36-14021GAA2615.png" alt></center></li></ul><p></p><p></p><h3>方法一:</h3><br>重启搜狗输入法,看是否有效<p></p><pre><code>~$ killall fcitx~$ killall sogou-qinpanel~$ fcitx</code></pre><p></p><h3>方法二：检查修复安装依赖</h3><br>我本机依赖完好,所以应该不是依赖的问题。但如果刚安装搜狗无法使用,可以尝试下修复依赖.<p></p><pre><code>~$ sudo apt  install -f</code></pre><p></p><h3>方法三:删除配置文件,重启搜狗</h3><br>ubuntu下搜狗配置文件在~/.config下的3个文件夹内:<br>    <code>SogouPY</code>,<code>SogouPY.users</code>、<code>sogou-qimpanel</code><br>    删除这3个文件夹,之后重启.<p></p><p><b>注:我就是用这个方法解决了无法输入中文问题</b></p><p></p><h3>总结</h3><br>Linux下软件经常会因为配置问题而崩溃，最直观的现象就是无法正常使用.因此，如果Linux下正常使用的软件，突然崩溃无法使用，可以尝试删除或修改配置文件的方式尝试解决。<p></p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;解决ubuntu16.04下搜狗输入法无法输入中文问题&lt;/h1&gt;

&lt;p&gt;今天打开电脑,突然发现一直正常使用的搜狗输入法无法无法输入中文(&lt;b&gt;具体现象是，可以呼出搜狗输入法界面，但是候选词列表无显示&lt;/b&gt;).在查阅了别人的博客后解决了这个问题，下面是解决方案.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/0D/06/ChMkJ1ojqAGISeb1AAexeXbMtcgAAiwQAPGnzMAB7GR200.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ngrok神器映射外网</title>
    <link href="http://yoursite.com/2016/09/20/%E7%A5%9E%E5%99%A8Ngrok%E6%98%A0%E5%B0%84%E5%A4%96%E7%BD%91/"/>
    <id>http://yoursite.com/2016/09/20/神器Ngrok映射外网/</id>
    <published>2016-09-20T11:59:53.000Z</published>
    <updated>2020-03-25T11:30:46.267Z</updated>
    
    <content type="html"><![CDATA[<p><b>ngrok 服务可以分配给你一个域名让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API (比如微信公众号，企业号的开发) </b></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJ1lkKOSIMAebABMY8g_U_F0AAeWIQDF5hoAExkK642.jpg"></p><a id="more"></a><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ul><li>下载linux版本的客户端，解压到你喜欢的目录,注意：要给ngrok文件的可执行权限<a href="http://pan.baidu.com/s/1jG4fEGu" target="_blank" rel="noopener">Ubuntu 64 位下载地址</a></li></ul><ul><li>在命令行下进入到<code>path/to/linux_amd64/</code>下</li><li>执行 <code>./ngrok -config=ngrok.cfg -subdomain xxx 8080</code> //(<code>xxx</code> 是你自定义的域名前缀，<code>8080</code>是你本机服务器对应的端口，由于我用的是<code>Apache Tomcat 7</code>所以端口是<code>8080</code>)</li><li>如果开启成功 你就可以使用 <code>xxx.tunnel.qydev.com</code> 来访问你本机的 <code>127.0.0.1:80</code> 的服务啦</li><li>如果你自己有顶级域名，想通过自己的域名来访问本机的项目，那么先将自己的顶级域名解析到<code>123.57.165.240</code> (域名需要已备案哦),然后执行<code>./ngrok -config=ngrok.cfg -hostname xxx.xxx.xxx 8080</code> //(xxx.xxx.xxx是你自定义的顶级域名)</li><li>如果开启成功 你就可以使用你的顶级域名来访问你本机的 <code>127.0.0.1:8080</code> 的服务啦</li></ul><p><b>参考文献:<a href="http://qydev.com/#" target="_blank" rel="noopener">http://qydev.com/#</a></b></p><pre><code>Writen on 11.Apri.2016</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;ngrok 服务可以分配给你一个域名让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API (比如微信公众号，企业号的开发) &lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJ1lkKOSIMAebABMY8g_U_F0AAeWIQDF5hoAExkK642.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ngrok" scheme="http://yoursite.com/tags/Ngrok/"/>
    
  </entry>
  
  <entry>
    <title>Git使用ssh密钥</title>
    <link href="http://yoursite.com/2016/09/13/Git%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5/"/>
    <id>http://yoursite.com/2016/09/13/Git使用ssh密钥/</id>
    <published>2016-09-13T11:59:53.000Z</published>
    <updated>2020-03-25T11:30:46.259Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJllkKMeIJ6CSAAdGdB9XHNIAAeWIAJf87AAB0aM436.jpg" alt></p><a id="more"></a><hr><p><b><br>git使用https协议，每次pull, push都要输入密码，相当的烦。<br>使用git协议，然后使用ssh密钥。这样可以省去每次都输密码。<br></b></p><hr><p>大概需要三个步骤：</p><ol><li>本地生成密钥对；</li><li>设置github上的公钥；</li><li>修改git的remote url为git协议。</li></ol><hr><h2 id="详细讲解第3部分"><a href="#详细讲解第3部分" class="headerlink" title="详细讲解第3部分"></a>详细讲解第3部分</h2><p>修改你本地的ssh remote url. 不用https协议，改用git 协议</p><p>可以用<code>git remote -v</code>查看你当前的<code>remote url</code></p><pre><code>$ git remote -vorigin    https://github.com/Helloxyw/Helloxyw.github.io.git (fetch)origin    https://github.com/Helloxyw/Helloxyw.github.io.git (push)</code></pre><p>可以看到是使用https协议进行访问的。</p><p>你可以使用浏览器登陆你的github，在上面可以看到你的ssh协议相应的url。类似如下：</p><pre><code>git@github.com:someaccount/someproject.git</code></pre><p>这时，你可以使用<code>git remote set-url</code> 来调整你的<code>url</code>。</p><pre><code>git remote set-url origin git@github.com:someaccount/someproject.git</code></pre><p>完了之后，你便可以再用<code>git remote -v</code> 查看一下。<br>    $ git remote -v<br>    origin    git@github.com:Helloxyw/Helloxyw.github.io.git (fetch)<br>    origin    git@github.com:Helloxyw/Helloxyw.github.io.git (push)</p><p> 至此，OK。</p><p>你可以用<code>git fetch, git pull , git push</code>， 现在进行远程操作，应该就不需要输入密码那么烦了。</p><pre><code>Writhen On 18-Apr-2016 By Ricardo Xu</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJllkKMeIJ6CSAAdGdB9XHNIAAeWIAJf87AAB0aM436.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
</feed>
