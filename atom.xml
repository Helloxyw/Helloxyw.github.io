<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RicardoXu博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-28T15:24:16.608Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>RicardoXu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>秒杀系统设计</title>
    <link href="http://yoursite.com/2020/03/28/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2020/03/28/秒杀系统设计/</id>
    <published>2020-03-27T16:00:00.000Z</published>
    <updated>2020-03-28T15:24:16.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-业务"><a href="#1-业务" class="headerlink" title="1.业务"></a>1.业务</h2><h3 id="用户业务："><a href="#用户业务：" class="headerlink" title="用户业务："></a>用户业务：</h3><ul><li>短信发送业务</li><li>注册业务</li><li>登录业务</li></ul><h3 id="商品业务："><a href="#商品业务：" class="headerlink" title="商品业务："></a>商品业务：</h3><ul><li>查询商品</li></ul><h3 id="交易业务："><a href="#交易业务：" class="headerlink" title="交易业务："></a>交易业务：</h3><ul><li>下单业务</li><li>订单ID的生成</li></ul><h3 id="秒杀业务："><a href="#秒杀业务：" class="headerlink" title="秒杀业务："></a>秒杀业务：</h3><ul><li>活动商品下单业务</li></ul><p><img src="https://2.bp.blogspot.com/-Sl6wdO704eo/Tbl_cbCIAbI/AAAAAAAACFw/nlP414H6CLo/s1600/96d8e440a7dd5501977e686709a8ee60.jpg" alt><br><a id="more"></a></p><h2 id="2-需要改进的地方"><a href="#2-需要改进的地方" class="headerlink" title="2.需要改进的地方"></a>2.需要改进的地方</h2><ol><li>如何发现容量问题</li><li>如何使得系统水平扩展</li><li>查询效率低下</li><li>活动开始前页面被疯狂刷新</li><li>库存行锁问题</li><li>下单操作多、缓慢</li><li>浪涌流量如何解决</li></ol><h1 id="秒杀优化部分："><a href="#秒杀优化部分：" class="headerlink" title="秒杀优化部分："></a>秒杀优化部分：</h1><h2 id="3-单机服务器并发容量问题"><a href="#3-单机服务器并发容量问题" class="headerlink" title="3.单机服务器并发容量问题"></a>3.单机服务器并发容量问题</h2><p>原因： 1. server并发线程数上不去，导致客户端被拒绝连接，tps上不去</p><p>查看商品详情接口压测数据：</p><table><thead><tr><th>序号</th><th>请求</th><th>平均耗时(ms)</th><th>tps(s)</th></tr></thead><tbody><tr><td>1</td><td>1000*100</td><td>283</td><td>2749</td></tr><tr><td>2</td><td>2000*100</td><td>577</td><td>2970</td></tr><tr><td>3</td><td>3000*100</td><td>588</td><td>1879</td></tr></tbody></table><h3 id="3-1-默认内嵌Tomcat配置"><a href="#3-1-默认内嵌Tomcat配置" class="headerlink" title="3.1 默认内嵌Tomcat配置"></a>3.1 默认内嵌Tomcat配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.accept-count:等待队列长度,默认<span class="number">100</span></span><br><span class="line">server.tomcat.max-connections:最大可被连接数，默认<span class="number">8192</span></span><br><span class="line">server.tomcat.max-threads:最大工作线程数，默认<span class="number">200</span></span><br><span class="line">server.tomcat.min-spare-threads:最小工作线程数，默认<span class="number">10</span></span><br><span class="line"></span><br><span class="line">默认配置下，连接超过<span class="number">8192</span>后出现拒绝连接的情况</span><br><span class="line">默认配置下，触发的请求超过<span class="number">200</span>+<span class="number">100</span>后拒绝处理</span><br></pre></td></tr></table></figure><h3 id="3-2-SpringBoot内嵌tomcat线程优化"><a href="#3-2-SpringBoot内嵌tomcat线程优化" class="headerlink" title="3.2 SpringBoot内嵌tomcat线程优化"></a>3.2 SpringBoot内嵌tomcat线程优化</h3><p>在<code>application.properties</code>里面进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.accept-count=1000</span><br><span class="line">server.tomcat.max-threads=800</span><br><span class="line">server.tomcat.min-spare-threads=100</span><br><span class="line"># 取默认值</span><br><span class="line">server.tomcat.max-connections=8192</span><br></pre></td></tr></table></figure><p><strong>等待队列不是越大越好</strong>，一是受到内存的限制，二是大量的出队入队操作耗费CPU性能。</p><p><strong>最大线程数不是越大越好</strong>，因为线程越多，CPU上下文切换的开销越大，存在一个“阈值”，对于一个4核8G的服务器，经验值是800。</p><p>而最小线程数设为100，则是为了应付一些<strong>突发情况</strong>。</p><p>spring boot内嵌的tomcat线程优化后，再次压测，效果不是特别明显</p><table><thead><tr><th>序号</th><th>请求</th><th>平均耗时(ms)</th><th>tps(s)</th></tr></thead><tbody><tr><td>1</td><td>2000*100</td><td>595</td><td>2958</td></tr></tbody></table><h3 id="3-3-SpringBoot内嵌Tomcat网络连接优化"><a href="#3-3-SpringBoot内嵌Tomcat网络连接优化" class="headerlink" title="3.3 SpringBoot内嵌Tomcat网络连接优化"></a>3.3 SpringBoot内嵌Tomcat网络连接优化</h3><p>当然Spring Boot并没有把内嵌Tomcat的所有配置都导出。一些配置需要通过<code>WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;</code>接口来定义。</p><p>这里需要自定义<code>KeepAlive</code>长连接的配置，减少客户端和服务器的连接请求次数，避免重复建立连接，提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerConfiguration</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用对应工厂类提供给我们的接口，定制化Tomcat connector</span></span><br><span class="line">        ((TomcatServletWebServerFactory) factory).addConnectorCustomizers(<span class="keyword">new</span> TomcatConnectorCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">                Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line">                <span class="comment">//定制化KeepAlive Timeout为30秒</span></span><br><span class="line">                protocol.setKeepAliveTimeout(<span class="number">30000</span>);</span><br><span class="line">                <span class="comment">//10000个请求则自动断开</span></span><br><span class="line">                protocol.setMaxKeepAliveRequests(<span class="number">8192</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springboot内嵌的tomcat网络连接优化，保持长连接，压测后效果</p><table><thead><tr><th>序号</th><th>请求</th><th>平均耗时(ms)</th><th>tps(s)</th></tr></thead><tbody><tr><td>1</td><td>2000*100</td><td>555</td><td>3223</td></tr></tbody></table><h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><ul><li>发现了Spring Boot内嵌Tomcat的<strong>线程容量问题</strong>。通过在Spring Boot配置文件中添加配置项，提高了Tomcat的等待队列长度、最大工作线程、最小工作线程，榨干服务器性能。</li><li>Spring Boot内嵌Tomcat默认使用<code>HTTP 1.0</code>的<strong>短连接</strong>，由于Spring Boot并没有把所有Tomcat配置都暴露出来，所以需要编写一个配置类使用<code>HTTP 1.1</code>的<strong>长连接</strong></li></ul><h3 id="3-5-接下来的优化方向"><a href="#3-5-接下来的优化方向" class="headerlink" title="3.5 接下来的优化方向"></a>3.5 接下来的优化方向</h3><ul><li>对服务器进行分布式扩展</li><li>优化SQL查询，比如添加索引</li></ul><h2 id="4-分布式扩展优化"><a href="#4-分布式扩展优化" class="headerlink" title="4. 分布式扩展优化"></a>4. 分布式扩展优化</h2><p><strong>部署图：</strong></p><p><img src="http://assets.processon.com/chart_image/5e5ba4dfe4b0541c5e15615c.png?_=1583073379976" alt></p><h3 id="4-1-nginx作用："><a href="#4-1-nginx作用：" class="headerlink" title="4.1 nginx作用："></a>4.1 nginx作用：</h3><ul><li>动静分离</li><li>反向代理、负载均衡</li></ul><h2 id="5-分布式会话"><a href="#5-分布式会话" class="headerlink" title="5. 分布式会话"></a>5. 分布式会话</h2><ul><li>基于cookie传输sessionID</li><li>基于token传输类似sessionID</li></ul><h2 id="6-查询优化之多级缓存"><a href="#6-查询优化之多级缓存" class="headerlink" title="6. 查询优化之多级缓存"></a>6. 查询优化之多级缓存</h2><p>多级缓存有两层含义，一个是<strong>缓存</strong>，一个是<strong>多级</strong>。我们知道，内存的速度是磁盘的成百上千倍，高并发下，从磁盘I/O十分影响性能。所谓缓存，就是将磁盘中的热点数据，暂时存到内存里面，以后查询直接从内存中读取，减少磁盘I/O，提高速度。所谓多级，就是在多个层次设置缓存，一个层次没有就去另一个层次查询。</p><h3>项目架构</h3><p><img src="http://assets.processon.com/chart_image/5e5ba4dfe4b0541c5e15615c.png" alt></p><h3 id="6-1-优化商品查询接口——单机版redis思路"><a href="#6-1-优化商品查询接口——单机版redis思路" class="headerlink" title="6.1 优化商品查询接口——单机版redis思路"></a>6.1 优化商品查询接口——单机版redis思路</h3><p>之前的<code>ItemController.getItem</code>接口，来一个<code>Id</code>，就调用<code>ItemService</code>去数据库查询一次。<code>ItemService</code>会查三张表，分别是商品信息表<code>item</code>表、商品库存<code>stock</code>表和活动信息表<code>promo</code>，十分影响性能。</p><p>所以修改<code>ItemController.getItem</code>接口，思路很简单，先从Redis服务器获取，若没有，则从数据库查询并存到Redis服务。有的话直接用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/get"</span>,method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getItem</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span>Integer id)</span>&#123;</span><br><span class="line">    ItemModel itemModel=(ItemModel)redisTemplate.opsForValue().get(<span class="string">"item_"</span>+id);</span><br><span class="line">    <span class="comment">//如果不存在，就执行下游操作，到数据查询</span></span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        itemModel=itemService.getItemById(id);</span><br><span class="line">        <span class="comment">//设置itemModel到redis服务器</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">        <span class="comment">//设置失效时间</span></span><br><span class="line">        redisTemplate.expire(<span class="string">"item_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    ItemVO itemVO=convertVOFromModel(itemModel);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(itemVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-优化商品查询接口——本地热点缓存"><a href="#6-2-优化商品查询接口——本地热点缓存" class="headerlink" title="6.2 优化商品查询接口——本地热点缓存"></a>6.2 优化商品查询接口——本地热点缓存</h3><p>Redis缓存虽好，但是有网络I/O，没有本地缓存快。我们可以在Redis的前面再添加一层<strong>“本地热点”</strong>缓存。所谓<strong>本地</strong>，就是利用<strong>本地JVM内存</strong>，由于JVM内存有限，仅存放<strong>多次查询</strong>的数据。</p><p>本地缓存，说白了就是一个<code>HashMap</code>，但是<code>HashMap</code>不支持并发读写，肯定是不行的。<code>j.u.c</code>包里面的<code>ConcurrentHashMap</code>虽然也能用，但是无法高效处理过期时限、没有淘汰机制等问题，所以这里使用了<code>Google</code>的<code>Guava Cache</code>方案。</p><p><code>Guava Cache</code>除了线程安全外，还可以控制超时时间，提供淘汰机制。</p><p>引用<code>google.guava</code>包后，在<code>service</code>包下新建一个<code>CacheService</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String,Object&gt; commonCache=<span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        commonCache= CacheBuilder.newBuilder()</span><br><span class="line">                <span class="comment">//初始容量</span></span><br><span class="line">                .initialCapacity(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//最大100个KEY，超过后会按照LRU策略移除</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                <span class="comment">//设置写缓存后多少秒过期，还有根据访问过期即expireAfterAccess</span></span><br><span class="line">                .expireAfterWrite(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommonCache</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">       commonCache.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFromCommonCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonCache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ItemController</code>里面，首先从本地缓存中获取，如果本地缓存没有，就去Redis里面获取，如果Redis也没有，就去数据库查询并存放到Redis里面。如果Redis里面有，将其获取后存到本地缓存里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getItem</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span>Integer id)</span>&#123;</span><br><span class="line">    ItemModel itemModel=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//第一级：先去本地缓存</span></span><br><span class="line">    itemModel=(ItemModel)cacheService.getFromCommonCache(<span class="string">"item_"</span>+id);</span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//第二级：从redis里面获取</span></span><br><span class="line">        itemModel=(ItemModel)redisTemplate.opsForValue().get(<span class="string">"item_"</span>+id);</span><br><span class="line">        <span class="comment">//如果不存在，就执行下游操作，到数据查询</span></span><br><span class="line">        <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">            itemModel=itemService.getItemById(id);</span><br><span class="line">            <span class="comment">//设置itemModel到redis服务器</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">            <span class="comment">//设置失效时间</span></span><br><span class="line">            redisTemplate.expire(<span class="string">"item_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//填充本地缓冲</span></span><br><span class="line">        cacheService.setCommonCache(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">    &#125;</span><br><span class="line">    ItemVO itemVO=convertVOFromModel(itemModel);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(itemVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-本地缓存缺点"><a href="#6-3-本地缓存缺点" class="headerlink" title="6.3 本地缓存缺点"></a>6.3 本地缓存缺点</h3><p>本地缓存虽然快，但是也有缺点：</p><ul><li>更新麻烦，容易产生脏数据</li><li>受到JVM容量的限制</li></ul><h3 id="6-4-Nginx缓存"><a href="#6-4-Nginx缓存" class="headerlink" title="6.4 Nginx缓存"></a>6.4 Nginx缓存</h3><h2 id="7-查询优化之页面静态化"><a href="#7-查询优化之页面静态化" class="headerlink" title="7.  查询优化之页面静态化"></a>7.  查询优化之页面静态化</h2><h3 id="7-1-CDN"><a href="#7-1-CDN" class="headerlink" title="7.1 CDN"></a>7.1 CDN</h3><h3 id="7-2-全页面静态化"><a href="#7-2-全页面静态化" class="headerlink" title="7.2 全页面静态化"></a>7.2 全页面静态化</h3><h2 id="8-交易优化之缓存库存"><a href="#8-交易优化之缓存库存" class="headerlink" title="8. 交易优化之缓存库存"></a>8. 交易优化之缓存库存</h2><h3 id="8-1-交易接口瓶颈"><a href="#8-1-交易接口瓶颈" class="headerlink" title="8.1 交易接口瓶颈"></a>8.1 交易接口瓶颈</h3><p>压测时发现<code>createOrder</code>接口压力很大，而数据库服务器的压力则要小很多。</p><p>原因在于，在<code>OrderService.createOrder</code>方法里面，首先要去数据库 <strong>查询商品信息，</strong>而在查询商品信息的过程中，又要去 <strong>查询秒杀活动消息</strong>，最后还要查询<strong>用户信息</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询商品信息的过程中，也会查询秒杀活动信息。</span></span><br><span class="line">ItemModel itemModel=itemService.getItemById(itemId);</span><br><span class="line"><span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR,<span class="string">"商品信息不存在"</span>);</span><br><span class="line"><span class="comment">//查询用户信息</span></span><br><span class="line">UserModel userModel=userService.getUserById(userId);</span><br></pre></td></tr></table></figure><p> 这还没完，最后还要对<code>stock</code><strong>库存表进行-1<code>update</code>操作</strong>，对<code>order_info</code><strong>订单信息表进行添加<code>insert</code>操作，</strong>对<code>item</code><strong>商品信息表进行销量+1<code>update</code>操作</strong>。仅仅一个下单，就有<strong>6次</strong>数据库I/O操作，此外，减库存操作还存在<strong>行锁阻塞</strong>，所以下单接口并发性很低。</p><h3 id="8-2-交易验证优化"><a href="#8-2-交易验证优化" class="headerlink" title="8.2 交易验证优化"></a>8.2 交易验证优化</h3><p>验证用户信息，是为了<strong>用户风控策略</strong>。判断用户信息是否存在是基本的策略，在企业级中，还可以判断用户状态是否异常，是否异地登录等。用户风控的信息，实际上可以缓存话，放到Redis里。</p><p>查询商品信息、活动信息，是为了<strong>活动校验策略</strong>。商品信息、活动信息，也可以存入缓存中。活动信息，由于具有<strong>时效性</strong>，需要具备紧急下线的接口，可以编写一个接口，清除活动信息的缓存。</p><h4 id="8-2-1-用户校验缓存化"><a href="#8-2-1-用户校验缓存化" class="headerlink" title="8.2.1 用户校验缓存化"></a>8.2.1 用户校验缓存化</h4><p>思路很简单，就是先从Redis里面获取用户信息，没有再去数据库查，并放到Redis里面。<code>UserService</code>新开一个<code>getUserByIdCache()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UserModel <span class="title">getUserByIdInCache</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    UserModel userModel= (UserModel) redisTemplate.opsForValue().get(<span class="string">"user_validate_"</span>+id);</span><br><span class="line">    <span class="keyword">if</span>(userModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        userModel=<span class="keyword">this</span>.getUserById(id);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"user_validate_"</span>+id,userModel);</span><br><span class="line">        redisTemplate.expire(<span class="string">"user_validate_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-2-活动校验缓存优化"><a href="#8-2-2-活动校验缓存优化" class="headerlink" title="8.2.2 活动校验缓存优化"></a>8.2.2 活动校验缓存优化</h4><p>跟用户校验类似，<code>ItemService</code>新开了一个<code>getItemByIdCache()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ItemModel <span class="title">getItemByIdInCache</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    ItemModel itemModel=(ItemModel)redisTemplate.opsForValue().get(<span class="string">"item_validate_"</span>+id);</span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        itemModel=<span class="keyword">this</span>.getItemById(id);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"item_validate_"</span>+id,itemModel);</span><br><span class="line">         redisTemplate.expire(<span class="string">"item_validate_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> itemModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-3-缓存优化后的效果"><a href="#8-2-3-缓存优化后的效果" class="headerlink" title="8.2.3 缓存优化后的效果"></a>8.2.3 缓存优化后的效果</h4><p>优化之后，tps和响应时间提升效果很好</p><h3 id="8-3-库存扣减优化"><a href="#8-3-库存扣减优化" class="headerlink" title="8.3 库存扣减优化"></a>8.3 库存扣减优化</h3><h4 id="8-3-1-索引优化"><a href="#8-3-1-索引优化" class="headerlink" title="8.3.1 索引优化"></a>8.3.1 索引优化</h4><p>之前扣减库存的操作，会执行<code>update stock set stock = stock - #{amount} where item_id = #{itemId} and stock &gt; #{amount}</code>这条SQL语句。如果<code>where</code>条件的<code>item_id</code>字段没有<strong>索引</strong>，那么会<strong>锁表</strong>，性能很低。所以先查看<code>item_id</code>字段是否有索引，没有的话，使用<code>alter table stock add UNIQUE INDEX item_id_index(item_id)</code>，为<code>item_id</code>字段添加一个<code>唯一索引</code>，这样在修改的时候，只会<strong>锁行</strong>。</p><h4 id="8-3-2-库存扣减缓存优化"><a href="#8-3-2-库存扣减缓存优化" class="headerlink" title="8.3.2 库存扣减缓存优化"></a>8.3.2 库存扣减缓存优化</h4><p>之前下单，是<strong>直接操作数据库</strong>，一旦秒杀活动开始，大量的流量涌入扣减库存接口，<strong>数据库压力很大</strong>。那么可不可以现在<strong>缓存中</strong>下单？答案是可以的。如果要在缓存中扣减库存，需要解决<strong>两个</strong>问题，第一个是活动开始前，将数据库的库存信息，同步到缓存中。第二个是下单之后，要将缓存中的库存信息同步到数据库中。这就需要用到<strong>异步消息队列</strong>——也就是<strong>RocketMQ</strong>。</p><h5 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h5><p>RocketMQ是阿里巴巴在RabbitMQ基础上改进的一个消息中间件。</p><p>只是要特别说明一下，默认的RocketMQ<strong>配置很坑</strong>（<code>Xms4g Xmx4g Xmn2g</code>），会导致Java<strong>内存不足</strong>的问题。需要修改<code>mqnamesrv.xml</code>，将<code>NewSize</code>、<code>MaxNewSize</code>、<code>PermSize</code>、<code>MaxPermSize</code>设置为自己服务器可承受值。</p><p>此外，<code>mqnamesrv</code>甚至不能用<code>localhost</code>启动，必须是本机公网IP，否则报<code>RemotingTooMuchRequestException</code>。</p><p><code>PromoService</code>新建一个<code>publishPromo()</code>方法，把数据库的缓存存到redis里去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishPromo</span><span class="params">(Integer promoId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过活动id获取活动</span></span><br><span class="line">    PromoDO promoDO=promoDOMapper.selectByPrimaryKey(promoId);</span><br><span class="line">    <span class="keyword">if</span>(promoDO.getItemId()==<span class="keyword">null</span> || promoDO.getItemId().intValue()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ItemModel itemModel=itemService.getItemById(promoDO.getItemId());</span><br><span class="line">    <span class="comment">//库存同步到Redis</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_"</span>+itemModel.getId(),itemModel.getStock());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意到的是，当我们把<strong>库存存到Redis的时候，商品可能被下单，</strong>这样数据库的库存和Redis的库存就 <strong>不一致</strong>了。解决方法就是活动<strong>未开始</strong>的时候，商品是<strong>下架状态</strong>，不能被下单。</p><p>最后，在<code>ItemService</code>里面修改<code>decreaseStock()</code>方法，在Redis里面扣减库存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 老方法，直接在数据库减</span></span><br><span class="line">    <span class="comment">// int affectedRow=itemStockDOMapper.decreaseStock(itemId,amount);</span></span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (affectedRow &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="同步缓存库存到数据库（异步扣减库存）"><a href="#同步缓存库存到数据库（异步扣减库存）" class="headerlink" title="同步缓存库存到数据库（异步扣减库存）"></a>同步缓存库存到数据库（异步扣减库存）</h5><p>引入RocketMQ相应<code>jar</code>包，在Spring Boot配置文件中添加MQ配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mq.nameserver.addr=IP:<span class="number">9876</span></span><br><span class="line">mq.topicname=stock</span><br></pre></td></tr></table></figure><p>新建一个<code>mq.MQProducer</code>类，编写<code>init</code>方法，初始化生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqProducer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> DefaultMQProducer producer;</span><br><span class="line">  <span class="comment">//即是IP:9867</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.nameserver.addr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameAddr;</span><br><span class="line">    <span class="comment">//即是stock</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.topicname&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String topicName;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">//Producer初始化，Group对于生产者没有意义，但是消费者有意义</span></span><br><span class="line">        producer=<span class="keyword">new</span> DefaultMQProducer(<span class="string">"producer_group"</span>);</span><br><span class="line">        producer.setNamesrvAddr(nameAddr);</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写<code>asyncReduceStock()</code>方法，实现异步扣减库存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">asyncReduceStock</span><span class="params">(Integer itemId, Integer amount)</span>  </span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; bodyMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    bodyMap.put(<span class="string">"itemId"</span>,itemId);</span><br><span class="line">    bodyMap.put(<span class="string">"amount"</span>,amount);</span><br><span class="line">    <span class="comment">//创建消息</span></span><br><span class="line">    Message message=<span class="keyword">new</span> Message(topicName,<span class="string">"increase"</span>,</span><br><span class="line">                JSON.toJSON(bodyMap).toString().getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        producer.send(message);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">      ···</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个<code>mq.MqConsumer</code>类，与<code>MqProducer</code>类类似，也有一个<code>init</code>方法，实现<strong>异步扣减库存</strong>的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DefaultMQPushConsumer consumer;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.nameserver.addr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameAddr;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.topicname&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String topicName;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ItemStockDOMapper itemStockDOMapper;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        consumer=<span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"stock_consumer_group"</span>);</span><br><span class="line">        <span class="comment">//监听名为topicName的话题</span></span><br><span class="line">        consumer.setNamesrvAddr(nameAddr);</span><br><span class="line">        <span class="comment">//监听topicName话题下的所有消息</span></span><br><span class="line">        consumer.subscribe(topicName,<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">//这个匿名类会监听消息队列中的消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//实现缓存数据真正到数据库扣减的逻辑</span></span><br><span class="line">                <span class="comment">//从消息队列中获取消息</span></span><br><span class="line">                Message message=list.get(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//反序列化消息</span></span><br><span class="line">                String jsonString=<span class="keyword">new</span> String(message.getBody());</span><br><span class="line">                Map&lt;String,Object&gt; map=JSON.parseObject(jsonString, Map.class);</span><br><span class="line">                Integer itemId= (Integer) map.get(<span class="string">"itemId"</span>);</span><br><span class="line">                Integer amount= (Integer) map.get(<span class="string">"amount"</span>);</span><br><span class="line">                <span class="comment">//去数据库扣减库存</span></span><br><span class="line">                itemStockDOMapper.decreaseStock(itemId,amount);</span><br><span class="line">                <span class="comment">//返回消息消费成功</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ItemService.decreaseStock()</code>方法也要做更改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//&gt;0，表示Redis扣减成功</span></span><br><span class="line">    <span class="keyword">if</span>(affectedRow&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//发送消息到消息队列，准备异步扣减</span></span><br><span class="line">        <span class="keyword">boolean</span> mqResult = mqProducer.asyncReduceStock(itemId,amount);</span><br><span class="line">        <span class="keyword">if</span> (!mqResult)&#123;</span><br><span class="line">            <span class="comment">//消息发送失败，需要回滚Redis</span></span><br><span class="line">          redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Redis扣减失败，回滚</span></span><br><span class="line">        redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异步扣减库存存在的问题"><a href="#异步扣减库存存在的问题" class="headerlink" title="异步扣减库存存在的问题"></a>异步扣减库存存在的问题</h5><ul><li>如果发送消息失败，只能回滚Redis</li><li>消费端从数据库扣减操作执行失败，如何处理（这里默认成功）？</li><li>下单失败无法正确回补库存（比如用户取消订单）。</li></ul><p>所以需要引入<strong>事务型消息</strong>。</p><h3 id="8-4-小结"><a href="#8-4-小结" class="headerlink" title="8.4 小结"></a>8.4 小结</h3><ul><li>首先对<strong>交易验证</strong>进行了优化，把对用户、商品、活动的查询从数据库转移到了缓存中，优化效果明显。</li><li>随后，优化了减库存的逻辑<ul><li>一是添加了索引，从锁表变成了锁行；</li><li>二是将减库存的操作也移到了缓存中，先从缓存中扣，再从数据库中扣。这就涉及到了<strong>异步减库存</strong>，所以需要引入<strong>消息中间件</strong>。</li></ul></li></ul><h2 id="9-交易优化之事务型优化"><a href="#9-交易优化之事务型优化" class="headerlink" title="9. 交易优化之事务型优化"></a>9. 交易优化之事务型优化</h2><h3 id="9-1-异步消息发送时机问题"><a href="#9-1-异步消息发送时机问题" class="headerlink" title="9.1 异步消息发送时机问题"></a>9.1 异步消息发送时机问题</h3><p>目前扣减库存的事务<code>ItemService.decreaseStock()</code>是封装在<code>OrderService()</code>事务里面的。在扣减Redis库存、发送异步消息之后，还有订单入库、增加销量的操作。如果这些操作失败，那么<code>createOrder()</code><strong>事务会回滚</strong>，<code>decreaseStock()</code><strong>事务也回滚</strong>，但是Redis的<strong>扣减操作却不能回滚，</strong>这会导致数据不一致。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>解决方法就是在订单入库、增加销量成功之后，再发生异步消息，<code>ItemService.decreaseStock()</code>只<strong>负责扣减Redis库存，不发送异步消息</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//&gt;0，表示Redis扣减成功</span></span><br><span class="line">    <span class="keyword">if</span>(affectedRow&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//抽离了发送异步消息的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Redis扣减失败，回滚</span></span><br><span class="line">        increaseStock(itemId, amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将发送异步消息的逻辑抽出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ItemService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">asyncDecreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mqProducer.asyncReduceStock(itemId, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在<code>OrderService.createOrder()</code>里面调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="comment">//订单入库</span></span><br><span class="line">orderDOMapper.insertSelective(orderDO);</span><br><span class="line"><span class="comment">//销量增加</span></span><br><span class="line">itemService.increaseSales(itemId,amount);</span><br><span class="line"><span class="comment">//执行完最后一步才发送异步消息</span></span><br><span class="line"><span class="keyword">boolean</span> mqResult=itemService.asyncDecreaseStock(itemId,amount);</span><br><span class="line">    <span class="keyword">if</span>(!mqResult)&#123;</span><br><span class="line">        <span class="comment">//回滚redis库存</span></span><br><span class="line">        itemService.increaseStock(itemId,amount);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.MQ_SEND_FAIL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样，就算订单入库失败、销量增加失败、消息发送失败，都能保证缓存和数据库的一致性。</p><h3 id="9-2-事务提交问题"><a href="#9-2-事务提交问题" class="headerlink" title="9.2 事务提交问题"></a>9.2 事务提交问题</h3><p>但是这么做，仍然有问题。Spring的<code>@Transactional</code>标签，会在<strong>事务方法返回后才提交</strong>，如果提交的过程中，发生了异常，则数据库回滚，但是Redis库存已扣，还是无法保证一致性。我们需要在<strong>事务提交成功后，再发生异步消息</strong>。</p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>Spring给我们提供了<code>TransactionSynchronizationManager.registerSynchronization()</code>方法，这个方法传入一个<code>TransactionSynchronizationAdapter</code>的匿名类，通过<code>afterCommit()</code>方法，在<strong>事务提交成功后，</strong>执行<strong>发送消息操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> mqResult=itemService.asyncDecreaseStock(itemId,amount);</span><br><span class="line">    <span class="keyword">if</span>(!mqResult)&#123;</span><br><span class="line">        itemService.increaseStock(itemId,amount);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.MQ_SEND_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-事务型消息"><a href="#9-3-事务型消息" class="headerlink" title="9.3 事务型消息"></a>9.3 事务型消息</h3><p>上面的做法，依然不能保证万无一失。假设现在<strong>事务提交成功了</strong>，等着执行 <code>afterCommit()</code>方法，这个时候<strong>突然宕机了</strong>，那么<strong>订单已然入库，销量已然增加，</strong>但是<strong>去数据库扣减库存的这条消息</strong>却<strong>“丢失”</strong>了。这里就需要引入RocketMQ的事务型消息。</p><p>所谓事务型消息，也会被发送到消息队列里面，这条消息处于<code>prepared</code>状态，<code>broker</code>会接收到这条消息，<strong>但是不会把这条消息给消费者消费</strong>。</p><p>处于<code>prepared</code>状态的消息，会执行<code>TransactionListener</code>的<code>executeLocalTransaction()</code>方法，根据执行结果，<strong>改变事务型消息的状态，让消费端消费或是不消费</strong>。</p><p>在<code>mq.MqProducer</code>类里面新注入一个<code>TransactionMQProducer</code>类，与<code>DefaultMQProducer</code>类似，也需要设置服务器地址、命名空间等。</p><p>新建一个<code>transactionAsyncReduceStock</code>的方法，该方法使用<code>事务型消息</code>进行异步扣减库存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务型消息同步库存扣减消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transactionAsyncReduceStock</span><span class="params">(Integer userId, Integer itemId, Integer promoId, Integer amount, String stockLogId)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; bodyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    bodyMap.put(<span class="string">"itemId"</span>, itemId);</span><br><span class="line">    bodyMap.put(<span class="string">"amount"</span>, amount);</span><br><span class="line">    <span class="comment">//用于执行orderService.createOrder的传参</span></span><br><span class="line">    Map&lt;String, Object&gt; argsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    argsMap.put(<span class="string">"itemId"</span>, itemId);</span><br><span class="line">    argsMap.put(<span class="string">"amount"</span>, amount);</span><br><span class="line">    argsMap.put(<span class="string">"userId"</span>, userId);</span><br><span class="line">    argsMap.put(<span class="string">"promoId"</span>, promoId);</span><br><span class="line"></span><br><span class="line">    Message message = <span class="keyword">new</span> Message(topicName, <span class="string">"increase"</span>,</span><br><span class="line">                JSON.toJSON(bodyMap).toString().getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注意，发送的是sendMessageInTransaction</span></span><br><span class="line">        transactionMQProducer.sendMessageInTransaction(message, argsMap);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就会发送一个事务型消息到<code>broke</code>，而处于<code>prepared</code>状态的事务型消息，会执行<code>TransactionListener</code>的<code>executeLocalTransaction</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">transactionMQProducer.setTransactionListener(<span class="keyword">new</span> TransactionListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message message, Object args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在事务型消息中去进行下单</span></span><br><span class="line">    Integer itemId = (Integer) ((Map) args).get(<span class="string">"itemId"</span>);</span><br><span class="line">    Integer promoId = (Integer) ((Map) args).get(<span class="string">"promoId"</span>);</span><br><span class="line">    Integer userId = (Integer) ((Map) args).get(<span class="string">"userId"</span>);</span><br><span class="line">    Integer amount = (Integer) ((Map) args).get(<span class="string">"amount"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用下单接口</span></span><br><span class="line">        orderService.createOrder(userId, itemId, promoId, amount);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BizException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//发生异常就回滚消息</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在<strong>事务型消息中去执行下单操作，</strong>下单失败，则消息回滚，<strong>不会去数据库扣减库存</strong>。下单成功，则消息被消费，<strong>扣减数据库库存</strong>。</p><h4 id="更新下单流程"><a href="#更新下单流程" class="headerlink" title="更新下单流程"></a>更新下单流程</h4><p>之前的下单流程是：<code>OrderController</code>里面调用<code>OrderService.createOrder()</code>方法，然后在该方法最后发送了异步消息，会导致异步消息丢失的问题。所以我们引入了<strong>事务型消息</strong>。</p><p>现在的下单流程是：<code>OrderController</code>里面直接调用<code>MqProducer.transactionAsyncReduceStock()</code>方法，发送一个事务型消息，然后在<strong>事务型消息中调用<code>OrderService.createOrder()</code>方法</strong>，进行下单。</p><h3 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4 小结"></a>9.4 小结</h3><ul><li>首先解决了<strong>发送异步消息时机</strong>的问题，之前是在<code>ItemService.decreaseStock()</code>，当在Redis里面扣减成功之后，发送异步消息。这样会导致数据库回滚，但Redis无法回滚的问题。所以我们把发送异步消息提到所有下单操作操作完成之后。</li><li>其次，由于Spring的<code>@Transactional</code>标签是在方法返回之后，才提交事务，如果返回阶段出了问题，那么数据库回滚了，但是缓存的库存却扣了。所以我们使用了<code>afterCommit()</code>方法。</li><li>最后，如果在执行<code>afterCommit()</code>的时候，发生了异常，那么消息就发不出去，又会导致数据一致性问题。所以我们通过使用<strong>事务型消息</strong>，把<strong>下单操作包装在异步扣减消息里面</strong>，让下单操作和扣减消息<strong>同生共死</strong>。</li></ul><h3 id="9-5-接下来的优化方向"><a href="#9-5-接下来的优化方向" class="headerlink" title="9.5 接下来的优化方向"></a>9.5 接下来的优化方向</h3><p>上述流程还有一个漏掉，就是当执行<code>orderService.createOrder()</code>后，突然<strong>又宕机</strong>了，根本没有返回，这个时候事务型消息就会进入<code>UNKNOWN</code>状态，我们需要处理这个状态。</p><p>在匿名类<code>TransactionListener</code>里面，还需要覆写<code>checkLocalTransaction()</code>方法，这个方法就是用来处理<code>UNKNOWN</code>状态的。应该怎么处理？这需要引入<strong>库存流水</strong>。</p><h2 id="10-库存流水"><a href="#10-库存流水" class="headerlink" title="10. 库存流水"></a>10. 库存流水</h2><p>数据库新建一张<code>stock_log</code>的表，用来记录库存流水，添加一个<code>ItemService.initStockLog</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">initStockLog</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    StockLogDO stockLogDO = <span class="keyword">new</span> StockLogDO();</span><br><span class="line">    stockLogDO.setItemId(itemId);</span><br><span class="line">    stockLogDO.setAmount(amount);</span><br><span class="line">    stockLogDO.setStockLogId(UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">    <span class="comment">//1表示初始状态，2表示下单扣减库存成功，3表示下单回滚</span></span><br><span class="line">    stockLogDO.setStatus(<span class="number">1</span>);</span><br><span class="line">    stockLogDOMapper.insertSelective(stockLogDO);</span><br><span class="line">    <span class="keyword">return</span> stockLogDO.getStockLogId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户请求后端<code>OrderController.createOrder()</code>接口，我们先初始化库存流水的状态，再调用事务型消息去下单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OrderController</span></span><br><span class="line"><span class="comment">//先检验用户登录信息</span></span><br><span class="line">String token = httpServletRequest.getParameterMap().get(<span class="string">"token"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.USER_NOT_LOGIN, <span class="string">"用户还未登录，不能下单"</span>);</span><br><span class="line">&#125;</span><br><span class="line">UserModel userModel = (UserModel) redisTemplate.opsForValue().get(token);</span><br><span class="line"><span class="keyword">if</span> (userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.USER_NOT_LOGIN, <span class="string">"登录过期，请重新登录"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化库存流水</span></span><br><span class="line">String stockLogId = itemService.initStockLog(itemId, amount);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送事务型消息，完成下单逻辑</span></span><br><span class="line"><span class="keyword">if</span> (!mqProducer.transactionAsyncReduceStock(userModel.getId(), itemId, promoId, amount, stockLogId)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.UNKNOWN_ERROR, <span class="string">"下单失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务型消息会调用<code>OrderService.createOrder()</code>方法，执行Redis扣减库存、订单入库、销量增加的操作，当这些操作都完成后，就说明下单完成了，<strong>等着异步更新数据库了</strong>。那么需要修改订单流水状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OrderService.createOrder</span></span><br><span class="line"><span class="comment">//订单入库</span></span><br><span class="line">orderDOMapper.insertSelective(orderDO);</span><br><span class="line"><span class="comment">//增加销量</span></span><br><span class="line">itemService.increaseSales(itemId, amount);</span><br><span class="line">StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line"><span class="keyword">if</span> (stockLogDO == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.UNKNOWN_ERROR);</span><br><span class="line"><span class="comment">//设置库存流水状态为成功</span></span><br><span class="line">stockLogDO.setStatus(<span class="number">2</span>);</span><br><span class="line">stockLogDOMapper.updateByPrimaryKeySelective(stockLogDO);</span><br></pre></td></tr></table></figure><h3 id="10-1-下单操作的处理"><a href="#10-1-下单操作的处理" class="headerlink" title="10.1 下单操作的处理"></a>10.1 下单操作的处理</h3><p>异步更新数据库，需要事务型消息从<code>prepare</code>状态编程<code>commit</code>状态。假设此时<code>orderService。createOrder()</code> <strong>本身发生了异常</strong>，那么就回滚事务型消息，并且返回<code>LocalTransactionState.ROLLBACK_MESSAGE</code>，这个下单操作就会被取消。</p><p>如果<strong>本身没有发生异常</strong>，那么就返回<code>LocalTransactionState.COMMIT_MESSAGE</code>，此时事务型消息会从<code>prepare</code>状态变为<code>commit</code>状态，接着被消费端消费，异步扣减库存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MqProducer.TransactionListener().executeLocalTransaction()</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    orderService.createOrder(userId, itemId, promoId, amount, stockLogId);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BizException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//如果发生异常，createOrder已经回滚，此时要回滚事务型消息。</span></span><br><span class="line">    <span class="comment">//设置stockLog为回滚状态</span></span><br><span class="line">    StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line">    stockLogDO.setStatus(<span class="number">3</span>);</span><br><span class="line">    stockLogDOMapper.updateByPrimaryKeySelective(stockLogDO);</span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br></pre></td></tr></table></figure><h3 id="10-2-UNKNOWN状态处理"><a href="#10-2-UNKNOWN状态处理" class="headerlink" title="10.2 UNKNOWN状态处理"></a>10.2 UNKNOWN状态处理</h3><p>如上节结尾所述，如果在执行<code>createOrder()</code>的时候，突然宕机了，此时事务型消息的状态是<code>UNKNOWN</code>，需要在<code>TransactionListener.checkLocalTransaction()</code>方法中处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据是否扣减库存成功，来判断要返回COMMIT，ROLLBACK还是UNKNOWN</span></span><br><span class="line">    String jsonString = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">    Map&lt;String, Object&gt; map = JSON.parseObject(jsonString, Map.class);</span><br><span class="line">    String stockLogId = (String) map.get(<span class="string">"stockLogId"</span>);</span><br><span class="line">    StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line">    <span class="keyword">if</span> (stockLogDO == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    <span class="comment">//订单操作已经完成，等着异步扣减库存，那么就提交事务型消息</span></span><br><span class="line">    <span class="keyword">if</span> (stockLogDO.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    <span class="comment">//订单操作还未完成，需要执行下单操作，那么就维持为prepare状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stockLogDO.getStatus() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就回滚</span></span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-库存售罄处理"><a href="#10-3-库存售罄处理" class="headerlink" title="10.3 库存售罄处理"></a>10.3 库存售罄处理</h3><p>现在是用户请求一次<code>OrderController.createOrder()</code>就初始化一次流水，但是如果10000个用户抢10个商品，就会初始化10000次库存流水，这显然是不行的。</p><p>解决的办法是在<code>ItemService.decreaseStock()</code>中，如果库存没有了，就打上<strong>“售罄标志”</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ublic <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow = redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span> + itemId, amount.intValue() * -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (affectedRow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (affectedRow == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//打上售罄标识</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_invalid_"</span> + itemId, <span class="string">"true"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        increaseStock(itemId, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>OrderController.createOrder()</code>初始化流水之前，先判断一下是否售罄，售罄了就直接抛异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否售罄</span></span><br><span class="line"><span class="keyword">if</span> (redisTemplate.hasKey(<span class="string">"promo_item_stock_invalid_"</span>+itemId))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.STOCK_NOT_ENOUGH);</span><br><span class="line">String stockLogId = itemService.initStockLog(itemId, amount);</span><br></pre></td></tr></table></figure><h3 id="10-4-小节"><a href="#10-4-小节" class="headerlink" title="10.4 小节"></a>10.4 小节</h3><p>这一节通过引入库存流水，来记录库存的状态，以便在<strong>事务型消息处于不同状态时进行处理</strong>。</p><p>事务型消息提交后，会在<code>broker</code>里面处于<code>prepare</code>状态，也即是<code>UNKNOWN</code>状态，等待被消费端消费，或者回滚。<code>prepare</code>状态下，会执行<code>OrderService.createOrder</code>方法。</p><p>此时有两种情况：</p><ol><li><code>createOrder()</code>执行完<strong>没有宕机</strong>，要么<strong>执行成功</strong>，要么<strong>抛出异常</strong>。<strong>执行成功</strong>，那么说明下单成功了，订单入库了，Redis里的库存扣了，销量增加了，<strong>等待着异步扣减库存</strong>，所以将事务型消息的状态，从<code>UNKNOWN</code>变为<code>COMMIT</code>，这样消费端就会消费这条消息，异步扣减库存。抛出异常，那么订单入库、Redis库存、销量增加，就会被数据库回滚，此时去异步扣减的消息，就应该”丢弃”，所以发回<code>ROLLBACK</code>，进行回滚。</li><li><code>createOrder()</code>执行完<strong>宕机了</strong>，那么这条消息会是<code>UNKNOWN</code>状态，这个时候需要在<code>checkLocalTransaction</code>进行处理。如果<code>createOrder()</code>执行完毕，此时<code>stockLog.status == 2</code>，就说明下单成功，需要去异步扣减库存，所以返回<code>COMMIT</code>。如果<code>status == 1</code>，说明下单还未完成，还需要继续执行下单操作，所以返回<code>UNKNOWN</code>。如果<code>status == 3</code>，说明下单失败，需要回滚，不需要异步扣减库存，所以返回<code>ROLLBACK</code>。</li></ol><h4 id="可以改进的地方"><a href="#可以改进的地方" class="headerlink" title="可以改进的地方"></a>可以改进的地方</h4><p>目前只是扣减库存异步化，实际上销量逻辑和交易逻辑都可以异步化，这里就不赘述了。</p><h4 id="接下来的优化方向"><a href="#接下来的优化方向" class="headerlink" title="接下来的优化方向"></a>接下来的优化方向</h4><p>目前下单接口会被脚本不停的刷，影响用户的正常体验。此外，验证逻辑和下单逻辑强关联，耦合度比较高。最后，验证逻辑也比较复杂。接下来会引入流量削峰技术。</p><h2 id="11-流量削峰"><a href="#11-流量削峰" class="headerlink" title="11. 流量削峰"></a>11. 流量削峰</h2><p>秒杀秒杀，就是在活动开始的一瞬间，有大量流量涌入，优化不当，会导致服务器停滞，甚至宕机。所以引入流量削峰技术十分有必要。</p><h3 id="11-1-业务解耦——秒杀令牌"><a href="#11-1-业务解耦——秒杀令牌" class="headerlink" title="11.1 业务解耦——秒杀令牌"></a>11.1 业务解耦——秒杀令牌</h3><p>之前的<strong>验证逻辑</strong>和<strong>下单逻辑</strong>都耦合在<code>OrderService.createOrder</code>里面，现在利用秒杀令牌，使校验逻辑和下单逻辑分离。</p><p><code>PromoService</code>新开一个<code>generateSecondKillToken()</code>里面，将活动、商品、用户信息校验逻辑封装在里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSecondKillToken</span><span class="params">(Integer promoId,Integer itemId,Integer userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断库存是否售罄，若Key存在，则直接返回下单失败</span></span><br><span class="line">    <span class="keyword">if</span>(redisTemplate.hasKey(<span class="string">"promo_item_stock_invalid_"</span>+itemId))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    PromoDO promoDO=promoDOMapper.selectByPrimaryKey(promoId);</span><br><span class="line">    PromoModel promoModel=convertFromDataObj(promoDO);</span><br><span class="line">    <span class="keyword">if</span>(promoModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(promoModel.getStartDate().isAfterNow()) &#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(promoModel.getEndDate().isBeforeNow())&#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断活动是否正在进行</span></span><br><span class="line">    <span class="keyword">if</span>(promoModel.getStatus()!=<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断item信息是否存在</span></span><br><span class="line">    ItemModel itemModel=itemService.getItemByIdInCache(itemId);</span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断用户是否存在</span></span><br><span class="line">    UserModel userModel=userService.getUserByIdInCache(userId);</span><br><span class="line">    <span class="keyword">if</span>(userModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//生成Token，并且存入redis内，5分钟时限</span></span><br><span class="line">    String token= UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_token_"</span>+promoId+<span class="string">"_userid_"</span>+userId+<span class="string">"_itemid_"</span>+itemId,token);</span><br><span class="line">    redisTemplate.expire(<span class="string">"promo_token_"</span>+promoId+<span class="string">"_userid_"</span>+userId+<span class="string">"_itemid_"</span>+itemId, <span class="number">5</span>,TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>OrderService.createOrder</code>的校验逻辑就可以删掉了。</p><p><code>OrderController</code>新开了一个<code>generateToken()</code>接口，以便前端请求时，返回令牌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/generatetoken"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">generateToken</span><span class="params">(···)</span> <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">    <span class="comment">//用户登录状态校验</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//获取秒杀访问令牌</span></span><br><span class="line">    String promoToken = promoService.generateSecondKillToken(promoId, itemId, userModel.getId());</span><br><span class="line">    <span class="keyword">if</span> (promoToken == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"生成令牌失败"</span>);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(promoToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端在点击<strong>“下单”</strong>后，首先会请求<code>generateToken()</code>接口，返回秒杀令牌。然后将秒杀令牌<code>promoToken</code>作为参数，再去请求后端<code>createOrder()</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/createorder"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">createOrder</span><span class="params">(··· @RequestParam(name = <span class="string">"promoToken"</span>, required = <span class="keyword">false</span>)</span> String promoToken) <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//校验秒杀令牌是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (promoId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String inRedisPromoToken = (String) redisTemplate.opsForValue().</span><br><span class="line">                    get(<span class="string">"promo_token_"</span> + promoId + <span class="string">"_userid_"</span> + userModel.getId() + <span class="string">"_itemid_"</span> + itemId);</span><br><span class="line">    <span class="keyword">if</span> (inRedisPromoToken == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"令牌校验失败"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.equals(promoToken, inRedisPromoToken)) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"令牌校验失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就彻底完成了校验逻辑和下单逻辑的分离。现在的问题是，假设有1E个用户请求下单，那么就会生成1E的令牌，这是十分消耗性能的，所以接下来引入<strong>秒杀大闸进行限流</strong>.</p><h3 id="11-2-限流——令牌大闸"><a href="#11-2-限流——令牌大闸" class="headerlink" title="11.2 限流——令牌大闸"></a>11.2 限流——令牌大闸</h3><p>大闸的意思就是<strong>令牌的数量是有限的</strong>，当令牌用完时，就不再发放令牌了，那么下单将无法进行。之前我们通过<code>PromoService.publishPromo()</code>将库存发布到了Redis上，现在我们将令牌总数也发布到Redis上，这里我们设定令牌总量是库存的5倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishPromo</span><span class="params">(Integer promoId)</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//库存同步到Redis</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_"</span> + itemModel.getId(), itemModel.getStock());</span><br><span class="line">    <span class="comment">//大闸限制数量设置到redis内</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_door_count_"</span> + promoId, itemModel.getStock().intValue() * <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，在<code>PromoService.generateSecondKillToken()</code>方法中，在生成令牌之前，首先将Redis里的令牌总量减1，然后再判断是否剩余，如果 &lt;0，直接返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取大闸数量</span></span><br><span class="line"><span class="keyword">long</span> result = redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_door_count_"</span> + promoId, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (result &lt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//令牌生成</span></span><br></pre></td></tr></table></figure><p>这样，当令牌总量为0时，就不再发放令牌了，也就无法下单了。</p><h4 id="令牌大闸限流缺点"><a href="#令牌大闸限流缺点" class="headerlink" title="令牌大闸限流缺点"></a>令牌大闸限流缺点</h4><p>当商品种类少、库存少的时候，令牌大闸效果还不错。但是一旦参与活动的商品库存太大，比如1W个，那么一秒钟也有上十万的流量涌入，限制能力是很弱的。所以需要<strong>队列泄洪</strong>。</p><h3 id="11-3-限流——队列泄洪"><a href="#11-3-限流——队列泄洪" class="headerlink" title="11.3 限流——队列泄洪"></a>11.3 限流——队列泄洪</h3><p>队列泄洪，就是让多余的请求<strong>排队等待</strong>。<strong>排队</strong>有时候比<strong>多线程</strong>并发效率更高，多线程毕竟有锁的竞争、上下文的切换，很消耗性能。而排队是无锁的，单线程的，某些情况下效率更高。</p><p>比如Redis就是<strong>单线程模型</strong>，多个用户同时执行<code>set</code>操作，只能一一等待。</p><p>比如MySQL的<code>insert</code>和<code>update</code>语句，会维护一个行锁。阿里SQL就不会，而是让多个SQL语句排队，然后依次执行。</p><p>像支付宝就使用了队列泄洪，双十一的时候，支付宝作为网络科技公司，可以承受很高的TPS，但是下游的各个银行，无法承受这么高的TPS。支付宝维护了一个”拥塞窗口”，慢慢地向下游银行发送流量，保护下游。</p><p>那对于我们的项目，什么时候引入”队列泄洪”呢？在<code>OrderController</code>里面，之前拿到秒杀令牌后，就要开始执行下单的业务了。现在我们把<strong>下单业务</strong>封装到一个<strong>固定大小的线程池中，</strong>一次<strong>只处理固定大小的请求</strong>。</p><p>在<code>OrderController</code>里面引入<code>j.u.c.ExecutorService</code>，创建了一个<code>init</code>方法，初始化线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//20个线程的线程池</span></span><br><span class="line">    executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在拿到秒杀令牌后，使用线程池来处理下单请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String stockLogId = itemService.initStockLog(itemId, amount);</span><br><span class="line">        <span class="keyword">if</span> (!mqProducer.transactionAsyncReduceStock(userModel.getId(), itemId, promoId, amount, stockLogId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.UNKNOWN_ERROR, <span class="string">"下单失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就算转瞬间涌入再多流量，得到处理的也就20个，其他全部等待。</p><h3 id="11-4-小结"><a href="#11-4-小结" class="headerlink" title="11.4 小结"></a>11.4 小结</h3><p>这一章我们</p><ul><li>使用秒杀令牌，实现了校验业务和下单业务的分离。同时为秒杀大闸做了铺垫</li><li>使用秒杀大闸，实现了限流的第一步，限制了流量的总量</li><li>使用队列泄洪，实现了限流的第二步，同一时间只有部分请求得到处理。</li></ul><h3 id="11-5-接下来的优化方向"><a href="#11-5-接下来的优化方向" class="headerlink" title="11.5 接下来的优化方向"></a>11.5 接下来的优化方向</h3><p>接下来会引入防刷限流技术，比如验证码技术等。</p><h2 id="12-防刷限流"><a href="#12-防刷限流" class="headerlink" title="12. 防刷限流"></a>12. 防刷限流</h2><h3 id="12-1-验证码技术"><a href="#12-1-验证码技术" class="headerlink" title="12.1 验证码技术"></a>12.1 验证码技术</h3><p>之前的流程是，用户点击下单后，会直接拿到令牌然后执行下单流程。现在，用户点击下单后，前端会弹出一个”验证码“，用户输入之后，才能请求下单接口。</p><p><code>OrderController</code>新开一个<code>generateVerifyCode()</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/generateverifycode"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateVerifyCode</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> BizException, IOException </span>&#123;</span><br><span class="line">    ···验证</span><br><span class="line">    <span class="comment">//验证用户信息</span></span><br><span class="line">    Map&lt;String, Object&gt; map = CodeUtil.generateCodeAndPic();</span><br><span class="line">    <span class="comment">//生成的验证码存到Redis里，并设置过期时间</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"verify_code_"</span> + userModel.getId(), map.get(<span class="string">"code"</span>));</span><br><span class="line">    redisTemplate.expire(<span class="string">"verify_code_"</span> + userModel.getId(), <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//生成的图片，响应到前端页面</span></span><br><span class="line">    ImageIO.write((RenderedImage) map.get(<span class="string">"codePic"</span>), <span class="string">"jpeg"</span>, response.getOutputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前获取秒杀令牌的<code>generateToken()</code>接口，需要添加验证码校验逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">generateToken</span><span class="params">(··· @RequestParam(name = <span class="string">"verifyCode"</span>)</span> String verifyCode) <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">    <span class="comment">//验证用户登录信息</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//验证验证码的有效性</span></span><br><span class="line">    String redisVerifyCode = (String) redisTemplate.opsForValue().get(<span class="string">"verify_code_"</span> + userModel.getId());</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(redisVerifyCode))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"请求非法"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!redisVerifyCode.equalsIgnoreCase(verifyCode))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, <span class="string">"请求非法"</span>);</span><br><span class="line">    <span class="comment">//获取秒杀访问令牌</span></span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就实现了在下单之前，添加一个验证码，限制部分流量的功能。</p><h3 id="12-2-限流方案——限并发"><a href="#12-2-限流方案——限并发" class="headerlink" title="12.2 限流方案——限并发"></a>12.2 限流方案——限并发</h3><p>限制并发量意思就是同一时间<strong>只有一定数量的线程去处理请求</strong>，实现也比较简单，维护一个<strong>全局计数器</strong>，当请求进入接口时，计数器-1，并且判断计数器是否&gt;0，大于0则处理请求，小于0则拒绝等待。</p><p>但是一般衡量并发性，是用TPS或者QPS，而该方案由于限制了线程数，自然不能用TPS或者QPS衡量。</p><h3 id="12-3-限流方案——令牌桶-漏桶"><a href="#12-3-限流方案——令牌桶-漏桶" class="headerlink" title="12.3 限流方案——令牌桶/漏桶"></a>12.3 限流方案——令牌桶/漏桶</h3><h4 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h4><p>客户端请求接口，必须先从令牌桶中获取令牌，令牌是由一个”定时器“定期填充的。在一个时间内，令牌的数量是有限的。令牌桶的大小为100，那么TPS就为100。</p><p><img src="https://raw.githubusercontent.com/MaJesTySA/miaosha_Shop/master/imgs/tokenBucket.png" alt></p><h4 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h4><p>客户端请求接口，会向漏桶里面”加水“。漏桶每秒漏出一定数量的”水“，也就是处理请求。只有当漏桶不满时，才能请求。</p><p><img src="https://raw.githubusercontent.com/MaJesTySA/miaosha_Shop/master/imgs/leekBucket.png" alt></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>漏桶无法应对<strong>突发流量</strong>，比如突然来10个请求，只能处理一个。但是令牌桶，可以一次性处理10个。所以令牌桶用得比较多。</p><h3 id="12-4-限流力度"><a href="#12-4-限流力度" class="headerlink" title="12.4 限流力度"></a>12.4 限流力度</h3><p>分为<strong>接口维度</strong>和<strong>总维度</strong>，很好理解。接口维度就是限制某个接口的流量，而总维度是限制所有接口的流量。</p><h3 id="12-5-限流范围"><a href="#12-5-限流范围" class="headerlink" title="12.5 限流范围"></a>12.5 限流范围</h3><p>分为<strong>集群限流</strong>和<strong>单机限流</strong>，集群限流顾名思义就是限制整个集群的流量，需要用Redis或者其他中间件技术来做统一计数器，往往会产生性能瓶颈。单机限流在负载均衡的前提下效果更好。</p><h3 id="12-6-RateLimiter限流实现"><a href="#12-6-RateLimiter限流实现" class="headerlink" title="12.6 RateLimiter限流实现"></a>12.6 RateLimiter限流实现</h3><p><code>google.guava.RateLimiter</code>就是令牌桶算法的一个实现类，<code>OrderController</code>引入这个类，在<code>init</code>方法里面，初始令牌数量为200。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//20个线程的线程池</span></span><br><span class="line">    executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//200个令牌，即200TPS</span></span><br><span class="line">    orderCreateRateLimiter = RateLimiter.create(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求<code>createOrder()</code>接口之前，会调用<code>RateLimiter.tryAcquire()</code>方法，看当前令牌是否足够，不够直接抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f (!orderCreateRateLimiter.tryAcquire())</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.RATELIMIT);</span><br></pre></td></tr></table></figure><h3 id="12-7-防刷技术"><a href="#12-7-防刷技术" class="headerlink" title="12.7 防刷技术"></a>12.7 防刷技术</h3><p>排队、限流、令牌只能控制总流量，无法控制黄牛流量。</p><h4 id="传统防刷技术"><a href="#传统防刷技术" class="headerlink" title="传统防刷技术"></a>传统防刷技术</h4><ul><li>限制一个会话(Session、Token)一定时间内请求接口的次数。多会话接入绕开无效，比如黄牛可以开启多个会话。</li><li>限制一个IP一定时间内请求接口的次数。容易误伤，某个局域网内的正常用户共享一个IP进行访问。而且IP可以被伪造。</li></ul><h4 id="黄牛为什么难防"><a href="#黄牛为什么难防" class="headerlink" title="黄牛为什么难防"></a>黄牛为什么难防</h4><ul><li>模拟硬件设备，比如手机。一个看似正常的用户，可能是用模拟器模拟出来的。</li><li>设备牧场，一屋子手机刷接口</li><li>人工作弊，这个最难防，情真人刷接口</li></ul><h4 id="防黄牛方案"><a href="#防黄牛方案" class="headerlink" title="防黄牛方案"></a>防黄牛方案</h4><ul><li><strong>设备指纹方式：</strong>采集终端设备各项数据，启动应用时生成一个唯一设备指纹。根据对应设备的指纹参数，估计是可疑设备的概率。</li><li><strong>凭证系统：</strong>根据设备指纹下发凭证，在关键业务链路上带上凭证并有凭证服务器验证。凭证服务器根据设备指纹参数和风控系统判断凭证的可疑程度。若凭证分数低于设定值，则开启验证</li></ul><h3 id="12-8-小结"><a href="#12-8-小结" class="headerlink" title="12.8 小结"></a>12.8 小结</h3><ul><li>通过引入验证码技术，在发送秒杀令牌之前，再做一层限流</li><li>介绍了三种限流方案，使用<code>RateLimiter</code>实现了令牌桶限流</li><li>介绍了常见的防刷技术以及它们的缺点。介绍了黄牛为什么难防，应该怎样防。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-业务&quot;&gt;&lt;a href=&quot;#1-业务&quot; class=&quot;headerlink&quot; title=&quot;1.业务&quot;&gt;&lt;/a&gt;1.业务&lt;/h2&gt;&lt;h3 id=&quot;用户业务：&quot;&gt;&lt;a href=&quot;#用户业务：&quot; class=&quot;headerlink&quot; title=&quot;用户业务：&quot;&gt;&lt;/a&gt;用户业务：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;短信发送业务&lt;/li&gt;
&lt;li&gt;注册业务&lt;/li&gt;
&lt;li&gt;登录业务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;商品业务：&quot;&gt;&lt;a href=&quot;#商品业务：&quot; class=&quot;headerlink&quot; title=&quot;商品业务：&quot;&gt;&lt;/a&gt;商品业务：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;查询商品&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;交易业务：&quot;&gt;&lt;a href=&quot;#交易业务：&quot; class=&quot;headerlink&quot; title=&quot;交易业务：&quot;&gt;&lt;/a&gt;交易业务：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;下单业务&lt;/li&gt;
&lt;li&gt;订单ID的生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;秒杀业务：&quot;&gt;&lt;a href=&quot;#秒杀业务：&quot; class=&quot;headerlink&quot; title=&quot;秒杀业务：&quot;&gt;&lt;/a&gt;秒杀业务：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;活动商品下单业务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://2.bp.blogspot.com/-Sl6wdO704eo/Tbl_cbCIAbI/AAAAAAAACFw/nlP414H6CLo/s1600/96d8e440a7dd5501977e686709a8ee60.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="秒杀系统" scheme="http://yoursite.com/tags/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux 五种IO模型</title>
    <link href="http://yoursite.com/2020/03/25/Linux%20%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/03/25/Linux 五种IO模型/</id>
    <published>2020-03-24T16:00:00.000Z</published>
    <updated>2020-03-25T11:15:14.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念说明"><a href="#1-概念说明" class="headerlink" title="1. 概念说明"></a>1. 概念说明</h2><p>在进行解释前，首先说明几个概念：</p><blockquote><p>用户空间和内核空间</p><p>进程切换</p><p>进程的阻塞</p><p>文件描述符</p><p>缓存IO</p></blockquote><h3 id="1-1-用户空间和内核空间"><a href="#1-1-用户空间和内核空间" class="headerlink" title="1.1 用户空间和内核空间"></a>1.1 用户空间和内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对于32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。<strong>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限</strong>。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，<strong>操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</strong>针对linux操作系统而言，将最高的1G字节（从虚拟地址<code>0xC0000000</code>到<code>0xFFFFFFF</code>），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址<code>0x00000000</code>到<code>0xBFFFFFFF</code>），供各个进程使用，称为用户空间。</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1920x1200c5/g5/M00/01/04/ChMkJlg2YRGIXrtCABy9qCTYS60AAYB1AAAAAAAHL3A605.png" alt><br><a id="more"></a></p><h3 id="1-2-进程切换"><a href="#1-2-进程切换" class="headerlink" title="1.2 进程切换"></a>1.2 进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><blockquote><ol><li>保存处理机上下文，包括程序计数器和其他寄存器</li><li>更新PCB（<code>Process Control Block</code> 进程处理块）信息</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列</li><li>选择另一个进程执行，并更新其PCB</li><li>更新内存管理的数据结构</li><li>恢复处理机上下文</li></ol></blockquote><p>注：总而言之就是很耗资源</p><h3 id="1-3-进程的阻塞"><a href="#1-3-进程的阻塞" class="headerlink" title="1.3 进程的阻塞"></a>1.3 进程的阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达</p><p>或无新工作做等，则由系统自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种自主行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p><h3 id="1-4-文件描述符fd"><a href="#1-4-文件描述符fd" class="headerlink" title="1.4 文件描述符fd"></a>1.4 文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，<strong>是一个用于表述指向文件的引用的抽象化概念</strong>。</p><p>文件描述符在形式上是一个非负整数。实际上，<strong>它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h3 id="1-5-缓存IO"><a href="#1-5-缓存IO" class="headerlink" title="1.5 缓存IO"></a>1.5 缓存IO</h3><p><strong>缓存IO又被称为标准IO，大多数文件系统的默认IO操作都是缓存IO</strong>。在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存（page cache）中，也就是说， <strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。</p><p><strong>缓存IO的缺点：</strong></p><p><strong>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作</strong>，这些数据拷贝带来的CPU以及内存开销是非常大的。</p><h2 id="2-Linux-IO模型"><a href="#2-Linux-IO模型" class="headerlink" title="2.Linux IO模型"></a>2.Linux IO模型</h2><p><strong>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作</strong>。刚才说了，对于一次IO访问（以read举例），<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。所以说，当一个read操作发生时，它会经历两个阶段：</p><blockquote><ol><li>第一阶段：等待数据准备</li><li>第二阶段：将数据从内核拷贝到进程中</li></ol></blockquote><p>对于socket流而言，</p><blockquote><ol><li>第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区</li><li>第二步：把数据从内核缓冲区复制到应用进程缓冲区</li></ol></blockquote><p>网络应用需要处理的无非就是两大类问题：<strong>网络IO、数据计算</strong>。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。网络IO的模型大致有如下几种：</p><blockquote><ul><li>同步模型（synchronous IO）</li><li>阻塞IO (blocking IO )</li><li>非阻塞IO（non-blocking IO）</li><li>多路复用IO（multiplexing IO）</li><li>信号驱动式IO（signal-driven IO）</li><li>异步IO（asynchronous IO）</li></ul></blockquote><p><strong>注：由于signal driven  IO在实际中并不常用，所以下面只提及剩下的四种IO模型</strong>。</p><p>在深入介绍Linux IO各种模型之前，让我们先来探索一下基本 Linux IO 模型的简单矩阵。如下图所示：</p><p><img src="https://static.oschina.net/uploads/img/201604/20144245_Wtld.png" alt></p><p>每个 IO 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。本节将简要对其一一进行介绍。<strong>常见的IO模型有阻塞、非阻塞、IO多路复用，异步</strong>。以一个生动形象的例子来说明这四个概念。周末我和女友去逛街，中午饿了，我们准备去吃饭。周末人多，吃饭需要排队，我和女友有以下几种方案。</p><h3 id="2-1-同步阻塞IO（blocking-IO）"><a href="#2-1-同步阻塞IO（blocking-IO）" class="headerlink" title="2.1 同步阻塞IO（blocking IO）"></a>2.1 同步阻塞IO（blocking IO）</h3><h4 id="2-1-1-场景描述"><a href="#2-1-1-场景描述" class="headerlink" title="2.1.1 场景描述"></a>2.1.1 场景描述</h4><blockquote><p>我和女友点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。女友本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。<strong>这就是典型的阻塞</strong>。</p></blockquote><h4 id="2-1-2-网络模型"><a href="#2-1-2-网络模型" class="headerlink" title="2.1.2 网络模型"></a>2.1.2 网络模型</h4><p><strong>同步阻塞IO模型是最常用的一个模型，也是最简单的模型</strong>。在linux中，<strong>默认情况下所有的socket都是blocking</strong>。它最符合人们最常见的逻辑。<strong>阻塞就是进程”被”休息，CPU处理其他进程去了</strong>。</p><p>在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，<strong>在等待数据到处理数据的两个阶段，</strong>整个进程都被阻塞，不能处理别的网络IO。<strong>调用应用程序处于一种不再消费CPU，而只是简单等待响应的状态</strong>，因此从处理的角度看，这是非常有效的。在调用recv()/recvfrom()函数时，发生在内核中等待数据和复制数据的过程，大致如下图：</p><p><img src="https://static.oschina.net/uploads/img/201604/20150405_VKYH.png" alt></p><h4 id="2-1-3-流程描述"><a href="#2-1-3-流程描述" class="headerlink" title="2.1.3 流程描述"></a>2.1.3 流程描述</h4><p>当用户进程调用了recv()/recvfrom()这个系统调用，<strong>kernel就开始了IO的第一个阶段：准备数据</strong>对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。<strong>第二个阶段：当kernel一只等到数据准备好了，它就会把数据从kernel拷贝到用户内存</strong>，然后kernel返回结果，用户进程才能解除blocking的状态，重新运行起来。</p><blockquote><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了</p></blockquote><p>优点:</p><blockquote><ol><li>能够及时返回数据，无延迟</li><li>对内核开发者来说这是省钱了</li></ol></blockquote><p>缺点：</p><blockquote><ol><li>对用来说处于等待就要付出性能的代价了</li></ol></blockquote><h3 id="2-同步非阻塞IO（nonblocking-IO）"><a href="#2-同步非阻塞IO（nonblocking-IO）" class="headerlink" title="2.同步非阻塞IO（nonblocking IO）"></a>2.同步非阻塞IO（nonblocking IO）</h3><h4 id="2-2-1-场景描述"><a href="#2-2-1-场景描述" class="headerlink" title="2.2.1 场景描述"></a>2.2.1 场景描述</h4><blockquote><p>我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。<strong>这就是非阻塞</strong>。需要不断的询问，是否准备好了。</p></blockquote><h4 id="2-2-2-网络模型"><a href="#2-2-2-网络模型" class="headerlink" title="2.2.2 网络模型"></a>2.2.2 网络模型</h4><p><strong>同步非阻塞就是”每隔一会儿瞄一眼进度条”的轮询（polling）方式</strong>。在这种模型中，<strong>设备是以非阻塞的形式打开的</strong>。这意味着 IO 操作不会立即完成，read 操作可能会返回一个错误代码，说明这个命令不能立即满足（EAGAIN 或 EWOULDBLOCK）。</p><p>在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。</p><p><strong>也就是说非阻塞的recvform系统调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error</strong>。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。 重复上面的过程，循环往复的进行recvform系统调用。<strong>这个过程通常被称之为轮询</strong>。轮询检查内核数据，知道数据准备好，再拷贝到进程，进行数据处理。<strong>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态</strong>。</p><p>在linux下，可以通过设置socket使其变为non-blocking。<strong>当对一个non-blocking socket执行读操作时</strong>，流程如图所示：</p><p><img src="https://static.oschina.net/uploads/img/201604/20152818_DXcj.png" alt></p><h4 id="2-2-3-流程描述"><a href="#2-2-3-流程描述" class="headerlink" title="2.2.3 流程描述"></a>2.2.3 流程描述</h4><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><blockquote><p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p></blockquote><p><strong>同步非阻塞方式相比同步阻塞方式：</strong></p><blockquote><p>优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。</p><p>缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</p></blockquote><h3 id="2-3-IO多路复用（IO-multiplexing）"><a href="#2-3-IO多路复用（IO-multiplexing）" class="headerlink" title="2.3 IO多路复用（IO multiplexing）"></a>2.3 IO多路复用（IO multiplexing）</h3><h4 id="2-3-1-场景描述"><a href="#2-3-1-场景描述" class="headerlink" title="2.3.1 场景描述"></a>2.3.1 场景描述</h4><blockquote><p>与第二个方案差不多，餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，<strong>这就是典型的IO多路复用</strong>。</p></blockquote><h4 id="2-3-2-网络模型"><a href="#2-3-2-网络模型" class="headerlink" title="2.3.2 网络模型"></a>2.3.2 网络模型</h4><p>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。<strong>那么这就是所谓的”IO多路复用“</strong>。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。</p><p><strong>IO多路复用有几个特别的系统调用select、poll、epoll、函数</strong>。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于——<strong>前者可以等待多个socket，能实现同时对多个IO端口进行监听</strong>，当其中任何一个socket的数据准备好了，<strong>就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。</strong>select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，<strong>此时的select不是等到socket数据全部到达再处理，而是有了一部分数据就会调用用户进程来处理</strong>。如何知道有一部分数据到达了呢？<strong>监视的事情交给了内核，内核负责数据到达的处理。也可以理解为”非阻塞”吧</strong>。</p><p><strong>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作</strong>。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p><p>对于多路复用，也就是轮询多个socket。<strong>多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了</strong>，当然也可以针对不同的编号。具体流程，如下图所示：</p><p><img src="https://static.oschina.net/uploads/img/201604/20164149_LD8E.png" alt></p><h4 id="2-3-3-流程描述"><a href="#2-3-3-流程描述" class="headerlink" title="2.3.3 流程描述"></a>2.3.3 流程描述</h4><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为<code>event driven IO。</code> <strong>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO</strong>。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p><strong>当用户进程调用了select，那么整个进程会被block</strong>，而同时，kernel会“监视”所有select负责的socket，<strong>当任何一个socket中的数据准备好了，select就会返回</strong>。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><blockquote><p>多路复用的特点是<strong>通过一种机制一个进程能同时等待多个IO文件描述符</strong>，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。</p></blockquote><p>上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。<strong>因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)</strong>。但是，<strong>用select的优势在于它可以同时处理多个connection</strong>。</p><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p><p>在IO multiplexing Model中，<strong>实际中，对于每一个socket，一般都设置成为non-blocking</strong>，但是，如上图所示，整个用户的process其实是一直被block的。<strong>只不过process是被select这个函数block，而不是被socket IO给block</strong>。所以<strong>IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</strong></p><p>在I/O编程过程中，<strong>当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理</strong>。I/O多路复用技术<strong>通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求</strong>。与传统的多线程/多进程模型比，<strong>I/O多路复用的最大优势是系统开销小</strong>，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源，I/O多路复用的主要应用场景如下：</p><blockquote><p>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</p><p>服务器需要同时处理多种网络协议的套接字。</p></blockquote><p>了解了前面三种IO模式，在用户进程进行系统调用的时候，<strong>它们在等待数据到来的时候，处理的方式不一样，直接等待、轮询、select或poll轮询</strong>，两个阶段过程：</p><blockquote><p>第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。</p><p>第二个阶段都是阻塞的。</p></blockquote><p><strong>从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态。（重要！！！）</strong></p><p><strong>高并发的程序一般使用同步非阻塞方式而非多线程+同步阻塞方式</strong>。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，<strong>办事大厅里的人数就是并发数，而窗口个数就是并行度</strong>。也就是说<strong>并发数是指同时进行的任务数（如同时服务的Http请求），而并行数是可以同时工作的物理资源数量（如CPU核数）</strong>。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。<strong>而同步非阻塞方式可以把多个IO请求丢到后台去，这就可以在一个进程里服务大量的并发IO请求</strong>。</p><p><strong>注意：IO多路复用是同步阻塞模型还是异步阻塞模型，在此给大家分析下：</strong></p><blockquote><p>此处仍然不太清楚的，强烈建议大家再细究<a href="https://link.jianshu.com/?t=http://my.oschina.net/xianggao/blog/661085" target="_blank" rel="noopener">《聊聊同步、异步、阻塞与非阻塞》</a>中讲同步与异步的根本性区别，<strong>同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程为阻塞。</strong>所以，<strong>把IO多路复用归为同步阻塞模式</strong>。</p></blockquote><h3 id="2-4-信号驱动式IO（signal-driven-IO）"><a href="#2-4-信号驱动式IO（signal-driven-IO）" class="headerlink" title="2.4 信号驱动式IO（signal-driven IO）"></a>2.4 信号驱动式IO（signal-driven IO）</h3><p>信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。过程如下图所示：</p><p><img src="https://static.oschina.net/uploads/img/201604/21091434_DsZb.png" alt></p><h3 id="2-5-异步非阻塞IO-asynchronous-IO"><a href="#2-5-异步非阻塞IO-asynchronous-IO" class="headerlink" title="2.5 异步非阻塞IO(asynchronous IO)"></a>2.5 异步非阻塞IO(asynchronous IO)</h3><h4 id="2-5-1-场景描述"><a href="#2-5-1-场景描述" class="headerlink" title="2.5.1 场景描述"></a>2.5.1 场景描述</h4><blockquote><p>女友不想逛街，又嫌餐厅太吵了，回家好好休息一下。于是我们叫外卖，打个电话点餐，然后我和女友可以在家好好休息一下，饭好了送货员送到家里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了。</p></blockquote><h4 id="2-5-2-网络模型"><a href="#2-5-2-网络模型" class="headerlink" title="2.5.2 网络模型"></a>2.5.2 网络模型</h4><p>相对于同步IO，异步IO不是顺序执行。<strong>用户进程进行aio_read系统调用后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。</strong>等到socket数据准备好了，内核直接复制数据给进程，<strong>然后从内核向进程发送通知，IO的两个阶段，进程都是非阻塞的。</strong></p><p>Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示：</p><p><img src="https://static.oschina.net/uploads/img/201604/20175459_gtgw.png" alt></p><h4 id="2-5-3-流程描述"><a href="#2-5-3-流程描述" class="headerlink" title="2.5.3 流程描述"></a>2.5.3 流程描述</h4><p>用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，<strong>首先它会立刻返回，所以不会对用户进程产生任何block</strong>。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，<strong>当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次IO处理过程</strong>，告诉他read操作完成了。</p><p><strong>在 Linux 中，通知的方式是 “信号”：</strong></p><blockquote><p><strong>如果这个进程正在用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数</strong>，这个函数可以决定何时以及如何处理这个异步任务。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，<strong>一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事</strong>。</p><p><strong>如果这个进程正在内核态忙着做别的事</strong>，例如以同步阻塞方式读写磁盘，<strong>那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知</strong>。</p><p><strong>如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒</strong>，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。</p></blockquote><p>异步 API 说来轻巧，做来难，这主要是对 API 的实现者而言的。Linux 的异步 IO（AIO）支持是 2.6.22 才引入的，还有很多系统调用不支持异步 IO。Linux 的异步 IO 最初是为数据库设计的，<strong>因此通过异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制</strong>。</p><p><strong>很多人把 Linux 的 O_NONBLOCK 认为是异步方式，但事实上这是前面讲的同步非阻塞方式。</strong>需要指出的是，虽然 Linux 上的 IO API 略显粗糙，但每种编程框架都有封装好的异步 IO 实现。操作系统少做事，把更多的自由留给用户，正是 UNIX 的设计哲学，也是 Linux 上编程框架百花齐放的一个原因。</p><p>从前面 IO 模型的分类中，我们可以看出 AIO 的动机</p><blockquote><p>同步阻塞模型需要在 IO 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 IO 操作。</p><p>同步非阻塞模型允许处理和 IO 操作重叠进行，但是这需要应用程序根据重现的规则来检查 IO 操作的状态。</p><p>这样就剩下异步非阻塞 IO 了，它允许处理和 IO 操作重叠进行，包括 IO 操作完成的通知</p></blockquote><p>IO多路复用除了需要阻塞之外，<strong>select 函数所提供的功能（异步阻塞 IO）与 AIO 类似</strong>。不过，<strong>它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞</strong>。</p><h3 id="2-6-异步阻塞"><a href="#2-6-异步阻塞" class="headerlink" title="2.6 异步阻塞"></a>2.6 异步阻塞</h3><p>有时我们的 API 只提供异步通知方式，例如在 node.js 里，<strong>但业务逻辑需要的是做完一件事后做另一件事</strong>，例如数据库连接初始化后才能开始接受用户的 HTTP 请求。这样的业务逻辑就需要调用者是以阻塞方式来工作。</p><p><strong>另外一种使用阻塞方式的理由是降低响应延迟</strong>。如果采用非阻塞方式，一个任务 A 被提交到后台，就开始做另一件事 B，但 B 还没做完，A 就完成了，这时要想让 A 的完成事件被尽快处理（比如 A 是个紧急事务），要么丢弃做到一半的 B，要么保存 B 的中间状态并切换回 A，任务的切换是需要时间的（不管是从磁盘载入到内存，还是从内存载入到高速缓存），这势必降低 A 的响应速度。<strong>因此，对实时系统或者延迟敏感的事务，有时采用阻塞方式比非阻塞方式更好</strong>。</p><h2 id="3-五种IO模型总结"><a href="#3-五种IO模型总结" class="headerlink" title="3. 五种IO模型总结"></a>3. 五种IO模型总结</h2><h3 id="3-1-blocking和non-blocking-区别"><a href="#3-1-blocking和non-blocking-区别" class="headerlink" title="3.1 blocking和non-blocking 区别"></a>3.1 blocking和non-blocking 区别</h3><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><h3 id="3-2-synchronousIO-和-asynchronous-IO区别"><a href="#3-2-synchronousIO-和-asynchronous-IO区别" class="headerlink" title="3.2 synchronousIO 和 asynchronous IO区别"></a>3.2 synchronousIO 和 asynchronous IO区别</h3><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p><blockquote><p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p><p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p></blockquote><p><strong>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞</strong>。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p><p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，<strong>定义中所指的”IO operation”是指真实的IO操作</strong>，就是例子中的recvfrom这个system call。nonblocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，<strong>当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了</strong>，在这段时间内，进程是被block的。</p><p>而asynchronous IO则不一样，<strong>当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成</strong>。在这整个过程中，进程完全没有被block。</p><p><strong>各个IO Model的比较如图所示：</strong></p><p><img src="https://static.oschina.net/uploads/img/201604/21095604_vhHX.png" alt></p><p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。<strong>在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check</strong>，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。<strong>它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知</strong>。在此期间，<strong>用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概念说明&quot;&gt;&lt;a href=&quot;#1-概念说明&quot; class=&quot;headerlink&quot; title=&quot;1. 概念说明&quot;&gt;&lt;/a&gt;1. 概念说明&lt;/h2&gt;&lt;p&gt;在进行解释前，首先说明几个概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用户空间和内核空间&lt;/p&gt;
&lt;p&gt;进程切换&lt;/p&gt;
&lt;p&gt;进程的阻塞&lt;/p&gt;
&lt;p&gt;文件描述符&lt;/p&gt;
&lt;p&gt;缓存IO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-1-用户空间和内核空间&quot;&gt;&lt;a href=&quot;#1-1-用户空间和内核空间&quot; class=&quot;headerlink&quot; title=&quot;1.1 用户空间和内核空间&quot;&gt;&lt;/a&gt;1.1 用户空间和内核空间&lt;/h3&gt;&lt;p&gt;现在操作系统都是采用虚拟存储器，那么对于32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。&lt;strong&gt;操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限&lt;/strong&gt;。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，&lt;strong&gt;操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。&lt;/strong&gt;针对linux操作系统而言，将最高的1G字节（从虚拟地址&lt;code&gt;0xC0000000&lt;/code&gt;到&lt;code&gt;0xFFFFFFF&lt;/code&gt;），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址&lt;code&gt;0x00000000&lt;/code&gt;到&lt;code&gt;0xBFFFFFFF&lt;/code&gt;），供各个进程使用，称为用户空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1920x1200c5/g5/M00/01/04/ChMkJlg2YRGIXrtCABy9qCTYS60AAYB1AAAAAAAHL3A605.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程状态及切换</title>
    <link href="http://yoursite.com/2020/03/24/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%88%87%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/03/24/Java线程状态及切换/</id>
    <published>2020-03-23T16:00:00.000Z</published>
    <updated>2020-03-23T16:03:39.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、线程的几个重要方法"><a href="#一、线程的几个重要方法" class="headerlink" title="一、线程的几个重要方法"></a>一、线程的几个重要方法</h2><ul><li>start()方法，开始执行该线程</li><li>stop()方法，强制结束该线程执行</li><li>join()方法，等待该线程结束</li><li>sleep()方法，线程进入等待</li><li>run()方法，直接执行线程的run()方法，但是线程调用start()方法时也会运行run()方法，区别就是一个是由线程调度运行run()方法，一个是直接调用了线程中的run()方法</li></ul><p><img src="http://pic1.win4000.com/wallpaper/0/57f86946b178d.jpg" alt><br><a id="more"></a></p><p>至于wait()和notify()他们是Objetc的方法，不是Thread的方法，同时wait()与notify()会配合使用，分别表示线程挂起和线程恢复。</p><p>wait()和sleep()的区别，<strong>wait()会释放对象锁资源，而sleep()不会释放对象锁资源。但是wait和sleep都会释放cpu资源。</strong></p><h2 id="二、Java线程的生命周期"><a href="#二、Java线程的生命周期" class="headerlink" title="二、Java线程的生命周期"></a>二、Java线程的生命周期</h2><ol><li><p>新建(NEW):新建了一个线程对象，并没有调用start()之前</p></li><li><p>可运行(Runnable):就绪状态，<strong>调用start()之后线程就进入就绪状态，但是并不是说只要调用start()线程马上变为当前线程，在变为当前线程之前都是为就绪状态。线程在睡眠和挂起中恢复的时候也会进入就绪状态。</strong> 线程对象创建后，其他线程（比如main线程)调用了该对象的start()方法，该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPI的使用权。</p></li><li><p>运行(Running):可运行状态的线程获得了CPU时间片，执行程序代码。线程被设置为当前线程，开始执行run()方法，就是线程进入了运行状态</p></li><li><p>阻塞(Blocked):阻塞是指线程因为某种原因放弃了cpu使用权，即让出了cpu 时间片，暂时停止运行。知道线程进入可运行状态，才有机会再次获得cpu 时间片转到运行状态。线程被暂停，比如调用sleep()方法后，线程就进入阻塞状态。</p><p>阻塞分为三种情况：</p><ul><li>等待阻塞：运行的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中</li><li>其他阻塞：运行的线程执行Thread.sleep(long ms)或者t.join()方法，或者放出了I/O请求，JVM会把线程设置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行状态</li></ul></li><li><p>死亡(Dead):线程执行结束，线程run()、main()方法执行结束，或者异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ol><p><img src="https://s1.ax1x.com/2020/03/23/8H2gIg.png" alt="8H2gIg.png"></p><h2 id="三、具体状态"><a href="#三、具体状态" class="headerlink" title="三、具体状态"></a>三、具体状态</h2><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态</p><h3 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h3><ol><li>可运行状态只是说你有资格运行，调度程序没有挑选到你，你就永远是可运行状态。</li><li>调用线程的start()方法，此线程进入可运行状态</li><li>当前线程sleep()方法结束、其他线程join()方法结束、等待用户输入完毕、某个线程拿到对象锁，这些线程也将进入可运行状态</li><li>当前线程时间片用完了、调用当前线程的yield()方法，当前线程进入可运行状态</li><li>锁池里的线程拿到对象锁后，进入可运行状态</li></ol><h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一方式</p><h3 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h3><ol><li>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。 <strong>线程一旦死亡，就不能复生</strong></li><li>在一个死去的线程上调用start()方法，会抛出<code>java.lang.IllegalThreadStateException</code>异常</li></ol><h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><ol><li>当前线程T调用Thread.sleep()方法，当前线程进入阻塞状态</li><li>运行在当前线程里的其他线程t2调用join方法，当前线程进入阻塞状态</li><li>等待用户输入时，当前线程进入阻塞状态</li></ol><h3 id="等待队列（本是Object里的方法，但影响了线程）"><a href="#等待队列（本是Object里的方法，但影响了线程）" class="headerlink" title="等待队列（本是Object里的方法，但影响了线程）"></a>等待队列（本是Object里的方法，但影响了线程）</h3><ol><li>调用obj的wait()、notify()方法前，必须获得obj锁，也就是必须写在<code>synchronized(obj)</code>代码段内。</li><li>等待队列相关的步骤和图</li></ol><p><img src="https://s1.ax1x.com/2020/03/23/8H4Kjs.png" alt="8H4Kjs.png"></p><h2 id="四、几个方法的比较"><a href="#四、几个方法的比较" class="headerlink" title="四、几个方法的比较"></a>四、几个方法的比较</h2><ul><li><p>sleep：Thread类的方法，必须带一个时间参数。 <strong>会让当前线程休眠进入阻塞状态并释放CPU( sleep释放cpu，wait也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段)</strong>，提供其他线程运行的机会且不考虑优先级，但如果有同步锁，则sleep不会释放锁，即其他线程无法获得同步锁，可通过调用interrupt()方法来唤醒休眠线程。（interrupt()的作用是，在线程收到阻塞时，抛出一个中断信号，这样线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait，Thread.join和Thread.sleep三种方法之一阻塞，那么它将接收到一个中断异常(<code>InterruptedException</code>)，从而提早终结被阻塞状态）</p></li><li><p>yield：<strong>让出CPU调度</strong>，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间，并且yield()方法 <strong>只能让同优先级的线程</strong>有执行的机会。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入 <strong>可执行状态后</strong>马上又被执行。调用yield()方法只是一个建议，告诉线程调度器，我的工作已经做的差不多了，可以让别的相同优先级的线程使用cpu了，没有任何机制保证采纳</p></li><li><p>wait: Object类的方法(notify()、notifyAll())，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程池等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)，即放入锁池中竞争同步锁</p></li><li><p>join:一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态，直到另一个线程运行结束，等待该线程终止。注意该方法也需要捕捉异常。</p><p>等待调用join方法的线程结束，再继续执行。</p><p><img src="https://s1.ax1x.com/2020/03/23/8H4UgJ.png" alt="8H4UgJ.png"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、线程的几个重要方法&quot;&gt;&lt;a href=&quot;#一、线程的几个重要方法&quot; class=&quot;headerlink&quot; title=&quot;一、线程的几个重要方法&quot;&gt;&lt;/a&gt;一、线程的几个重要方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;start()方法，开始执行该线程&lt;/li&gt;
&lt;li&gt;stop()方法，强制结束该线程执行&lt;/li&gt;
&lt;li&gt;join()方法，等待该线程结束&lt;/li&gt;
&lt;li&gt;sleep()方法，线程进入等待&lt;/li&gt;
&lt;li&gt;run()方法，直接执行线程的run()方法，但是线程调用start()方法时也会运行run()方法，区别就是一个是由线程调度运行run()方法，一个是直接调用了线程中的run()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://pic1.win4000.com/wallpaper/0/57f86946b178d.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>同步异步与阻塞非阻塞</title>
    <link href="http://yoursite.com/2020/03/24/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>http://yoursite.com/2020/03/24/同步异步阻塞非阻塞/</id>
    <published>2020-03-23T16:00:00.000Z</published>
    <updated>2020-03-23T16:25:52.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-同步与异步"><a href="#1-同步与异步" class="headerlink" title="1 同步与异步"></a>1 同步与异步</h2><p><strong>首先来解释下同步和异步的概念，这两个概念和消息的通知机制有关。也就是同步和异步主要是从消息通知机制角度来说的。</strong></p><h3 id="1-1-概念描述"><a href="#1-1-概念描述" class="headerlink" title="1.1 概念描述"></a>1.1 概念描述</h3><p><strong>所谓同步就是一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才算完成，这是一种可靠的任务序列。</strong>要么成功都成功，要么失败都失败，这两个任务的状态可以一致。</p><p><strong>所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。</strong>至于依赖的任务最终是否真正完成，依赖它的任务无法确定，<strong>所以它是不可靠的任务序列。</strong></p><p><img src="http://img3.51tietu.net/pic/2016-060411/20160604110705phmiwo32jbb329772.jpg" alt><br><a id="more"></a></p><h3 id="1-2-消息通知"><a href="#1-2-消息通知" class="headerlink" title="1.2 消息通知"></a>1.2 消息通知</h3><p><strong>异步的概念和同步相对</strong>。当一个同步调用发出后，<strong>调用者要一直等待返回消息(结果)通知后</strong>，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。<strong>实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者</strong>。</p><p>这里提到的执行部件和调用者通过三种途径返回结果：<code>状态、通知和回调</code>。使用哪一种通知机制，<code>依赖于执行部件的实现</code>，除非执行部件提供多种选择，<code>否则不受调用者控制</code>。</p><blockquote><p>1.如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误。</p><p>2.如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</p></blockquote><h3 id="1-3-场景比喻"><a href="#1-3-场景比喻" class="headerlink" title="1.3 场景比喻"></a>1.3 场景比喻</h3><p>举个例子，比如我去银行办理业务，可能会用两种方式：</p><blockquote><ol><li>选择排队等候</li><li>另外一种选择，取号，等到排到我这一号时由柜台的人通知我去办理业务</li></ol></blockquote><p>第一种：<strong>前者（排队等候）就是同步等待消息通知</strong>，也就是我要一直在等待银行办理业务情况；</p><p>第二种：<strong>后者（等待别人通知）就是异步等待消息通知</strong>，在异步消息处理中，<strong>等待消息通知者（等待办理业务的人）往往注册一个回调机制</strong>。在所等待的事件被触发时由触发机制（柜台的人）通过某种机制（写在小纸条上的号码，喊号）找到等待该事件的人。</p><h2 id="2-阻塞非阻塞"><a href="#2-阻塞非阻塞" class="headerlink" title="2. 阻塞非阻塞"></a>2. 阻塞非阻塞</h2><p><strong>阻塞和非阻塞这两个概念与程序（线程）等待消息通知（无所谓同步或者异步）时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</strong></p><h3 id="2-1-概念描述"><a href="#2-1-概念描述" class="headerlink" title="2.1 概念描述"></a>2.1 概念描述</h3><p><strong>阻塞调用是指调用结果返回前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务</strong>。函数只有在得到结果之后才会返回。</p><p><strong>有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。</strong></p><ol><li><strong>对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已。此时，这个线程可能也会处理其他的消息。</strong>扩展点：</li></ol><blockquote><p>(a)如果这个线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫作同步非阻塞</p><p>(b)如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做同步阻塞</p></blockquote><p><strong>所以同步的实现方式会有两种：同步阻塞、同步非阻塞；同理，异步也会有两种实现：异步阻塞、异步非阻塞</strong>。</p><ol><li><p>对于阻塞调用来说，则当前线程就会被挂起等待当前函数返回</p><p>非阻塞和阻塞的概念相对于，<strong>指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</strong>虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，<strong>但是也带来了另外一种后果就是系统的线程切换增加，增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。</strong></p></li></ol><h3 id="2-2-场景比喻"><a href="#2-2-场景比喻" class="headerlink" title="2.2 场景比喻"></a>2.2 场景比喻</h3><p>继续上面的例子，不论是排队还是取号等待通知，<strong>如果在这个等待的过程中，等待者除了等待消息通知之外不能做其他事情，那么该机制就是阻塞的</strong>。表现在程序中，也就是该程序一直阻塞在该函数调用处不能继续往下执行。</p><p>相反，<strong>有的人喜欢在银行办理这些业务的时候，一边打电话发短信一边等待，这样的状态就是非阻塞的</strong>，因为等待者没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</p><p>但是需要注意的是，<strong>同步非阻塞形式实际上是效率低下的</strong>，想象一下你一边打着电话，一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而<strong>异步非阻塞形式却没有这样的问题，</strong>因为打电话是等待者的事情，而通知你则是柜台（消息触发机制）的事情，程序没有在两种不同的操作中来回切换。</p><h2 id="3-同步-异步与阻塞-非阻塞"><a href="#3-同步-异步与阻塞-非阻塞" class="headerlink" title="3 同步/异步与阻塞/非阻塞"></a>3 同步/异步与阻塞/非阻塞</h2><h3 id="3-1-同步阻塞形式"><a href="#3-1-同步阻塞形式" class="headerlink" title="3.1. 同步阻塞形式"></a>3.1. 同步阻塞形式</h3><p>效率最低，以上面的例子举例，就是你专心排队，什么别的事情都不做</p><p><strong>实际程序中：</strong>就是未对fd设置<code>O_NONBLOCK</code>标志位的 read/write操作</p><h3 id="3-2-异步阻塞形式"><a href="#3-2-异步阻塞形式" class="headerlink" title="3.2. 异步阻塞形式"></a>3.2. 异步阻塞形式</h3><p>如果是在银行等待办理业务的人，<strong>采用的是异步的方式去等待消息被触发（通知）</strong>，也就是领了一张小纸条，假如在这段时间里他不能离开银行去做其他的事情，那么很显然，这个人被阻塞在了这个等待的操作上面</p><p><strong>异步操作是可以被阻塞的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</strong></p><p>比如select函数，假如传入的最后一个timeout参数为NULL，<strong>那么如果所关注的事件没有一个被触发，程序就会一直阻塞在这个select调用处</strong></p><h3 id="3-3-同步非阻塞形式"><a href="#3-3-同步非阻塞形式" class="headerlink" title="3.3. 同步非阻塞形式"></a>3.3. 同步非阻塞形式</h3><p>实际上效率低下的，2.2已解释了效率低下的原因。很多人会写阻塞的read/write操作，<strong>但是可以对fd设置O_NONBLOCK标志位，这样就可以将同步操作变成非阻塞的了</strong>。</p><h3 id="3-4-异步非阻塞形式"><a href="#3-4-异步非阻塞形式" class="headerlink" title="3.4.异步非阻塞形式"></a>3.4.异步非阻塞形式</h3><p>效率更高，因为打电话是等待者的事情，而通知你是柜台（消息触发机制）的事情，<strong>程序没有在两种不同的操作中来回切换</strong>。</p><p>比如说，这个人突然想出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下(注册一个回调函数)，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p><p>如果使用异步非阻塞的情况，比如aio_<em>组的操作，当发起一个aio_read操作时，<em>*函数会马上返回不会被阻塞，当所关注的事件被触发时会调用之前注册的回调函数进行处理。</em></em></p><blockquote><p>很多人会把同步和阻塞混淆，我想是因为<strong>很多时候同步操作会以阻塞的形式表现出来，但最根本是因为没有区分这两个概念。</strong>比如阻塞的read/write操作中，<strong>其实是把消息通知机制和等待消息通知的状态结合在了一起，</strong>在这里<strong>所关注的消息就是fd是否可读/写，</strong>而<strong>等待消息通知的状态则是对fd可读/写等待过程中程序（线程）的状态</strong>。如果我们将这个fd设置为非阻塞的时候，read/write操作就不会在等待消息通知这里阻塞，如果fd不可读/写,则操作立即返回。</p><p>同样的，很多人也会把异步和非阻塞混淆，<strong>因为异步操作一般都不会在真正的IO操作处被阻塞，</strong>比如如果用select函数，<strong>当select返回可读时再去read一般不会被阻塞，而是在select函数调用处阻塞</strong>。</p></blockquote><h2 id="4-小明的故事"><a href="#4-小明的故事" class="headerlink" title="4.小明的故事"></a>4.小明的故事</h2><p>对上面所讲的概念再次进行一个场景梳理，上面已经明确说过了，<strong>同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序(线程)等待消息通知的状态</strong>。以小明下载文件打个比方，从这两个关注点来再次说明这两组概念，希望能更好的促进大家的理解。</p><p><strong>同步阻塞：小明一直盯着下载进度条，到100%的时候完成</strong></p><blockquote><p>同步体现在：等待下载完成通知</p><p>阻塞体现在：等待下载完成通知的过程中，不能做其他任务处理</p></blockquote><p><strong>同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到100%就完成</strong></p><blockquote><p>同步体现在：等待下载完成通知</p><p>非阻塞体现在：等待下载完成通知的过程中，去干别的任务了，只是时不时会瞄一眼进度条（小明必须要在两个任务间切换，关注下载进度）</p></blockquote><p><strong>异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就”叮”一声，不过小明仍然一直在等待”叮“的声音（看起来很傻）</strong></p><blockquote><p>异步体现在：下载完成”叮”一声通知</p><p>阻塞体现在：等待下载完成后”叮”一声通知中，不能做其他任务处理</p></blockquote><p><strong>异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了</strong></p><blockquote><p>异步体现在：下载完成”叮”一声通知</p><p>阻塞体现在：等待下载完成后”叮”一声通知中，去干别的任务了，只需要接收”叮”的一声通知即可，（软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件”叮”的通知即可</p></blockquote><p>也就是说，<strong>同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务）</strong>，在不同的场景下，同步/异步、阻塞/非阻塞的四种组合都有应用。</p><p>所以综上所述，<strong>同步和异步仅仅是关注的消息如何通知的机制，而阻塞与非阻塞关注的是等待消息通知时的状态。</strong>也就是说，<strong>同步的情况下，是由处理消息者自己去等待消息是否被触发，而异步的情况下是由触发机制来通知处理消息者，</strong>所以在异步机制中，<strong>处理消息和触发机制之间就需要一个连接的桥梁:</strong></p><blockquote><p>银行的例子中，这个桥梁就是小纸条上的号码</p><p>小明的例子中，这个桥梁就是软件”叮”的声音</p></blockquote><p><strong>最后，大家注意理解”消息通知机制”和”等待消息通知时的状态”这两个概念，这是理解四个概念的关键所在。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-同步与异步&quot;&gt;&lt;a href=&quot;#1-同步与异步&quot; class=&quot;headerlink&quot; title=&quot;1 同步与异步&quot;&gt;&lt;/a&gt;1 同步与异步&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;首先来解释下同步和异步的概念，这两个概念和消息的通知机制有关。也就是同步和异步主要是从消息通知机制角度来说的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-1-概念描述&quot;&gt;&lt;a href=&quot;#1-1-概念描述&quot; class=&quot;headerlink&quot; title=&quot;1.1 概念描述&quot;&gt;&lt;/a&gt;1.1 概念描述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;所谓同步就是一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才算完成，这是一种可靠的任务序列。&lt;/strong&gt;要么成功都成功，要么失败都失败，这两个任务的状态可以一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。&lt;/strong&gt;至于依赖的任务最终是否真正完成，依赖它的任务无法确定，&lt;strong&gt;所以它是不可靠的任务序列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.51tietu.net/pic/2016-060411/20160604110705phmiwo32jbb329772.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java秒杀系统方案优化 高性能高并发实战</title>
    <link href="http://yoursite.com/2019/06/16/Java%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/06/16/Java秒杀系统方案优化/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-16T15:28:16.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIBt6YAAvmGfwhdgwAALGfwFf6LcAC-Yx733.jpg" alt></p><h2><br>  项目安排<br></h2><h3>1.项目搭建</h3><ul><li><code>SpringBoot</code> 环境搭建</li><li>集成<code>Thymeleaf</code>,<code>Result</code>结果封装</li><li>集成<code>Mybatis</code> + <code>Druid</code></li><li>集成<code>Jedis</code> +<code>Redis</code>安装 + 通用缓存<code>Key</code>封装</li></ul><a id="more"></a><h3>2.实现登录功能</h3><ul><li>数据库设计</li><li>明文密码两次<code>MD5</code>处理</li><li><code>JSR303</code>参数校验 + 全局异常处理器</li><li>分布式<code>Session</code></li></ul><h3>3.实现秒杀功能</h3><ul><li>数据库设计</li><li>商品列表页</li><li>商品详情页</li><li>订单详情页 </li></ul><h4>4.JMeter压测</h4><ul><li><code>JMeter</code>入门</li><li>自定义多变量模拟多用户</li><li><code>JMeter</code>命令行使用</li><li><code>SpringBoot</code>打<code>War</code>包</li></ul><h3>5.页面优化技术</h3><ul><li>页面缓存 + <code>URL</code>缓存 + 对象缓存</li><li>页面静态化 ，前后端分离</li><li>静态资源优化</li><li><code>CDN</code>优化</li></ul><h3>6.接口优化</h3><ul><li><code>Redis</code>预减库存减少数据库访问</li><li>内存标记减少<code>Redis</code>访问</li><li><code>RabbitMQ</code>队列缓冲，异步下单，增强用户体验</li><li><code>RabbitMQ</code>安装与<code>SpringBoot</code>集成</li><li>访问<code>Nginx</code>水平扩展</li><li>分库分表（<code>Mycat</code>)</li><li>压测</li></ul><h3>7.安全优化</h3><ul><li>秒杀接口地址隐藏</li><li>数学公式验证码</li><li>接口防刷</li></ul><hr><h2>1.项目搭建</h2><h3>集成Redis中的问题和笔记</h3><h4>1.Spring注入</h4><p><code>Spring</code>通过<code>DI</code>（依赖注入）实现<code>IOC</code>（控制反转)，常用的注入方式主要有以下三种:</p><ul><li>构造方法注入</li><li><code>setter</code>方法注入</li><li>基于注解的注入</li></ul><h4>构造方法注入</h4><p>在spring的配置文件中注册UserService，将UserDaoJdbc通过constructor-arg标签注入到UserService的<strong>某个</strong>有参数的构造方法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册userService --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.lyu.spring.service.impl.UserService"</span>&gt;</span><br><span class="line">&lt;constructor-arg ref="userDaoJdbc"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册jdbc实现的dao --&gt;</span><br><span class="line">&lt;bean id="userDaoJdbc" class="com.lyu.spring.dao.impl.UserDaoJdbc"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>如果只有一个有参数的构造方法并且参数类型与注入的bean的类型匹配，那就会注入到该构造方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(IUserDao userDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDao.loginUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">// 获取bean对象</span></span><br><span class="line">UserService userService = ac.getBean(UserService.class, <span class="string">"userService"</span>);</span><br><span class="line"><span class="comment">// 模拟用户登录</span></span><br><span class="line">userService.loginUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><h4>setter注入</h4><p>配置文件如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册userService --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.lyu.spring.service.impl.UserService"</span>&gt;</span><br><span class="line">&lt;!-- 写法一 --&gt;</span><br><span class="line">&lt;!-- &lt;property name="UserDao" ref="userDaoMyBatis"&gt;&lt;/property&gt; --&gt;</span><br><span class="line">&lt;!-- 写法二 --&gt;</span><br><span class="line">&lt;property name="userDao" ref="userDaoMyBatis"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册mybatis实现的dao --&gt;</span><br><span class="line">&lt;bean id="userDaoMyBatis" class="com.lyu.spring.dao.impl.UserDaoMyBatis"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>注：上面这两种写法都可以,spring会将name值的每个单词首字母转换成大写，然后再在前面拼接上”set”构成一个方法名,然后去对应的类中查找该方法,通过反射调用,实现注入。</strong></p><p><em>切记：name属性值与类中的成员变量名以及set方法的参数名都无关，只与对应的set方法名有关，下面的这种写法是可以运行成功的</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IUserDao userDao1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(IUserDao userDao1)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao1 = userDao1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDao1.loginUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>还有一点需要注意：如果通过set方法注入属性，那么spring会通过默认的空参构造方法来实例化对象，所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上，否则spring没有办法实例化对象，导致报错。</strong></p><h4>基于注解的注入</h4><p>在介绍注解注入的方式前，先简单了解<code>bean</code>的一个属性<code>autowire</code>，<code>autowire</code>主要有三个属性值：<code>constructor</code>，<code>byName</code>，<code>byType</code>。</p><ul><li><p><code>constructor</code>：通过构造方法进行自动注入，<code>spring</code>会匹配与构造方法参数类型一致的<code>bean</code>进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的<code>bean</code>，那么<code>spring</code>会优先将<code>bean</code>注入到多参数的构造方法中。</p></li><li><p><code>byName</code>：被注入<code>bean</code>的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。</p></li><li><p><code>byType</code>：查找所有的set方法，将符合符合参数类型的bean注入。</p></li></ul><hr><p>主要有四种注解可以注册bean，每种注解可以任意使用，只是语义上有所差异：</p><ul><li><code>@Component</code>：可以用于注册所有bean</li><li><code>@Repository</code>：主要用于注册dao层的bean</li><li><code>@Controller</code>：主要用于注册控制层的bean</li><li><code>@Service</code>：主要用于注册服务层的bean</li></ul><p>描述依赖关系主要有两种：</p><ul><li><code>@Resource</code>：java的注解，默认以byName的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（spring注解）指定某个具体名称的bean。</li><li><code>@Autowired</code>：spring注解，<strong>默认是以byType的方式去匹配类型相同的bean</strong>，如果只匹配到一个，那么就直接注入该bean，无论要注入的 bean 的 name 是什么；如果匹配到多个，就会调用就会调用 <strong><code>DefaultListableBeanFactory</code></strong> 的 <strong><code>determineAutowireCandidate</code></strong> 方法来决定具体注入哪个bean</li></ul><blockquote><p>determineAutowireCandidate 方法的逻辑是：</p><ol><li>先找 Bean 上有@Primary 注解的，有则直接返回 bean 的 name。</li><li>再找 Bean 上有 @Order，@PriorityOrder 注解的，有则返回 bean 的 name。</li><li>最后再以名称匹配（ByName）的方式去查找相匹配的 bean</li></ol></blockquote><p>虽然有这么多的注入方式，但是实际上开发的时候自己编写的类一般用注解的方式注册类，用@Autowired描述依赖进行注入，一般实现类也只有一种（jdbc or hibernate or mybatis），除非项目有大的变动，所以@Qualifier标签用的也较少；但是在使用其他组件的API的时候用的是通过xml配置文件来注册类，描述依赖，因为你不能去改人家源码嘛。</p><h4>2.</h4><p><a href="https://postimg.cc/tYCsYJ80" target="_blank" rel="noopener"><img src="https://i.postimg.cc/Pr1YV84q/WX20190519-182215-2x.png" alt="WX20190519-182215-2x.png"></a></p><h3>2.实现登录</h3><h4>1.两次MD5</h4><ol><li>用户端：PASS = MD5（明文 + 固定Salt)</li><li>服务端：PASS = MD5（用户输入 + 随机Salt）</li></ol><h4>2.数据库三大范式</h4><ul><li>1NF：要求有主键，并且要求每一个字段原子性不可再分</li></ul><blockquote><p>1NF是对属性的<strong>原子性</strong>，要求属性具有原子性，不可再分解；</p><p>表：字段1、 字段2(字段2.1、字段2.2)、字段3 ……</p><p>如学生（学号，姓名，性别，出生年月日），如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不是一范式了，否则就是。</p></blockquote><ul><li>2NF：要求所有非主键字段完全依赖主键，不能产生部分依赖</li></ul><blockquote><p>2NF是对记录的<strong>惟一性</strong>，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；</p><p>表：学号、课程号、姓名、学分;</p><p>这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里<strong>学分依赖课程号</strong>，<strong>姓名依赖与学号</strong>，所以不符合二范式。</p><p><strong>可能会存在问题：</strong></p><ul><li><code>数据冗余:</code>，每条记录都含有相同信息；</li><li><code>删除异常：</code>删除所有学生成绩，就把课程信息全删除了；</li><li><code>插入异常：</code>学生未选课，无法记录进数据库；</li><li><code>更新异常：</code>调整课程学分，所有行都调整。</li></ul><p><strong>正确做法:</strong><br>学生：<code>Student</code>(学号, 姓名)；<br>课程：<code>Course</code>(课程号, 学分)；<br>选课关系：<code>StudentCourse</code>(学号, 课程号, 成绩)。</p></blockquote><ul><li>3NF：所有非主键字段和主键字段之间不能传递依赖</li></ul><blockquote><p>3NF是对字段的<strong>冗余性</strong>，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</p><p>表: 学号, 姓名, 年龄, 学院名称, 学院电话</p><p>因为存在<strong>依赖传递</strong>: (学号) → (学生)→(所在学院) → (学院电话) 。</p><p><strong>可能会存在问题：</strong></p><ul><li><code>数据冗余:</code>有重复值；</li><li><code>更新异常：</code>有重复的冗余信息，修改时需要同时修改多条记录，否则会出现<strong>数据不一致的情况</strong> 。</li></ul><p><strong>正确做法：</strong></p><p>学生：(学号, 姓名, 年龄, 所在学院)；</p><p>学院：(学院, 电话)。</p></blockquote><h4>反范式</h4><p><strong>一般说来，数据库只需满足第三范式（3NF）就行了。</strong></p><blockquote><p>没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余，<strong>达到以空间换时间的目的</strong>。</p><p>〖例〗：有一张存放商品的基本表，如表1所示。“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以<strong>提高查询统计的速度</strong>，这就是以<strong>空间换时间</strong>的作法。</p></blockquote><h4>范式化设计和反范式化设计的优缺点</h4><p><strong>范式化</strong></p><p><strong>优点</strong></p><ul><li>可以尽可能的减少数据冗余</li><li>数据表更新快，体积小</li></ul><p><strong>缺点</strong></p><ul><li>对于查询需要对多个表进行关联，导致性能低</li><li>更难进行索引优化</li></ul><p><strong>反范式化</strong></p><p><strong>优点</strong></p><ul><li>可以减少表的关联</li><li>可以更好进行索引优化</li></ul><p><strong>缺点</strong></p><ul><li>存在数据冗余及数据维护异常</li><li>对数据的修改需要更多的成本</li></ul><h3>五、页面优化</h3><h4>页面缓存</h4><ol><li>取缓存</li><li>手动渲染模板</li><li>结果输出</li></ol><h4>静态资源优化</h4><ol><li>JS/CSS压缩，减少流量</li><li>多个JS/CSS组合，减少连接数</li><li>CDN就近访问</li></ol><h3>六、秒杀接口优化</h3><p><strong>思路：减少数据库访问 </strong></p><ol><li>系统初始化，把商品库存数量加载到Redis</li><li>收到请求，Redis预减库存，库存不足，直接返回，否则进入3</li><li>请求入队，立即返回排队中</li><li>请求出队，生成订单，减少库存</li><li>客户端轮询，是否秒杀成功</li></ol><p><strong>1.<code>SpringBoot</code>集成<code>RabbitMQ</code></strong></p><ol><li>添加依赖<code>spring-boot-starter-amqp</code></li><li>创建消息接受者</li><li>创建消息发送者</li></ol><h3>7.安全优化</h3><ul><li>秒杀接口地址隐藏</li><li>数学公式验证码</li><li>接口防刷</li></ul><p><strong>1.秒杀接口地址隐藏</strong></p><p><strong>思路：秒杀开始之前，先去请求接口获取秒杀地址</strong></p><ol><li>接口改造，带上PathVariable参数</li><li>添加生成地址的接口</li><li>秒杀收到请求，先验证PathVariable</li></ol><p><strong>2.数学公式验证码</strong></p><p><strong>思路：点击秒杀之前，先输入验证码，分散用户的请求</strong></p><ol><li>添加生成验证码的接口</li><li>在获取秒杀路径的时候，验证验证码</li><li>ScriptEngine使用 </li></ol><p><strong>3.接口限流</strong></p><p>把用户访问次数写入缓存，并加上有效时间。（可以用拦截器减少对业务代码的侵入）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIBt6YAAvmGfwhdgwAALGfwFf6LcAC-Yx733.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2&gt;&lt;br&gt;  项目安排&lt;br&gt;&lt;/h2&gt;

&lt;h3&gt;1.项目搭建&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SpringBoot&lt;/code&gt; 环境搭建&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Thymeleaf&lt;/code&gt;,&lt;code&gt;Result&lt;/code&gt;结果封装&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Mybatis&lt;/code&gt; + &lt;code&gt;Druid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Jedis&lt;/code&gt; +&lt;code&gt;Redis&lt;/code&gt;安装 + 通用缓存&lt;code&gt;Key&lt;/code&gt;封装&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="秒杀" scheme="http://yoursite.com/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>并发编程与高并发入门</title>
    <link href="http://yoursite.com/2019/06/11/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/06/11/并发编程入门与高并发笔记/</id>
    <published>2019-06-11T09:15:53.000Z</published>
    <updated>2019-07-15T15:35:30.203Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://996.icu" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/link-996.icu-red.svg"></a></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIFY_6AA3VjT9w7FMAALGfwFCj8AADdWl862.jpg" alt></p><h3>4.线程安全性</h3><br>定义：当多个线程访问某个类时，不管运行时环境采用<b>何种调度方式</b>或者这些进程将如何交替执行，并且在主调代码中<b>不需要任何额外的同步或协同</b>，这个类都能表现出<b>正确的行为</b>，那么就称这个类是线程安全的。<br><br><em> 原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。</em> 可见性：一个线程对主内存的修改可以及时的被其他线程观察到。<br><em> 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。<br><br><a id="more"></a><br><br><b>原子性——Atomic包</b><br><br>- AtomicXXX：CAS、Unsafe.compareAndSwapInt<br>- AtomicLong、LongAdder<br>- AtomicReference、AtomicReferenceFieldUpdater<br>- AtomicStampReference：CAS的ABA问题<br><br><b>原子性——锁</b></em> synchronized：依赖JVM<br><em> Lock：依赖特殊的CPU指令，代码实现，ReentrantLock<br><br><b>原子性——synchronize</b></em> 修饰代码块：大括号括起来的代码，作用于<b>调用对象</b><br><em> 修饰方法：整个方法，作用于<b>调用的对象</b></em> 修饰静态方法：整个静态方法，作用于这个<b>类的所有对象</b><br><em> 修饰类：括号括起来的部分，作用于这个<b>类的所有对象</b><br><br><b>原子性——对比</b></em> Synchronized：不可中断锁，适合竞争不激烈，可读性好<br><em> Lock：可中断锁，多样化同步，竞争激烈时能维持常态</em> Atomic：竞争激烈时能维持常态，比Lock性能好；只能同步一个值<br><br><b>可见性</b><br><br><em> 线程交叉执行</em> 重排序结合线程交叉执行<br><em> 共享变量更新后的值没有在工作内存及主存空间及时更新<br><br><b>可见性</b><br><br><b>JMM(Java Memory Model) 关于synchorized 的两条规定:</b></em> 线程解锁前，必须把共享变量的最新值刷新到主内存<br><em> 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读区最新的值（注意，加锁与解锁是同一把锁)<br><br><b>可见性——volatile</b><br><br>通过加入<b>内存屏障</b>和<b>禁止重排序</b>优化来实现</em> 对volatile变量写操作时，会在写操作后加入一条store 屏障指令，将本地内存中的共享变量值刷新到主内存<br><em> 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量<br><br><b>可见性——volatile使用（适合作为状态标识量）</b><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">context = loadContext();</span><br><span class="line">inited = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="keyword">while</span>(!inited)&#123;</span><br><span class="line">  sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure><br><br><b>有序性</b></em> java内存模型中，允许编译器和处理器对指令进行<b>重排序</b>，但是重排序过程不会影响到<b>单线程</b>程序的执行，却会影响到多线程并发执行的正确性<br><em> volatile、synchronized、Lock<br><br><b>有序性-happens-before原则</b><br><br><b>较重要的原则</b></em> 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br><em> 锁定原则：一个unLock操作先行发生于后面对同一个锁的lock操作</em> volatile变量规则：对一个变量的写操作先行发生于后面这个变量的读操作<br><em> 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br><br><b>显而易见的原则</b></em> 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作<br><em> 线程中断规则：对线程的interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</em> 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br><em> 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br><br><br><br><h3>线程安全性——总结</h3></em> 原子性：Atomic包、CAS算法、synchronized、Lock<br><em> 可见性：synchronized、volatile</em> 有序性：happens-before<br><br><h3>5.安全发布对象</h3><br><a href="https://postimg.cc/sBjb8q95" target="_blank" rel="noopener"><img src="https://i.postimg.cc/3wm7yHkf/WX20190707-225115-2x.png" alt="WX20190707-225115-2x.png"></a><br><br><br><br><strong>UnsafePublish.java</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafePublish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] states = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafePublish unsafePublis = <span class="keyword">new</span> UnsafePublish();</span><br><span class="line">        System.out.println(Arrays.toString(unsafePublis.getStates()));</span><br><span class="line"></span><br><span class="line">        unsafePublis.getStates()[<span class="number">0</span>] = <span class="string">"d"</span>;</span><br><span class="line">        System.out.println(Arrays.toString(unsafePublis.getStates()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>Console</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c]</span><br><span class="line">[d, b, c]</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><br><br><strong>Escape.java（对象溢出）</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Escape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thisCanBeEscape = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Escape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerClass();   <span class="comment">//在构造函数运行时，启动了一个新线程去实例化InnerClass</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"&#123;&#125;"</span>, Escape.<span class="keyword">this</span>.thisCanBeEscape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Escape();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>Console</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 [main] INFO com.interview.concurrency.publish.Escape - 0</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><br><br><strong>安全发布对象</strong><br><br><em>  在静态初始化函数中初始化一个对象引用</em> 将对象的引用保存到<code>volatile</code>类型域或者<code>AtomicReference</code>对象中<br><em> 将对象的引用保存到某个正确构造对象的final类域中</em> 将对象的引用保存到一个由锁保护的域中<br><br><br><br> <strong>（1）线程不安全的单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annotion.NotThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;     <span class="comment">//此处线程不安全</span></span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 并发情况下，两个线程都同时通过if判断，就会导致实例化两个不同的对象。<br><br><br><br><strong>（2）线程安全的单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 饿汉模式————单例实例类装载使用时创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; ​     饿汉模式是线程安全的，当类的构造方法中没有包含过多的操作处理，饿汉模式是可以接受的。<br>&gt;<br>&gt; ​    但他的不足之处在于：当类的构造方法中包含过多的操作处理时， 会导致类加载时特别慢。 因此可能会引    起性能问题；如果使用饿汉模式只进行类的加载，却没有实际调用的话，会造成资源的浪费。<br><br><br><br><strong>（3）线程安全的“懒汉”模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotRecommend;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@NotRecommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonExample3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 加了<code>synchronized</code>关键字，同一时刻只有一个线程可以访问这个方法，保证了线程安全性。<br>&gt;<br>&gt; 通过使用同一时刻只能有一个线程访问的方式来保证线程安全，但是会带来性能的开销。而这个开销是我们所不希望的，所以不建议这种方式。<br><br><strong>（4）双重同步锁单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> * 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. memory = allocate()分配对象内寸空间</span></span><br><span class="line">    <span class="comment">//2. ctorInstance()初始化对象</span></span><br><span class="line">    <span class="comment">//3. instance = memory 设置instance指向刚才分配的内存空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//JVM和cpu优化，发生了指令重排</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. memory = allocate()分配对象内寸空间、</span></span><br><span class="line">    <span class="comment">//3. instance = memory 设置instance指向刚才分配的内存空间</span></span><br><span class="line">    <span class="comment">//2. ctorInstance()初始化对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//双重检测机制          B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4.class) &#123;  <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4(); <span class="comment">//A-3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 在指令重排的情况，（A-3) 未初始化对象带来的线程不安全问题<br><br><br><br><strong>（5）正确的线程安全的懒汉式单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> * 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象  volatile + 双重检测机制 -&gt; 禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonExample5 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. memory = allocate()分配对象内寸空间</span></span><br><span class="line">    <span class="comment">//2. ctorInstance()初始化对象</span></span><br><span class="line">    <span class="comment">//3. instance = memory 设置instance指向刚才分配的内存空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//双重检测机制          B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample5.class) &#123;  <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample5(); <span class="comment">//A-3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>（6）最安全的枚举模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.Recommend;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:23:13</span></span><br><span class="line"><span class="comment"> * 枚举模式————最安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JVM保证这个方法只调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h3>11.高并发解决思路之扩容思路</h3><p><a href="https://postimg.cc/1f6nzJMw" target="_blank" rel="noopener"><img src="https://i.postimg.cc/m2pQ8nHX/WX20190704-215857-2x.png" alt="WX20190704-215857-2x.png"></a></p><p><a href="https://postimg.cc/2bZbBGms" target="_blank" rel="noopener"><img src="https://i.postimg.cc/bJ6QWV5w/WX20190704-220347-2x.png" alt="WX20190704-220347-2x.png"></a></p><h3>13.高并发解决思路之消息队列</h3><br><strong>特性</strong><br><br><em> 业务无关：只做消息分发</em> FIFO：先投递先到达<br><em> 容灾：节点的动态增删和消息的持久化</em> 性能：吞吐量提升，系统内部通信效率提高<br><br><br><br><strong>为什么需要消息队列</strong><br><br>&gt; 【生产】和【消费】的速度或稳定性等因素不一致<br><br><br><br><strong>消息队列好处</strong><br><br><em> 业务解耦</em> 最终一致性<br><em> 广播</em> 错峰与流控<br><br><br><br><strong>消息队列举例</strong><br><br><em> Kafka<br><br><a href="https://postimg.cc/TpHcT5dg" target="_blank" rel="noopener"><img src="https://i.postimg.cc/mgTpN7KX/WX20190515-221556-2x.png" alt="WX20190515-221556-2x.png"></a></em> RabbitMQ<br><br><a href="https://postimg.cc/yggHrZ8j" target="_blank" rel="noopener"><img src="https://i.postimg.cc/KzQ8j7X6/WX20190515-221940-2x.png" alt="WX20190515-221940-2x.png"></a><br><br><br><br><br><br><br><br><h3>14.高并发解决思路之应用拆分</h3><br><a href="https://postimg.cc/GB5Msxn0" target="_blank" rel="noopener"><img src="https://i.postimg.cc/50xDTsPt/WX20190626-220947-2x.png" alt="WX20190626-220947-2x.png"></a><br><br><br><br><a href="https://postimg.cc/nM0L3NrH" target="_blank" rel="noopener"><img src="https://i.postimg.cc/qMdCvTdC/WX20190704-213601-2x.png" alt="WX20190704-213601-2x.png"></a><br><br><a href="https://postimg.cc/LJvv596c" target="_blank" rel="noopener"><img src="https://i.postimg.cc/yNCGfWq8/WX20190704-213815-2x.png" alt="WX20190704-213815-2x.png"></a><br><br><a href="https://postimg.cc/xJmKvnnT" target="_blank" rel="noopener"><img src="https://i.postimg.cc/gJSNP27R/WX20190704-213920-2x.png" alt="WX20190704-213920-2x.png"></a><br><br><br><br><a href="https://postimg.cc/c62JqwRj" target="_blank" rel="noopener"><img src="https://i.postimg.cc/pXX5FBp2/WX20190704-213959-2x.png" alt="WX20190704-213959-2x.png"></a><br><br><a href="https://postimg.cc/yDJ5M3Tf" target="_blank" rel="noopener"><img src="https://i.postimg.cc/GmzCskT1/WX20190704-214449-2x.png" alt="WX20190704-214449-2x.png"></a><br><br><a href="https://postimg.cc/CRfPPTFX" target="_blank" rel="noopener"><img src="https://i.postimg.cc/T3tzPfBd/WX20190704-214535-2x.png" alt="WX20190704-214535-2x.png"></a><br><br><h3>15.高并发之应用限流思路</h3><p><a href="https://postimg.cc/k2FXL5vt" target="_blank" rel="noopener"><img src="https://i.postimg.cc/sgbQQQBK/WX20190704-221013-2x.png" alt="WX20190704-221013-2x.png"></a></p><p><a href="https://postimg.cc/HrJgHkmL" target="_blank" rel="noopener"><img src="https://i.postimg.cc/13B5G8YD/WX20190704-221221-2x.png" alt="WX20190704-221221-2x.png"></a></p><p><a href="https://postimg.cc/HrB1Q8t3" target="_blank" rel="noopener"><img src="https://i.postimg.cc/KYychn3X/WX20190704-222107-2x.png" alt="WX20190704-222107-2x.png"></a></p><p><a href="https://postimg.cc/S2z0FTbt" target="_blank" rel="noopener"><img src="https://i.postimg.cc/wvw9NZfH/WX20190704-222138-2x.png" alt="WX20190704-222138-2x.png"></a></p><p><a href="https://postimg.cc/Z9BsCWsW" target="_blank" rel="noopener"><img src="https://i.postimg.cc/JhKfYJb5/WX20190704-222258-2x.png" alt="WX20190704-222258-2x.png"></a></p><p><a href="https://postimg.cc/bdDnWQDD" target="_blank" rel="noopener"><img src="https://i.postimg.cc/QNSqBmjb/WX20190704-222545-2x.png" alt="WX20190704-222545-2x.png"></a></p><p></p><h3>16.高并发之服务降级与服务熔断思路</h3><br><img src="https://i.postimg.cc/J0hYqZdq/WX20190707-205833-2x.png" alt><p></p><p><a href="https://postimg.cc/JD4GgdQb" target="_blank" rel="noopener"><img src="https://i.postimg.cc/tTFWsKZm/WX20190707-210322-2x.png" alt="WX20190707-210322-2x.png"></a></p><p><a href="https://postimg.cc/dLv8V9vp" target="_blank" rel="noopener"><img src="https://i.postimg.cc/kXRwwjHJ/WX20190707-213457-2x.png" alt="WX20190707-213457-2x.png"></a></p><p><a href="https://postimg.cc/2bRxFNR8" target="_blank" rel="noopener"><img src="https://i.postimg.cc/d1DSFJ5d/WX20190707-213551-2x.png" alt="WX20190707-213551-2x.png"></a></p><p><a href="https://postimg.cc/hJFmN8C2" target="_blank" rel="noopener"><img src="https://i.postimg.cc/vmTvg35w/WX20190707-213654-2x.png" alt="WX20190707-213654-2x.png"></a></p><p></p><h3>17.高并发之数据库切库分库分表思路</h3><br><a href="https://postimg.cc/mh0mNnMn" target="_blank" rel="noopener"><img src="https://i.postimg.cc/3Jwz75w3/WX20190707-222739-2x.png" alt="WX20190707-222739-2x.png"></a><p></p><p><a href="https://postimg.cc/3WCZmw8k" target="_blank" rel="noopener"><img src="https://i.postimg.cc/pV31N93J/WX20190707-222913-2x.png" alt="WX20190707-222913-2x.png"></a></p><p><a href="https://postimg.cc/TyVKFpHm" target="_blank" rel="noopener"><img src="https://i.postimg.cc/s285BWYn/WX20190707-223004-2x.png" alt="WX20190707-223004-2x.png"></a></p><p><a href="https://postimg.cc/Hj4fnHF2" target="_blank" rel="noopener"><img src="https://i.postimg.cc/CMWYvxNW/WX20190707-223138-2x.png" alt="WX20190707-223138-2x.png"></a></p><p><a href="https://postimg.cc/5XNHT4Wk" target="_blank" rel="noopener"><img src="https://i.postimg.cc/htV9Jvyg/WX20190707-223929-2x.png" alt="WX20190707-223929-2x.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://996.icu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/link-996.icu-red.svg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIFY_6AA3VjT9w7FMAALGfwFCj8AADdWl862.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3&gt;4.线程安全性&lt;/h3&gt;&lt;br&gt;定义：当多个线程访问某个类时，不管运行时环境采用&lt;b&gt;何种调度方式&lt;/b&gt;或者这些进程将如何交替执行，并且在主调代码中&lt;b&gt;不需要任何额外的同步或协同&lt;/b&gt;，这个类都能表现出&lt;b&gt;正确的行为&lt;/b&gt;，那么就称这个类是线程安全的。&lt;br&gt;&lt;br&gt;&lt;em&gt; 原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。
&lt;/em&gt; 可见性：一个线程对主内存的修改可以及时的被其他线程观察到。&lt;br&gt;&lt;em&gt; 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="高并发" scheme="http://yoursite.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下shadowsocks 配合SwitchyOmega科学上网</title>
    <link href="http://yoursite.com/2017/11/03/Ubuntu%E4%B8%8B%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://yoursite.com/2017/11/03/Ubuntu下科学上网/</id>
    <published>2017-11-02T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.867Z</updated>
    
    <content type="html"><![CDATA[<p>最近重新装起了阔别已久的ubuntu，第一件事当然是科学上网啊。大概需要下面几步</p><h3 id="1-一个代理服务账号"><a href="#1-一个代理服务账号" class="headerlink" title="1.一个代理服务账号"></a>1.一个代理服务账号</h3><p>&nbsp;&nbsp;这里我推荐 <a href="https://jikess.org/" target="_blank" rel="noopener">jikess</a>，一个月只需要12大洋，200G代理流量，速度也很客观。自行注册购买，或者也可以先领几十M先体验下。</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/02/08/ChMkJlbKzWGIZIhdAAQNZj09ufQAALJAQMP9cYABA1-499.jpg" alt></p><a id="more"></a><h3 id="2-ubuntu使用shadowsocks"><a href="#2-ubuntu使用shadowsocks" class="headerlink" title="2. ubuntu使用shadowsocks"></a>2. ubuntu使用shadowsocks</h3><p> <b>1.安装shadowsocks命令行程序，配置命令。</b></p><p> 2.安装shadowsocks GUI图形界面程序，配置。<br></p><h4 id="第一种安装shadowsocks命令行程序"><a href="#第一种安装shadowsocks命令行程序" class="headerlink" title="第一种安装shadowsocks命令行程序"></a>第一种安装shadowsocks命令行程序</h4><p>用PIP安装很简单</p><pre><code>sudo apt-get updatesudo apt-get install python-pipsudo apt-get install python-setuptools m2crypto</code></pre><p>接着安装shadowsocks</p><pre><code>pip install shadowsocks</code></pre><p>如果是ubuntu16.04 直接 (16.04 里可以直接用apt 而不用 apt-get 这是一项改进）</p><pre><code>sudo apt install shadowsocks</code></pre><p>当然你在安装时候肯定有提示需要安装一些依赖比如<code>python-setuptools m2crypto</code> ，依照提示安装然后再安装就好。也可以网上搜索有很多教程的。</p><h4>启动shadowsocks</h4><p>安装好后，在本地我们要用到sslocal ，终端输入sslocal –help 可以查看帮助，像这样</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-04%2017-03-17%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>通过帮助提示我们知道各个参数怎么配置，比如 sslocal -c 后面加上我们的json配置文件，或者像下面这样直接命令参数写上运行。</p><p>比如</p><pre><code>sslocal -s 11.22.33.44 -p 50003 -k &quot;123456&quot; -l 1080 -t 600 -m aes-256-cfb</code></pre><p> -s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加””）, -t超时默认300,-m是加密方法默认<code>aes-256-cfb</code>，</p><p> <b>为了方便我推荐直接用sslcoal -c 配置文件路径 这样的方式，简单好用。</b></p><p>我们可以在/home/{user}/ 下新建个文件shadowsocks.json  ({user}是你自己电脑上的用户名)。内容是这样：</p><pre><code>{    &quot;server&quot;:&quot;11.22.33.44&quot;,    &quot;server_port&quot;:50003,    &quot;local_port&quot;:1080,    &quot;password&quot;:&quot;123456&quot;,    &quot;timeout&quot;:600,    &quot;method&quot;:&quot;aes-256-cfb&quot;}</code></pre><p>server  你服务端的IP<br>servier_port  你服务端的端口<br>local_port  本地端口，一般默认1080<br>passwd  ss服务端设置的密码<br>timeout  超时设置 和服务端一样<br>method  加密方法 和服务端一样</p><p>确定上面的配置文件没有问题，然后我们就可以在终端输入 <code>sslocal -c /home/{user}/shadowsocks.json</code> 回车运行。如果没有问题的话，下面会是这样…</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-04%2017-11-06%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h4 id="第二种-安装图形界面"><a href="#第二种-安装图形界面" class="headerlink" title="第二种 安装图形界面"></a>第二种 安装图形界面</h4><p><b>在 Ubuntu下 通过PPA源安装，仅支持Ubuntu 14.04或更高版本。</b></p><pre><code>sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5</code></pre><p>由于是图形界面，配置和windows基本没啥差别就不赘述了。</p><p>经过上面两种方式的配置，你只是启动了sslocal 但是要上网你还需要配置下浏览器到指定到代理端口比如1080才可以正式上网。你可以去系统的代理设置按照说明设置代理，但一般是全局的，然而我们访问baidu,taobao等着些网站如果用代理就有点绕了，而且还会浪费服务器流量。我们最好配置我们的浏览器让它可以自动切换，该用代理用代理该直接连接自动直接连接。所以请看配置浏览器。</p><h3 id="3-配置浏览器（chrome"><a href="#3-配置浏览器（chrome" class="headerlink" title="3.配置浏览器（chrome)"></a>3.配置浏览器（chrome)</h3><p>我们需要给chrome安装SwitchyOmega插件，但是没有代理之前是不能从谷歌商店安装这个插件的，但是我们可以从Github上直接下载最新版 <a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases/</a> （这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。</p><p><b>上面也是我之前一直用的方法，屡试不爽。但是这次不知道为啥在拖进chrome后始终没反应，无法离线安装。于是我决定先配置全局代理，这样chrome可以直接访问谷歌商店，然后再直接在线安装SwitchyOmega，实现代理自动切换的目的。</b></p><h4>先配置全局代理</h4><p>1、安装GenPAC<br>GenPAC 是基于gfwlist的代理自动配置（Proxy Auto-config）文件生成工具，支持自定义规则。在多数情况下，我们更希望使用PAC模式的代理，让我们访问国内网站时不再先绕地球跑一圈，在Windows和Mac上的shadowsocks客户端可以轻松切换到PAC模式，而在Ubuntu上我们需要使用pac文件来设置系统代理以达到相同的效果</p><pre><code>sudo pip install genpacpip install --upgrade genpac</code></pre><p>2、使用GenPAC生成pac文件</p><pre><code>genpac -p &quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output=&quot;autoproxy.pac&quot;</code></pre><p>3、设置全局代理</p><p>点击：System settings &gt; Network &gt; Network Proxy，选择 Method 为 Automatic，设置 Configuration URL 为 autoproxy.pac 文件的路径，点击 Apply System Wide。<br>格式如：<code>file:///home/{user}/autoproxy.pac</code></p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-28-09%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>4、安装switchyOmega<br>  此时应该可以按照一定过滤规则访问外网了，但仍配置下浏览器（毕竟善始善终）</p><p>  <img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-32-26%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h4> 配置switchyOmega</h4><p>1.配置代理地址</p><p>安装好插件会自动跳到设置选项，有提示你可以跳过。左边新建情景模式-选择代理服务器-比如命名为proxy（叫什么无所谓）其他默认之后创建，之后在代理协议选择SOCKS5，地址为127.0.0.1,端口默认1080 。然后保存即应用选项。</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-35-17%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>2.设置自动切换</p><p>接着点击自动切换 ( Auto switch）上面的不用管，在按照规则列表匹配请求后面选择刚才新建的proxy，默认情景模式选择直接连接。点击应用选项保存。再往下规则列表设置选择AutoProxy 然后将这个地址(<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>) 填进去，点击下面的立即更新情景模式，会有提示更新成功！</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-37-58%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p><b>点击浏览器右上角的SwitchyOmega图标，下面选择自动切换，然后打开google.com试试，其他的就不在这贴图了。</b></p><h4>至此shadowsocks搭建完成，天高任鸟飞，海阔任鱼跃。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近重新装起了阔别已久的ubuntu，第一件事当然是科学上网啊。大概需要下面几步&lt;/p&gt;
&lt;h3 id=&quot;1-一个代理服务账号&quot;&gt;&lt;a href=&quot;#1-一个代理服务账号&quot; class=&quot;headerlink&quot; title=&quot;1.一个代理服务账号&quot;&gt;&lt;/a&gt;1.一个代理服务账号&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;这里我推荐 &lt;a href=&quot;https://jikess.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jikess&lt;/a&gt;，一个月只需要12大洋，200G代理流量，速度也很客观。自行注册购买，或者也可以先领几十M先体验下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/02/08/ChMkJlbKzWGIZIhdAAQNZj09ufQAALJAQMP9cYABA1-499.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ShadowSocks" scheme="http://yoursite.com/tags/ShadowSocks/"/>
    
  </entry>
  
  <entry>
    <title>SSH整合过程中的问题</title>
    <link href="http://yoursite.com/2017/01/13/SSH%E6%95%B4%E5%90%88%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/01/13/SSH整合出现的一些异常/</id>
    <published>2017-01-12T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.866Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="首先介绍下博主的工作环境"><a href="#首先介绍下博主的工作环境" class="headerlink" title="首先介绍下博主的工作环境"></a>首先介绍下博主的工作环境</h2><p><strong></strong></p><ul><li>系统：<code>Ubuntu 16.04 LTS</code></li><li>IDE: <code>Myeclispe 2015</code></li><li>Server: <code>Myeclipse2015</code>自带的<code>Myeclipse Tomcat v7.0</code></li><li>框架版本: <code>Struts 2.1</code>  <code>Spring 4.1</code> <code>Hibernate 4.1.4</code></li></ul><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g2/M00/01/0E/Cg-4WlU4niOIChfEAAtm0dNCMiIAACHugPmzzsAC2bp782.jpg" alt></p><a id="more"></a><h2 id="先介绍下-SSH-经典架构（大神请跳过"><a href="#先介绍下-SSH-经典架构（大神请跳过" class="headerlink" title="先介绍下 SSH 经典架构（大神请跳过)"></a>先介绍下 <code>SSH</code> 经典架构（大神请跳过)</h2><p>首先，SSH不是一个框架，而是多个框架（struts+spring+hibernate）的集成，是目前较流行的一种Web应用程序开源集成框架，用于构建灵活、易于扩展的多层Web应用程序。</p><p>集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层（实体层）。</p><p>Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，控制业务跳转，利用Hibernate框架对持久层提供支持。Spring一方面作为一个轻量级的IoC容器，负责查找、定位、创建和管理对象及对象之间的依赖关系，另一方面能使Struts和Hibernate更好地工作。</p><h2 id="以下是最近做项目时遇到的一些问题"><a href="#以下是最近做项目时遇到的一些问题" class="headerlink" title="以下是最近做项目时遇到的一些问题"></a>以下是最近做项目时遇到的一些问题</h2><h3 id="1-Struts2自带的antlr-2-7-2-jar与Hibernate4-1-4自带的antlr-2-7-7-jar发生冲突"><a href="#1-Struts2自带的antlr-2-7-2-jar与Hibernate4-1-4自带的antlr-2-7-7-jar发生冲突" class="headerlink" title="1.Struts2自带的antlr-2.7.2.jar与Hibernate4.1.4自带的antlr-2.7.7.jar发生冲突"></a>1.Struts2自带的<code>antlr-2.7.2.jar</code>与Hibernate4.1.4自带的<code>antlr-2.7.7.jar</code>发生冲突</h3><p>  <strong> 报错内容如下: </strong></p><pre><code>java.lang.NoSuchMethodError: antlr.collections.AST.getLine()I</code></pre><h3 id="这是一个ssh整合的经典bug-解决方案是"><a href="#这是一个ssh整合的经典bug-解决方案是" class="headerlink" title="这是一个ssh整合的经典bug ,解决方案是:"></a>这是一个ssh整合的经典bug ,解决方案是:</h3><p>  <strong> 在Myeclipse2015中打开<code>window -&gt; perference -&gt; project libraries</code>在里面找到<code>struts2.1 Libraries-&gt; core-&gt;  antlr-2.7.2.jar</code> 点击取消勾选这个jar包， 然后点击Apply ，最后重新部署下工程就ok了</strong></p><h3 id="2-Spring事务管理出错"><a href="#2-Spring事务管理出错" class="headerlink" title="2.Spring事务管理出错"></a>2.Spring事务管理出错</h3><p>   <strong> 报错内容如下: </strong></p><pre><code>Write operations are not allowed in read-only mode (FlushMode.MANUAL): Turn your Session into FlushMode.COMMIT/AUTO or remove &apos;readOnly&apos; markerfrom transaction definition.</code></pre><p><strong> 大意是：只读模式下(FlushMode.NEVER/MANUAL)写操作不被允许：把你的Session改成FlushMode.COMMIT/AUTO或者清除事务定义中的readOnly标记。</strong></p><h3 id="解决方案是-配置Spring的事务管理"><a href="#解决方案是-配置Spring的事务管理" class="headerlink" title="解决方案是:配置Spring的事务管理"></a>解决方案是:配置Spring的事务管理</h3><p>  在applicationContext.xml中加入</p><pre><code>&lt;tx:advice id=&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;&lt;tx:attributes&gt;  &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;modify*&quot; propagation=&quot;REQUIRED&quot;    rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt;&lt;aop:pointcut id=&quot;daoMethod&quot; expression=&quot;execution(* com.muke.employee.daoImpl.*.*(..))&quot; /&gt;&lt;aop:advisor pointcut-ref=&quot;daoMethod&quot; advice-ref=&quot;txadvice&quot; /&gt;&lt;/aop:config&gt;</code></pre><ul><li><code>expression=&quot;execution( com.dao..(..))&quot;</code>其中第一个<em>代表返回值，第二代表daoImpl下子包，第三个代表方法名，“（..）”代表方法参数。</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;首先介绍下博主的工作环境&quot;&gt;&lt;a href=&quot;#首先介绍下博主的工作环境&quot; class=&quot;headerlink&quot; title=&quot;首先介绍下博主的工作环境&quot;&gt;&lt;/a&gt;首先介绍下博主的工作环境&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统：&lt;code&gt;Ubuntu 16.04 LTS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;IDE: &lt;code&gt;Myeclispe 2015&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Server: &lt;code&gt;Myeclipse2015&lt;/code&gt;自带的&lt;code&gt;Myeclipse Tomcat v7.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;框架版本: &lt;code&gt;Struts 2.1&lt;/code&gt;  &lt;code&gt;Spring 4.1&lt;/code&gt; &lt;code&gt;Hibernate 4.1.4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g2/M00/01/0E/Cg-4WlU4niOIChfEAAtm0dNCMiIAACHugPmzzsAC2bp782.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="http://yoursite.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架整合</title>
    <link href="http://yoursite.com/2017/01/10/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
    <id>http://yoursite.com/2017/01/10/SSM框架整合/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.867Z</updated>
    
    <content type="html"><![CDATA[<hr><b>这里的SSM指的是（<code>Spring-Springmvc-Mybatis</code>)三大框架</b><h4>前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;我们看招聘信息的时候，经常会看到这一点，需要具备<code>SSH</code>(<code>Struts-Spring-Hibernate</code>)框架的技能；而且在大部分教学课堂中，也会把<code>SSH</code>作为最核心的教学内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;但是，我们在实际应用中发现，<code>SpringMVC</code>可以完全替代<code>Struts</code>，配合注解的方式，编程非常快捷，而且通过restful风格定义url，让地址看起来非常优雅。<br>&nbsp;&nbsp;&nbsp;&nbsp;另外，<code>MyBatis</code>也可以替换<code>hibernate</code>，正因为<code>MyBatis</code>的半自动特点，我们程序猿可以完全掌控SQL，这会让有数据库经验的程序猿能开发出高效率的SQL语句，而且XML配置管理起来也非常方便。<br>&nbsp;&nbsp;&nbsp;&nbsp;下面我们开始进行SSM框架的整合。</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIJK4PAAfFWxl1L9IAALJAQM0wFQAB8Vz309.jpg" alt></p><a id="more"></a><p></p><h4>介绍</h4><br>在整合之前先介绍一下这三个框架，之前有了解的可以跳过.这里尽量通俗易懂的简单讲解一下。<p></p><ul><li><p>Springmvc<br>  &nbsp;&nbsp;&nbsp;&nbsp;它用于web层，相当于controller（等价于传统的servlet和struts的action），用来处理用户请求。举个例子，用户在地址栏输入<a href="http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法，（中间可能包含验证用户名和密码的业务逻辑，以及查询数据库操作，但这些都不是springmvc的职责），最终把结果返回给用户，并且返回相应的页面（当然也可以只反馈josn/xml等格式数据）。springmvc就是做前面和后面过程的活，与用户打交道！！" target="_blank" rel="noopener">http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法，（中间可能包含验证用户名和密码的业务逻辑，以及查询数据库操作，但这些都不是springmvc的职责），最终把结果返回给用户，并且返回相应的页面（当然也可以只反馈josn/xml等格式数据）。springmvc就是做前面和后面过程的活，与用户打交道！！</a></p></li><li><p>Spring<br>&nbsp;&nbsp;&nbsp;&nbsp; 太强大了，以至于我无法用一个词或一句话来概括它。但与我们平时开发接触最多的估计就是IOC容器，它可以装载bean（也就是我们Java中的类，当然也包括service dao里面的），有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。</p></li></ul><ul><li>Mybatis<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你问我它跟鼎鼎大名的Hibernate有什么区别？我只想说，他更符合我的需求。第一，它能自由控制sql，这会让有数据库经验的人编写的代码能搞提升数据库访问的效率。第二，它可以使用xml的方式来组织管理我们的sql，因为一般程序出错很多情况下是sql出错，别人接手代码后能快速找到出错地方，甚至可以优化原来写的sql。</li></ul><p></p><h4>SSM框架整合配置</h4><br>&nbsp;&nbsp;&nbsp;&nbsp;首先在Myeclipse中建立一个<code>Maven Web</code>工程。(对这步有疑问的可以看我之前的博客<a href="http://blog.pockerface.cn/2016/10/20/使用项目管理利器Maven/" target="_blank" rel="noopener">使用项目管理工具 <code>Maven</code></a>)<br>这是相应的项目目录<p></p><center><br><img src="http://7xta11.com1.z0.glb.clouddn.com/SSM.png" alt><br></center><br><strong>这里介绍下Maven目录规范下各目录的作用</strong><br><del>====</del><br><br>| 文件名           | 作用          |<br>| ————- |:————-:|<br>|src           |根目录，没什么好说的，下面有main和test |<br>|main    |主要目录，可以放java代码和一些资源文件|<br>|java    |存放我们的java代码 |<br>|resources    | 存放资源文件，譬如各种的spring，mybatis，log配置文件|<br>mapper    |存放dao中每个方法对应的sql，在这里配置，无需写daoImpl|<br>|spring        |这里当然是存放spring相关的配置文件，有dao service web三层|<br>|test    |这里是测试分支|<br>|java    |测试java代码，应遵循包名相同的原则，这个文件夹同样要使用Build Path -&gt; Use as Source Folder，这样看包结构会方便很多|<br>|resources    |没什么好说的，好像也很少用到，但这个是maven的规范|<br>webapp    |用来存放我们前端的静态资源，如jsp js css|<br>|resources    |这里的资源是指项目的静态资源，如js css images等|<br>|WEB-INF    |很重要的一个目录，外部浏览器无法访问，只有羡慕内部才能访问，可以把jsp放在这里，另外就是web.xml了。你可能有疑问了，为什么上面java中的resources里面的配置文件不妨在这里，那么是不是会被外部窃取到？你想太多了，部署时候基本上只有webapp里的会直接输出到根目录，其他都会放入WEB-INF里面，项目内部依然可以使用classpath:XXX来访问，好像IDE里可以设置部署输出目录|<br><br><strong>讲解几个必要的包，顺便讲解一下每个包的作用.</strong><br><center><br><img src="http://7xta11.com1.z0.glb.clouddn.com/SSM2.png" alt><br></center><table><thead><tr><th>包名</th><th style="text-align:center">名称</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td>dao</td><td style="text-align:center">数据访问层（接口）</td><td style="text-align:right">与数据打交道，可以是数据库操作，也可以是文件读写操作，甚至是redis缓存操作，总之与数据操作有关的都放在这里，也有人叫做dal或者数据持久层都差不多意思。为什么没有daoImpl，因为我们用的是mybatis，所以可以直接在配置文件中实现接口的每个方法。</td></tr><tr><td>entity</td><td style="text-align:center">实体类</td><td style="text-align:right">一般与数据库的表相对应，封装dao层取出来的数据为一个对象，也就是我们常说的pojo，一般只在dao层与service层之间传输</td></tr><tr><td>dto</td><td style="text-align:center">数据传输层</td><td style="text-align:right">刚学框架的人可能不明白这个有什么用，其实就是用于service层与web层之间传输，为什么不直接用entity（pojo）？其实在实际开发中发现，很多时候一个entity并不能满足我们的业务需求，可能呈现给用户的信息十分之多，这时候就有了dto，也相当于vo，记住一定不要把这个混杂在entity里面</td></tr><tr><td>service</td><td style="text-align:center">业务逻辑（接口）</td><td style="text-align:right">写我们的业务逻辑，也有人叫bll，在设计业务接口时候应该站在“使用者”的角度</td></tr><tr><td>impl</td><td style="text-align:center">业务逻辑（实现）</td><td style="text-align:right">实现我们业务接口，一般事务控制是写在这里</td></tr><tr><td>web</td><td style="text-align:center">控制器</td><td style="text-align:right">springmvc就是在这里发挥作用的，一般人叫做controller控制器，相当于struts中的action</td></tr></tbody></table><p><strong>添加依赖</strong><br>    SSM整合需要导入相应的jar包,我们使用maven来管理我们的jar，所以只需要在<code>pom.xml</code>中加入相应的依赖。如果没有使用maven的话,可以自己去官网下载相应的jar包，然后放到项目的WEB-INF/lib目录下.</p><p><b>三个主要框架版本</b></p><ul><li><code>Spring---4.3.3.RELEASE</code><ul><li><code>spring mvc ---- 4.3.3.RELEASE</code></li><li><code>mybatis ---- 3.2.5</code></li></ul></li></ul><p><b>其他</b></p><ul><li><p><code>junit ---- 4.8.1</code></p></li><li><p><code>MySQL ---- 5.1.38</code></p></li><li><p><code>log4j ---- 1.2.17</code></p></li><li><p><code>c3p0 ---- 0.9.2.1</code></p></li><li><p><code>mybatis-spring ---- 1.3.0</code>  </p></li><li><p><code>jstl ---- 1.2</code></p></li></ul><p><b>pom.xml文件如下</b></p><pre><code>  &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.fendo.ssm&lt;/groupId&gt;    &lt;artifactId&gt;fendo-SSM&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;fendo-SSM Maven Webapp&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;      &lt;!-- 初始化框架的版本号 --&gt;      &lt;properties&gt;          &lt;spring.version&gt;4.3.3.RELEASE&lt;/spring.version&gt;      &lt;/properties&gt;    &lt;dependencies&gt;      &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;3.8.1&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;      &lt;/dependency&gt;           &lt;!-- 加入ServletAPI --&gt;          &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;          &lt;dependency&gt;              &lt;groupId&gt;javax.servlet&lt;/groupId&gt;              &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;              &lt;version&gt;2.3&lt;/version&gt;              &lt;scope&gt;provided&lt;/scope&gt;          &lt;/dependency&gt;          &lt;!-- MySQL依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;mysql&lt;/groupId&gt;              &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;              &lt;version&gt;5.1.38&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- MySQL依赖 end --&gt;          &lt;!-- 加入MyBatis 依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.mybatis&lt;/groupId&gt;              &lt;artifactId&gt;mybatis&lt;/artifactId&gt;              &lt;version&gt;3.2.5&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 加入MyBatis 依赖 end --&gt;          &lt;!-- Log4j start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;log4j&lt;/groupId&gt;              &lt;artifactId&gt;log4j&lt;/artifactId&gt;              &lt;version&gt;1.2.17&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- Log4j end --&gt;             &lt;!-- 引入Spring(包含SpringMVC) 依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-core&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-web&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-test&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 引入Spring 依赖 end --&gt;          &lt;!-- 引用c3p0 依赖 start--&gt;          &lt;dependency&gt;              &lt;groupId&gt;com.mchange&lt;/groupId&gt;              &lt;artifactId&gt;c3p0&lt;/artifactId&gt;              &lt;version&gt;0.9.2.1&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 引用c3p0 依赖 end--&gt;          &lt;!-- 引用插件依赖：MyBatis整合Spring --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.mybatis&lt;/groupId&gt;              &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;              &lt;version&gt;1.3.0&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- JSTL --&gt;          &lt;dependency&gt;              &lt;groupId&gt;jstl&lt;/groupId&gt;              &lt;artifactId&gt;jstl&lt;/artifactId&gt;              &lt;version&gt;1.2&lt;/version&gt;          &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;      &lt;finalName&gt;fendo-SSM&lt;/finalName&gt;      &lt;plugins&gt;        &lt;!-- 加入Tomcat插件 --&gt;          &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;                  &lt;configuration&gt;                       &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt;                      &lt;username&gt;admin&lt;/username&gt;                        &lt;password&gt;admin&lt;/password&gt;                  &lt;/configuration&gt;           &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/build&gt;  &lt;/project&gt;</code></pre><p>   </p><h4>编码配置文件</h4><br>      <b>第一步：</b>我们先在spring文件夹里新建<code>spring-dao.xml</code>文件，因为spring的配置太多，我们这里分三层，分别是dao, service , web.<p></p><ol><li>读入数据库连接相关参数（可选）</li><li><p>配置数据连接池</p><ol><li>配置连接属性，可以不读配置项文件直接在这里写死</li><li>配置c3p0，只配了几个常用的</li></ol></li><li><p>配置SqlSessionFactory对象（mybatis）</p></li><li><p>扫描dao层接口，动态实现dao接口，也就是说不需要daoImpl，sql和参数都写在xml文件上</p><p><b>spring-dao.xml</b></p></li></ol><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     &quot;&gt;     &lt;context:annotation-config /&gt;    &lt;!-- 配置整合MyBatis过程 --&gt;    &lt;!-- 1.配置数据库相关参数properties的属性:${url} --&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;    &lt;!--2.数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!-- 配置连接池属性 --&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;        &lt;!-- c3p0私有属性 --&gt;        &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;&gt;&lt;/property&gt;        &lt;!-- 关闭连接后不自动commit --&gt;        &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;&gt;&lt;/property&gt;        &lt;!-- 获取连接超时时间 --&gt;        &lt;property name=&quot;checkoutTimeout&quot; value=&quot;1000&quot;&gt;&lt;/property&gt;        &lt;!-- 当获取连接失败重试次数 --&gt;        &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 3.配置sqlSessionFactory对象 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 注入数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;        &lt;!-- 配置MyBatis全局配置文件:myBatis-config.xml --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;        &lt;!-- 扫描entity包，使用别名 --&gt;        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;org.seckill.entity&quot;&gt;&lt;/property&gt;        &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!-- 注入sqlSessionFactory --&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;        &lt;!-- 给出需要扫描的Dao接口包 --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.blog.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>&nbsp;&nbsp;因为数据库配置相关参数是读取配置文件，所以在resources文件夹里新建一个jdbc.properties文件，存放我们4个最常见的数据库连接属性，这是我本地的，大家记得修改.如果大家上传github时记得删掉密码，不然别人就很容易得到你服务器的数据库配置信息.    </p><p><b>jdbc.properties</b></p><pre><code>jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://127.0.0.1\:3306/personBlogjdbc.username=rootjdbc.password=</code></pre><p><b>友情提示：</b>配置文件中的jdbc.username，如果写成username，可能会与系统环境中的username变量冲突，所以到时候真正连接数据库的时候，用户名就被替换成系统中的用户名（有得可能是administrator），那肯定是连接不成功的，这里有个小坑,需要大家注意.</p><p>这里用到了mybatis,所以接下来需要配置mybatis核心文件,在<code>resources</code>文件夹下新建<code>mybatis-config.xml</code>文件</p> <li>  使用自增主键</li><br><li> 使用列别名</li><br> <li>   开启驼峰命名转换 create_time -&gt; createTime</li><p><b>mybatis-config.xml</b></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 配置全局属性 --&gt;    &lt;settings&gt;        &lt;!-- 使用jdbc的getGenerateKeys获取数据库自增主键 --&gt;        &lt;setting name=&quot;useGererateKeys&quot; value=&quot;true&quot; /&gt;        &lt;!-- 使用列别名替换列名 默认：true --&gt;        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt;        &lt;!-- 开启驼峰命名转换 --&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt;    &lt;/settings&gt;&lt;/configuration&gt;</code></pre><p><b>第二步:</b>刚弄好dao层，接下来到service层了。在spring文件夹里新建<code>spring-service.xml</code>文件。    </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;                 xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans             http://    www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     &quot;&gt;    &lt;!-- 扫描service包下所有使用注解的类型 --&gt;    &lt;context:component-scan base-package=&quot;com.blog.service&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 注入事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot;        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!-- 注入数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置基于注解的声明式事务 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt;</code></pre><p><b>第三步:</b>配置web层，在spring文件夹里新建spring-web.xml文件.</p><ol><li><p>开启SpringMVC注解模式，可以使用@RequestMapping，@PathVariable，@ResponseBody等</p><ol><li>对静态资源处理，如js，css，jpg等</li><li>配置jsp 显示ViewResolver，例如在controller中某个方法返回一个string类型的 “login”，实际上会返回”/WEB-INF/login.jsp”</li><li>扫描web层 @Controller</li></ol><p><b>spring-web.xml</b></p></li></ol><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     http://www.springframework.org/schema/mvc     http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd     &quot;&gt;    &lt;!-- 配置springMVC --&gt;    &lt;!-- 1:开启springMVC注解模式 --&gt;    &lt;!-- 简化配置： （1）自动注册DefaultAnnotationHandlerMapping,AnnotationMethodHandlerAdapter         (2)提供一系列：数据绑定，数字和日期的format @NumberFormat ,@DataTimeFormat ,xml ,json默认读写支持 --&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!-- 2.静态资源默认servlet配置        1：允许加入对静态资源的处理：js,gif,png        2:允许使用&quot;/&quot;做整体映射     --&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!--3：配置jsp 显示ViewResolver--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 4:扫描web相关的bean --&gt;    &lt;context:component-scan base-package=&quot;org.seckill.web&quot;/&gt;&lt;/beans&gt;</code></pre><p>  <b>第四步:</b>最后就是修改web.xml文件了，它在webapp的<code>WEB-INF</code>下。<br><b>web.xml</b></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;&lt;!-- maven命令创建的servlet版本较低，默认没有打开JSTL，所以更改servlet版本为3.0 --&gt;  &lt;!-- 配置DispatcherServlet --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;blog-dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- 配置springMVC需要加载的配置文件            spring-dao.xml ,spring-service.xml ,spring-web.xml            Mybatis -&gt;spring -&gt;springMVC         --&gt;         &lt;init-param&gt;             &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;             &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;         &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;blog-dispatcher&lt;/servlet-name&gt;        &lt;!-- 默认匹配所有请求 --&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>我们在项目中经常会使用到日志，所以这里还有配置日志xml，在<code>resources</code>文件夹里新建<code>logback.xml</code>文件，所给出的日志输出格式也是最基本的控制台呼出，大家有兴趣查看<code>logback官方文档</code>。</p><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;configuration debug=&quot;true&quot;&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!-- encoders are by default assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n            &lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=&quot;debug&quot;&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;&lt;/configuration&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;b&gt;这里的SSM指的是（&lt;code&gt;Spring-Springmvc-Mybatis&lt;/code&gt;)三大框架&lt;/b&gt;

&lt;h4&gt;前言&lt;/h4&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们看招聘信息的时候，经常会看到这一点，需要具备&lt;code&gt;SSH&lt;/code&gt;(&lt;code&gt;Struts-Spring-Hibernate&lt;/code&gt;)框架的技能；而且在大部分教学课堂中，也会把&lt;code&gt;SSH&lt;/code&gt;作为最核心的教学内容。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;但是，我们在实际应用中发现，&lt;code&gt;SpringMVC&lt;/code&gt;可以完全替代&lt;code&gt;Struts&lt;/code&gt;，配合注解的方式，编程非常快捷，而且通过restful风格定义url，让地址看起来非常优雅。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;另外，&lt;code&gt;MyBatis&lt;/code&gt;也可以替换&lt;code&gt;hibernate&lt;/code&gt;，正因为&lt;code&gt;MyBatis&lt;/code&gt;的半自动特点，我们程序猿可以完全掌控SQL，这会让有数据库经验的程序猿能开发出高效率的SQL语句，而且XML配置管理起来也非常方便。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下面我们开始进行SSM框架的整合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIJK4PAAfFWxl1L9IAALJAQM0wFQAB8Vz309.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb三大框架之Hibernate初识</title>
    <link href="http://yoursite.com/2017/01/01/JavaWeb%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8BHibernate%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2017/01/01/JavaWeb三大框架之Hibernate初识/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.865Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>ORM</strong><br>    <code>ORM (Object / Relationship Mapping)</code> : 对象/关系映射<br>    </p><p>它的好处是使让习惯于面向对象编程的开发人员少写于底层数据库有关的<code>sql</code>语句，方便了程序的维护与修改，及跨平台性。</p><p></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/0A/ChMkJ1bKzzSIOgDcAAj_4khgui4AALJSwDm3zIACP_6935.jpg" alt></p><a id="more"></a><hr><p><strong>Hibernate</strong><br>    <code>Hibernate</code>就是<code>Java</code>中一种成熟的基于<code>ORM</code>的框架</p><hr><p><strong>Hibernate开发的基本步骤</strong></p><ol><li>编写配置文档 <code>hibernate.cfg.xml</code></li><li>编写实体类 (需要遵循<code>JavaBean</code>的设计规范)</li><li>生成对应实体类的映射文件（如 <code>Student</code>类的映射文件<code>Student.hbm.xml</code>)并添加到配置文档<code>hibernate.cfg.xml</code>中 </li><li>调用<code>Hibernate API</code>进行测试</li></ol><hr><p><strong>Session</strong></p><p><code>Hibernate</code>对数据库的操作都需要使用到<code>Session</code>对象，就类似于<code>JDBC</code>开发中的<code>Connection</code>对象。本质上讲<code>Hibernate</code>操作数据库，就是通过调用<code>Session</code>对象的各种函数实现的。</p><p>单表操作的常用方法：<code>save . delete .  update .  get / load</code>对应相应的<code>增删查改</code></p><p>其中查询方法<code>get</code>与<code>load</code>的主要区别在于：<code>get</code>在使用的时候立即发送<code>sql</code>语句，且获得的就是实体类的对象类型。而<code>load</code>是在使用到对象的非主键属性时才会发送sql语句，且它返回的是一个代理对象.</p><pre><code>Writren on 6.April.2016 Rainday</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;ORM&lt;/strong&gt;&lt;br&gt;    &lt;code&gt;ORM (Object / Relationship Mapping)&lt;/code&gt; : 对象/关系映射&lt;br&gt;    &lt;/p&gt;&lt;p&gt;它的好处是使让习惯于面向对象编程的开发人员少写于底层数据库有关的&lt;code&gt;sql&lt;/code&gt;语句，方便了程序的维护与修改，及跨平台性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/0A/ChMkJ1bKzzSIOgDcAAj_4khgui4AALJSwDm3zIACP_6935.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate" scheme="http://yoursite.com/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 笔记</title>
    <link href="http://yoursite.com/2016/12/20/Mysql%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/12/20/Mysql笔记/</id>
    <published>2016-12-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.866Z</updated>
    
    <content type="html"><![CDATA[<h4>外键(foreign key)</h4><p>定义:如果一个实体的某个字段指向另一个实体的主键,这个字段就是这个实体的外键.</p><p>&nbsp;&nbsp;被指向的实体，称之为主实体(主表),也叫父实体(父表).<br>&nbsp;&nbsp;负责指向的实体，称之为从实体(从表),也叫子实体(子表).</p><center><br><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIGD1xAAlbi8UmgHEAALJAQMblhoACVuj729.jpg" alt><br></center> <a id="more"></a><h4>一 : 外键约束</h4><p> MySQL通过外键约束来保证表与表之间的数据的<code>完整性</code>和<code>准确性</code>。</p> <h4>外键使用条件</h4><ul><li><p>两个表必须是InnoDB表，MyISAM表暂时不支持外键（据说以后的版本有可能支持，但至少目前不支持）</p><ul><li><p>外键列必须建立了索引，MySQL 4.1.2以后的版本在建立外键时会自动创建索引，但如果在较早的版本则需要显示建立</p></li><li><p>外键关系的两个表的列必须是数据类型相似，也就是可以相互转换类型的列，比如int和tinyint可以，而int和char则不可以</p></li></ul><p>外键的好处 : 可以使得两张表关联，保证数据的一致性和实现一些级联操作.</p><h4>创建外键语法:</h4><p>  [CONSTRAINT [symbol]] FOREIGN KEY<br>[index_name] (index_col_name, …)<br>REFERENCES tbl_name (index_col_name,…)<br>[ON DELETE reference_option]<br>[ON UPDATE reference_option]</p></li></ul><p>例如:</p><pre><code>&lt;!--Blog表  子表--&gt;   CREATE TABLE `t_blog` (  `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &apos;博客类型&apos;,  `title` VARCHAR(200) NOT NULL COMMENT &apos;博客题目&apos;,  `summary` VARCHAR(400) DEFAULT NULL COMMENT &apos;博客摘要&apos;,  `releaseDate` DATETIME DEFAULT NULL COMMENT &apos;发布日期&apos;,  `clickHit` INT(11) DEFAULT NULL COMMENT &apos;评论次数&apos;,  `replyHit` INT(11) DEFAULT NULL COMMENT &apos;回复次数&apos;,  `content` TEXT COMMENT &apos;博客内容&apos;,  `keyWord` VARCHAR(200) DEFAULT NULL COMMENT &apos;关键字&apos;,  `type_id` INT(11) DEFAULT NULL COMMENT &apos;外键关联博客类别&apos;,  PRIMARY KEY (`id`),  KEY `type_id` (`type_id`),  CONSTRAINT `t_blog_ibfk_1` FOREIGN KEY (`type_id`) REFERENCES `t_blogtype` (`id`)   //创建外键) ENGINE=INNODB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8;&lt;!--BlogType表  父表--&gt;  CREATE TABLE `t_blogtype` (  `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &apos;博客id&apos;,  `typeName` VARCHAR(30) DEFAULT NULL COMMENT &apos;博客类别&apos;,  `orderNum` INT(11) DEFAULT NULL COMMENT &apos;博客排序&apos;,  PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;</code></pre><p><b>注意:</b></p><p>&nbsp;&nbsp;如果子表试图创建一个在父表中不存在的外键值，InnoDB会拒绝任何<code>INSERT</code>或<code>UPDATE</code>操作。如果父表试图<code>UPDATE</code>或者<code>DELETE</code>任何子表中存在或匹配的外键值，最终动作取决于外键约束定义中的<code>ON UPDATE</code>和<code>ON DELETE</code>选项。InnoDB支持5种不同的动作，如果没有指定<code>ON DELETE</code>或者<code>ON UPDATE</code>，默认的动作为<code>RESTRICT</code>:</p><ol><li><p><code>CASCADE</code>:从父表中删除或更新对应的行，同时自动的删除或更新子表中匹配的行。<code>ON DELETE CANSCADE</code>和<code>ON UPDATE CANSCADE</code>都被InnoDB所支持。</p><ol><li><p><code>SET NULL</code>: 从父表中删除或更新对应的行，同时将子表中的外键列设为空。注意，这些在外键列没有被设为NOT NULL时才有效。<code>ON DELETE SET NULL</code>和<code>ON UPDATE SET SET NULL</code>都被InnoDB所支持。</p></li><li><p><code>NO ACTION</code>: InnoDB拒绝删除或者更新父表。</p></li><li><p><code>RESTRICT</code>: 拒绝删除或者更新父表。指定RESTRICT（或者NO ACTION）和忽略<code>ON DELETE</code>或者<code>ON UPDATE</code>选项的效果是一样的。</p></li><li><p><code>SET DEFAULT</code>: InnoDB目前不支持。</p></li></ol><p><b>外键约束使用最多的两种情况：</b></p><ol><li>父表更新时子表也更新，父表删除时如果子表有匹配的项，删除失败.</li></ol></li><li><p>父表更新时子表也更新，父表删除时子表匹配的项也删除。</p><p>前一种情况，在外键定义中，我们使用<code>ON UPDATE CASCADE ON DELETE RESTRICT</code>；</p><p>后一种情况，可以使用<code>ON UPDATE CASCADE ON DELETE CASCADE</code>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;外键(foreign key)&lt;/h4&gt;

&lt;p&gt;定义:如果一个实体的某个字段指向另一个实体的主键,这个字段就是这个实体的外键.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;被指向的实体，称之为主实体(主表),也叫父实体(父表).&lt;br&gt;&amp;nbsp;&amp;nbsp;负责指向的实体，称之为从实体(从表),也叫子实体(子表).&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIGD1xAAlbi8UmgHEAALJAQMblhoACVuj729.jpg&quot; alt&gt;&lt;br&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat绑定域名发布应用</title>
    <link href="http://yoursite.com/2016/10/30/tomcat%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%E5%8F%8A%E5%8F%91%E5%B8%83%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/10/30/tomcat绑定域名及发布应用/</id>
    <published>2016-10-30T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<hr><p><b>我们使用<code>Tomcat</code>发布应用时，默认是绑定在<code>8080</code>端口，这种情况一般在测试后使用。如果应用需要部署到服务器上则需要修改端口为<code>80</code>，并通过域名直接访问。具体如何做呢？<br></b></p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/ChMkJ1cghZGIbfOAAARV4Pwpv4QAAQsDQJ9YssABFX4485.jpg" alt></p><h4 id="打包应用为war"><a href="#打包应用为war" class="headerlink" title="打包应用为war"></a>打包应用为war</h4><p><b>首先打包应用为.war文件，具体步骤为在<code>Myeclipse</code>中点击<code>File-&gt;Export</code>选择<code>web-&gt;war file</code>下一步之后选择要打包的应用，重命名为发布名称，比如<code>test.war</code>确定之后即打包。</b></p><a id="more"></a><p><b>我们把War包传到主机上去，放到Tomcat的webapps下，启动tomcat的startup.bat，会自动解压项目；到了这里，还不够。我们只能通过 <a href="http://外网IP:8080/项目名称访问；" target="_blank" rel="noopener">http://外网IP:8080/项目名称访问；</a> (<a href="http://外网IP:8080/项目名称访问；" target="_blank" rel="noopener">http://外网IP:8080/项目名称访问；</a>)</b></p><p><strong>我们现在要干两个事情，第一个是去掉端口，第二个是去掉项目名称。</strong></p><h4 id="配置容器"><a href="#配置容器" class="headerlink" title="配置容器"></a>配置容器</h4><h4>1.这里是在本地调试时的修改，真正部署可以跳过这段，看下个段落</h4><p>修改tomcat安装目录下的conf下的server.xml</p><blockquote><p>找到Connector节点，将其port改为80后保存，结果如下：</p></blockquote><pre><code>&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;        connectionTimeout=&quot;20000&quot;        redirectPort=&quot;8443&quot; /&gt;</code></pre><blockquote><p>绑定域名</p></blockquote><p>这里博主假设域名是<code>testphoto.com</code><em>(注意域名没有大小写之分，就算是大写也会被浏览器解析成小写)</em> 要绑定的项目时WebPhoto</p><p><b>1.首先因为是在本地访问该域名，所以需要修改Hosts文件，ubuntu系统下修改/<code>etc/hosts</code>加上一条记录</b></p><pre><code>127.0.0.1      testphoto.com</code></pre><p><b>2.之后修改server.xml文件</b></p><p>  找到 Engine节点,在里面添加一个 Host 节点，Engine其中有一个默认的<code>Hostname=&quot;localhost&quot;</code>的Host 节点，增添的Host节点:</p><pre><code>&lt;Host name=&quot;testphoto.com&quot;   appBase=&quot;webapps&quot;      unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;&lt;/Host&gt;</code></pre><p>此时在启动tomcat后，输入绑定的域名<code>testphoto.com</code>就可以看到tomcat了，但是要访问我们的项目，还是要在后面加上项目名称，<br>如<code>testphoto.com/WebPhoto</code></p><p><b>3.绑定项目到域名</b></p><p>  在第二步的基础上，在<host>节点中加入下面的配置</host></p><pre><code>&lt;Context path=&quot;/&quot; docBase=&quot;/opt/tomcat7/webapps/WebPhoto&quot;&gt;&lt;/Context&gt;</code></pre><p>  <code>docBase</code>是你的应用的绝对路径。</p><h4 id="此时通过testphoto-com就可以访问你的页面了"><a href="#此时通过testphoto-com就可以访问你的页面了" class="headerlink" title="此时通过testphoto.com就可以访问你的页面了"></a>此时通过<code>testphoto.com</code>就可以访问你的页面了</h4><p><img src="http://7xta11.com1.z0.glb.clouddn.com/1.png" alt></p><h4>2.真正部署应用到网上的配置</h4><p>  和在本地调试配置步骤一样，只不过这里是在服务器上配置。</p><blockquote><p>修改端口，改成80端口</p></blockquote><pre><code>&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;        connectionTimeout=&quot;20000&quot;        redirectPort=&quot;8443&quot; /&gt;</code></pre><blockquote><p>绑定域名</p></blockquote><pre><code>&lt;Host name=&quot;top.pockerface.cn&quot;  appBase=&quot;webapps&quot;        unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;&lt;Context path=&quot;/&quot; docBase=&quot;/opt/tomcat7/webapps/WebPhoto&quot;&gt;&lt;/Context&gt;&lt;/Host&gt;</code></pre><p><b>这里的<code>top.pockerface.cn</code>是博主的二级域名，需要在DNS解析中，解析域名指向你的服务器。</b></p><h4 id="此时通过top-pockerface-cn就可以访问你的页面了"><a href="#此时通过top-pockerface-cn就可以访问你的页面了" class="headerlink" title="此时通过top.pockerface.cn就可以访问你的页面了"></a>此时通过<code>top.pockerface.cn</code>就可以访问你的页面了</h4><p><img src="http://7xta11.com1.z0.glb.clouddn.com/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;b&gt;我们使用&lt;code&gt;Tomcat&lt;/code&gt;发布应用时，默认是绑定在&lt;code&gt;8080&lt;/code&gt;端口，这种情况一般在测试后使用。如果应用需要部署到服务器上则需要修改端口为&lt;code&gt;80&lt;/code&gt;，并通过域名直接访问。具体如何做呢？&lt;br&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xta11.com1.z0.glb.clouddn.com/ChMkJ1cghZGIbfOAAARV4Pwpv4QAAQsDQJ9YssABFX4485.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;打包应用为war&quot;&gt;&lt;a href=&quot;#打包应用为war&quot; class=&quot;headerlink&quot; title=&quot;打包应用为war&quot;&gt;&lt;/a&gt;打包应用为war&lt;/h4&gt;&lt;p&gt;&lt;b&gt;首先打包应用为.war文件，具体步骤为在&lt;code&gt;Myeclipse&lt;/code&gt;中点击&lt;code&gt;File-&amp;gt;Export&lt;/code&gt;选择&lt;code&gt;web-&amp;gt;war file&lt;/code&gt;下一步之后选择要打包的应用，重命名为发布名称，比如&lt;code&gt;test.war&lt;/code&gt;确定之后即打包。&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>解决Ubuntu下搜狗输入法无法输入中文问题</title>
    <link href="http://yoursite.com/2016/10/20/%E8%A7%A3%E5%86%B3ubuntu%E4%B8%8B%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/10/20/解决ubuntu下搜狗输入法无法输入中文问题/</id>
    <published>2016-10-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<h1>解决ubuntu16.04下搜狗输入法无法输入中文问题</h1><p>今天打开电脑,突然发现一直正常使用的搜狗输入法无法无法输入中文(<b>具体现象是，可以呼出搜狗输入法界面，但是候选词列表无显示</b>).在查阅了别人的博客后解决了这个问题，下面是解决方案.</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/0D/06/ChMkJ1ojqAGISeb1AAexeXbMtcgAAiwQAPGnzMAB7GR200.jpg" alt></p><a id="more"></a><p>我的版本号:</p><ul><li>OS：<code>Ubuntu16.04LST</code></li><li>搜狗版本:<code>sogoupinyin_2.1.0.0082_amd64.deb</code><br><center><br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1490240967&amp;di=a8c79abaa880c6efe8cd7a471576e4b1&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fwww.xiazaizhijia.com%2Fuploads%2Fallimg%2F140217%2F36-14021GAA2615.png" alt></center></li></ul><p></p><p></p><h3>方法一:</h3><br>重启搜狗输入法,看是否有效<p></p><pre><code>~$ killall fcitx~$ killall sogou-qinpanel~$ fcitx</code></pre><p></p><h3>方法二：检查修复安装依赖</h3><br>我本机依赖完好,所以应该不是依赖的问题。但如果刚安装搜狗无法使用,可以尝试下修复依赖.<p></p><pre><code>~$ sudo apt  install -f</code></pre><p></p><h3>方法三:删除配置文件,重启搜狗</h3><br>ubuntu下搜狗配置文件在~/.config下的3个文件夹内:<br>    <code>SogouPY</code>,<code>SogouPY.users</code>、<code>sogou-qimpanel</code><br>    删除这3个文件夹,之后重启.<p></p><p><b>注:我就是用这个方法解决了无法输入中文问题</b></p><p></p><h3>总结</h3><br>Linux下软件经常会因为配置问题而崩溃，最直观的现象就是无法正常使用.因此，如果Linux下正常使用的软件，突然崩溃无法使用，可以尝试删除或修改配置文件的方式尝试解决。<p></p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;解决ubuntu16.04下搜狗输入法无法输入中文问题&lt;/h1&gt;

&lt;p&gt;今天打开电脑,突然发现一直正常使用的搜狗输入法无法无法输入中文(&lt;b&gt;具体现象是，可以呼出搜狗输入法界面，但是候选词列表无显示&lt;/b&gt;).在查阅了别人的博客后解决了这个问题，下面是解决方案.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/0D/06/ChMkJ1ojqAGISeb1AAexeXbMtcgAAiwQAPGnzMAB7GR200.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ngrok神器映射外网</title>
    <link href="http://yoursite.com/2016/09/20/%E7%A5%9E%E5%99%A8Ngrok%E6%98%A0%E5%B0%84%E5%A4%96%E7%BD%91/"/>
    <id>http://yoursite.com/2016/09/20/神器Ngrok映射外网/</id>
    <published>2016-09-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<p><b>ngrok 服务可以分配给你一个域名让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API (比如微信公众号，企业号的开发) </b></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJ1lkKOSIMAebABMY8g_U_F0AAeWIQDF5hoAExkK642.jpg"></p><a id="more"></a><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ul><li>下载linux版本的客户端，解压到你喜欢的目录,注意：要给ngrok文件的可执行权限<a href="http://pan.baidu.com/s/1jG4fEGu" target="_blank" rel="noopener">Ubuntu 64 位下载地址</a></li></ul><ul><li>在命令行下进入到<code>path/to/linux_amd64/</code>下</li><li>执行 <code>./ngrok -config=ngrok.cfg -subdomain xxx 8080</code> //(<code>xxx</code> 是你自定义的域名前缀，<code>8080</code>是你本机服务器对应的端口，由于我用的是<code>Apache Tomcat 7</code>所以端口是<code>8080</code>)</li><li>如果开启成功 你就可以使用 <code>xxx.tunnel.qydev.com</code> 来访问你本机的 <code>127.0.0.1:80</code> 的服务啦</li><li>如果你自己有顶级域名，想通过自己的域名来访问本机的项目，那么先将自己的顶级域名解析到<code>123.57.165.240</code> (域名需要已备案哦),然后执行<code>./ngrok -config=ngrok.cfg -hostname xxx.xxx.xxx 8080</code> //(xxx.xxx.xxx是你自定义的顶级域名)</li><li>如果开启成功 你就可以使用你的顶级域名来访问你本机的 <code>127.0.0.1:8080</code> 的服务啦</li></ul><p><b>参考文献:<a href="http://qydev.com/#" target="_blank" rel="noopener">http://qydev.com/#</a></b></p><pre><code>Writen on 11.Apri.2016</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;ngrok 服务可以分配给你一个域名让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API (比如微信公众号，企业号的开发) &lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJ1lkKOSIMAebABMY8g_U_F0AAeWIQDF5hoAExkK642.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ngrok" scheme="http://yoursite.com/tags/Ngrok/"/>
    
  </entry>
  
  <entry>
    <title>Git使用ssh密钥</title>
    <link href="http://yoursite.com/2016/09/13/Git%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5/"/>
    <id>http://yoursite.com/2016/09/13/Git使用ssh密钥/</id>
    <published>2016-09-13T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJllkKMeIJ6CSAAdGdB9XHNIAAeWIAJf87AAB0aM436.jpg" alt></p><a id="more"></a><hr><p><b><br>git使用https协议，每次pull, push都要输入密码，相当的烦。<br>使用git协议，然后使用ssh密钥。这样可以省去每次都输密码。<br></b></p><hr><p>大概需要三个步骤：</p><ol><li>本地生成密钥对；</li><li>设置github上的公钥；</li><li>修改git的remote url为git协议。</li></ol><hr><h2 id="详细讲解第3部分"><a href="#详细讲解第3部分" class="headerlink" title="详细讲解第3部分"></a>详细讲解第3部分</h2><p>修改你本地的ssh remote url. 不用https协议，改用git 协议</p><p>可以用<code>git remote -v</code>查看你当前的<code>remote url</code></p><pre><code>$ git remote -vorigin    https://github.com/Helloxyw/Helloxyw.github.io.git (fetch)origin    https://github.com/Helloxyw/Helloxyw.github.io.git (push)</code></pre><p>可以看到是使用https协议进行访问的。</p><p>你可以使用浏览器登陆你的github，在上面可以看到你的ssh协议相应的url。类似如下：</p><pre><code>git@github.com:someaccount/someproject.git</code></pre><p>这时，你可以使用<code>git remote set-url</code> 来调整你的<code>url</code>。</p><pre><code>git remote set-url origin git@github.com:someaccount/someproject.git</code></pre><p>完了之后，你便可以再用<code>git remote -v</code> 查看一下。<br>    $ git remote -v<br>    origin    git@github.com:Helloxyw/Helloxyw.github.io.git (fetch)<br>    origin    git@github.com:Helloxyw/Helloxyw.github.io.git (push)</p><p> 至此，OK。</p><p>你可以用<code>git fetch, git pull , git push</code>， 现在进行远程操作，应该就不需要输入密码那么烦了。</p><pre><code>Writhen On 18-Apr-2016 By Ricardo Xu</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJllkKMeIJ6CSAAdGdB9XHNIAAeWIAJf87AAB0aM436.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>高并发秒杀项目</title>
    <link href="http://yoursite.com/2016/04/20/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2016/04/20/高并发秒杀项目/</id>
    <published>2016-04-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-springmvc-Mybatis"><a href="#spring-springmvc-Mybatis" class="headerlink" title="spring-springmvc-Mybatis"></a>spring-springmvc-Mybatis</h1><h3>SSM整合实现Java高并发秒杀</h3><p><strong> 选择使用<code>springmvc</code> + <code>spring</code> +<code>mybatis</code>三大框架原因是:</strong></p><ul><li>轻量</li><li>易使用</li></ul><p><strong>主要使用到的技术：</strong></p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/mybatis-spring.png" alt></p><a id="more"></a><h4>Mysql</h4><ul><li>表设计</li><li>SQL技巧</li><li>事务和行级锁</li></ul><h4>MyBatis</h4><ul><li>DAO层设计开发</li><li>MyBatis全程使用</li><li>MyBatis与Spring整合</li><li>推荐XML配置Sql</li></ul><h4>Spring</h4><ul><li>IOC整合Service</li><li>声明式事务运用</li></ul><p></p><h4>Spring MVC</h4><p></p><ul><li>Restful接口设计使用</li><li>框架运作流程</li><li>Controller开发技巧</li></ul><p></p><h4>前端</h4><p></p><ul><li>交互设计</li><li>Bootstrap</li><li>jQuery</li></ul><h3 id="所用到的包的依赖-pom-xml文件"><a href="#所用到的包的依赖-pom-xml文件" class="headerlink" title="所用到的包的依赖(pom.xml文件)"></a>所用到的包的依赖(pom.xml文件)</h3><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.seckill&lt;/groupId&gt;    &lt;artifactId&gt;seckill&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;name&gt;seckill Maven Webapp&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;dependencies&gt;        &lt;!-- 补全项目依赖 --&gt;        &lt;!-- 使用junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.11&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- 1:日志 java日志： slf4j,log4j,logback,common-logging slf4j是规范/接口 日志实现：log4j,logback,common-logging            使用:slf4j + logback --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;1.7.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-core&lt;/artifactId&gt;            &lt;version&gt;1.1.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;1.1.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 数据库相关依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.35&lt;/version&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;c3p0&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- DAO框架：Mybatis依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.2.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Servlet web 依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;taglibs&lt;/groupId&gt;            &lt;artifactId&gt;standard&lt;/artifactId&gt;            &lt;version&gt;1.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jstl&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;            &lt;version&gt;2.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;            &lt;version&gt;2.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Spring 依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Spring dao层依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Spring web依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;4.2.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc-portlet&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring test依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;4.2.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- redis客户端:Jedis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;redis.clients&lt;/groupId&gt;            &lt;artifactId&gt;jedis&lt;/artifactId&gt;            &lt;version&gt;2.7.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- protostuff序列化依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;            &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt;            &lt;version&gt;1.0.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;            &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;            &lt;version&gt;1.0.8&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;seckill&lt;/finalName&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spring-springmvc-Mybatis&quot;&gt;&lt;a href=&quot;#spring-springmvc-Mybatis&quot; class=&quot;headerlink&quot; title=&quot;spring-springmvc-Mybatis&quot;&gt;&lt;/a&gt;spring-springmvc-Mybatis&lt;/h1&gt;&lt;h3&gt;SSM整合实现Java高并发秒杀&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt; 选择使用&lt;code&gt;springmvc&lt;/code&gt; + &lt;code&gt;spring&lt;/code&gt; +&lt;code&gt;mybatis&lt;/code&gt;三大框架原因是:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轻量&lt;/li&gt;
&lt;li&gt;易使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;主要使用到的技术：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xta11.com1.z0.glb.clouddn.com/mybatis-spring.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下安装java</title>
    <link href="http://yoursite.com/2015/09/20/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85jdk%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/09/20/Ubuntu下安装jdk两种方式/</id>
    <published>2015-09-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.867Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-通过ppa-源-方式安装"><a href="#1-通过ppa-源-方式安装" class="headerlink" title="1.通过ppa(源) 方式安装."></a>1.通过ppa(源) 方式安装.</h3><p><b>这里推荐第1种,因为可以通过 <code>apt-get upgrade</code> 方式方便获得jdk的升级</b></p><h4>在我们继续了解如何安装Java之前，让我们快速地了解<code>JRE、OpenJDK</code>和<code>Oracle JDK</code>之间的不同之处。</h4><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/04/ChMkJlpZZLeIGFB8AATf7vf_nYQAAkD4wFg_xEABOAG369.jpg"><br><a id="more"></a></p><h4><code>JRE（Java Runtime Environment）</code>，它是你运行一个基于Java语言应用程序的所正常需要的环境。如果你不是一个程序员的话，这些足够你的需要。</h4><h4>JDK代表Java开发工具包，如果你想做一些有关Java的开发（阅读程序），这正是你所需要的。</h4><h4>OpenJDK是Java开发工具包的开源实现，Oracle JDK是Java开发工具包的官方Oracle版本。尽管OpenJDK已经足够满足大多数的案例，但是许多程序比如Android Studio建议使用Oracle JDK，以避免UI/性能问题。</h4><h3 id="检查Java是否已经安装在Ubuntu上"><a href="#检查Java是否已经安装在Ubuntu上" class="headerlink" title="检查Java是否已经安装在Ubuntu上"></a>检查Java是否已经安装在Ubuntu上</h3><p><strong>打开终端输入命令：</strong></p><pre><code>java -version</code></pre><p><strong>如果有看到类似以下的输出，则表明你的电脑上已经安装好了JDK，否则就是没有安装：</strong></p><pre><code>java version &quot;1.8.0_73&quot;Java(TM) SE Runtime Environment (build 1.8.0_73-b02)Java HotSpot(TM) 64-Bit Server VM (build 25.73-b02, mixed mode)</code></pre><p><strong>安装Oracle JDK</strong></p><pre><code>sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installer</code></pre><p><strong>    设置 Java 8 环境变量：</strong></p><pre><code>sudo apt-get install oracle-java8-set-default</code></pre><p><strong>此时打开配置文件</strong></p><pre><code>sudo gedit ~/.bashrc</code></pre><p><strong>在打开的文本编辑器末尾换行添加如下内容：(部分内容在安装时可能已经自动配置好了)</strong></p><pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-oracleexport JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH</code></pre><p><strong>右上角保存后，在终端输入 <code>java -version</code> 或 <code>java</code> 或者<code>javac</code>回车，如果显示了版本信息或者一些帮助信息，则表示配置成功</strong></p><h3 id="2-通过官网下载安装包安装"><a href="#2-通过官网下载安装包安装" class="headerlink" title="2:通过官网下载安装包安装."></a>2:通过官网下载安装包安装.</h3><h4 id="首先去官网下载最新的jdk-8u92-linux-x64-tar-gz"><a href="#首先去官网下载最新的jdk-8u92-linux-x64-tar-gz" class="headerlink" title="首先去官网下载最新的jdk-8u92-linux-x64.tar.gz"></a>首先去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">官网</a>下载最新的<code>jdk-8u92-linux-x64.tar.gz</code></h4><h4 id="打开终端创建Java目标路径文件"><a href="#打开终端创建Java目标路径文件" class="headerlink" title="打开终端创建Java目标路径文件"></a>打开终端创建Java目标路径文件</h4><pre><code>sudo mkdir /usr/lib/jvm</code></pre><h4 id="解压jdk文件到目标文件下"><a href="#解压jdk文件到目标文件下" class="headerlink" title="解压jdk文件到目标文件下"></a>解压jdk文件到目标文件下</h4><pre><code>sudo tar -C /usr/lib/jvm -xzf (你下载的路径)/jdk-8u92-linux-x64.tar.gz</code></pre><h4 id="查看本机上是否还有java可选"><a href="#查看本机上是否还有java可选" class="headerlink" title="查看本机上是否还有java可选"></a>查看本机上是否还有java可选</h4><pre><code>sudo update-alternatives --list java</code></pre><h4 id="若显示-update-alternatives-错误-无-java-的候选项-则表示系统中没有java可选，可以进行以下步骤"><a href="#若显示-update-alternatives-错误-无-java-的候选项-则表示系统中没有java可选，可以进行以下步骤" class="headerlink" title="若显示   update-alternatives: 错误: 无 java 的候选项  则表示系统中没有java可选，可以进行以下步骤"></a>若显示   <code>update-alternatives: 错误: 无 java 的候选项</code>  则表示系统中没有java可选，可以进行以下步骤</h4><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><pre><code>sudo gedit ~/.bashrc</code></pre><h4 id="在打开的文本编辑器末尾换行添加如下内容："><a href="#在打开的文本编辑器末尾换行添加如下内容：" class="headerlink" title="在打开的文本编辑器末尾换行添加如下内容："></a>在打开的文本编辑器末尾换行添加如下内容：</h4><pre><code>export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_92   export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH</code></pre><p><strong>右上角保存后，在终端输入 <code>java -version</code> 或 <code>java</code> 或者<code>javac</code>回车，如果显示了版本信息或者一些帮助信息，则表示配置成功</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-通过ppa-源-方式安装&quot;&gt;&lt;a href=&quot;#1-通过ppa-源-方式安装&quot; class=&quot;headerlink&quot; title=&quot;1.通过ppa(源) 方式安装.&quot;&gt;&lt;/a&gt;1.通过ppa(源) 方式安装.&lt;/h3&gt;&lt;p&gt;&lt;b&gt;这里推荐第1种,因为可以通过 &lt;code&gt;apt-get upgrade&lt;/code&gt; 方式方便获得jdk的升级&lt;/b&gt;&lt;/p&gt;
&lt;h4&gt;在我们继续了解如何安装Java之前，让我们快速地了解&lt;code&gt;JRE、OpenJDK&lt;/code&gt;和&lt;code&gt;Oracle JDK&lt;/code&gt;之间的不同之处。&lt;/h4&gt;



&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/04/ChMkJlpZZLeIGFB8AATf7vf_nYQAAkD4wFg_xEABOAG369.jpg&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
