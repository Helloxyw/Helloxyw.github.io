<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RicardoXu博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-23T16:25:52.369Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>RicardoXu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步异步与阻塞非阻塞</title>
    <link href="http://yoursite.com/2020/03/24/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>http://yoursite.com/2020/03/24/同步异步阻塞非阻塞/</id>
    <published>2020-03-23T16:00:00.000Z</published>
    <updated>2020-03-23T16:25:52.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-同步与异步"><a href="#1-同步与异步" class="headerlink" title="1 同步与异步"></a>1 同步与异步</h2><p><strong>首先来解释下同步和异步的概念，这两个概念和消息的通知机制有关。也就是同步和异步主要是从消息通知机制角度来说的。</strong></p><h3 id="1-1-概念描述"><a href="#1-1-概念描述" class="headerlink" title="1.1 概念描述"></a>1.1 概念描述</h3><p><strong>所谓同步就是一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才算完成，这是一种可靠的任务序列。</strong>要么成功都成功，要么失败都失败，这两个任务的状态可以一致。</p><p><strong>所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。</strong>至于依赖的任务最终是否真正完成，依赖它的任务无法确定，<strong>所以它是不可靠的任务序列。</strong></p><p><img src="http://img3.51tietu.net/pic/2016-060411/20160604110705phmiwo32jbb329772.jpg" alt><br><a id="more"></a></p><h3 id="1-2-消息通知"><a href="#1-2-消息通知" class="headerlink" title="1.2 消息通知"></a>1.2 消息通知</h3><p><strong>异步的概念和同步相对</strong>。当一个同步调用发出后，<strong>调用者要一直等待返回消息(结果)通知后</strong>，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。<strong>实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者</strong>。</p><p>这里提到的执行部件和调用者通过三种途径返回结果：<code>状态、通知和回调</code>。使用哪一种通知机制，<code>依赖于执行部件的实现</code>，除非执行部件提供多种选择，<code>否则不受调用者控制</code>。</p><blockquote><p>1.如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误。</p><p>2.如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</p></blockquote><h3 id="1-3-场景比喻"><a href="#1-3-场景比喻" class="headerlink" title="1.3 场景比喻"></a>1.3 场景比喻</h3><p>举个例子，比如我去银行办理业务，可能会用两种方式：</p><blockquote><ol><li>选择排队等候</li><li>另外一种选择，取号，等到排到我这一号时由柜台的人通知我去办理业务</li></ol></blockquote><p>第一种：<strong>前者（排队等候）就是同步等待消息通知</strong>，也就是我要一直在等待银行办理业务情况；</p><p>第二种：<strong>后者（等待别人通知）就是异步等待消息通知</strong>，在异步消息处理中，<strong>等待消息通知者（等待办理业务的人）往往注册一个回调机制</strong>。在所等待的事件被触发时由触发机制（柜台的人）通过某种机制（写在小纸条上的号码，喊号）找到等待该事件的人。</p><h2 id="2-阻塞非阻塞"><a href="#2-阻塞非阻塞" class="headerlink" title="2. 阻塞非阻塞"></a>2. 阻塞非阻塞</h2><p><strong>阻塞和非阻塞这两个概念与程序（线程）等待消息通知（无所谓同步或者异步）时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</strong></p><h3 id="2-1-概念描述"><a href="#2-1-概念描述" class="headerlink" title="2.1 概念描述"></a>2.1 概念描述</h3><p><strong>阻塞调用是指调用结果返回前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务</strong>。函数只有在得到结果之后才会返回。</p><p><strong>有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。</strong></p><ol><li><strong>对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已。此时，这个线程可能也会处理其他的消息。</strong>扩展点：</li></ol><blockquote><p>(a)如果这个线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫作同步非阻塞</p><p>(b)如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做同步阻塞</p></blockquote><p><strong>所以同步的实现方式会有两种：同步阻塞、同步非阻塞；同理，异步也会有两种实现：异步阻塞、异步非阻塞</strong>。</p><ol><li><p>对于阻塞调用来说，则当前线程就会被挂起等待当前函数返回</p><p>非阻塞和阻塞的概念相对于，<strong>指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</strong>虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，<strong>但是也带来了另外一种后果就是系统的线程切换增加，增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。</strong></p></li></ol><h3 id="2-2-场景比喻"><a href="#2-2-场景比喻" class="headerlink" title="2.2 场景比喻"></a>2.2 场景比喻</h3><p>继续上面的例子，不论是排队还是取号等待通知，<strong>如果在这个等待的过程中，等待者除了等待消息通知之外不能做其他事情，那么该机制就是阻塞的</strong>。表现在程序中，也就是该程序一直阻塞在该函数调用处不能继续往下执行。</p><p>相反，<strong>有的人喜欢在银行办理这些业务的时候，一边打电话发短信一边等待，这样的状态就是非阻塞的</strong>，因为等待者没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</p><p>但是需要注意的是，<strong>同步非阻塞形式实际上是效率低下的</strong>，想象一下你一边打着电话，一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而<strong>异步非阻塞形式却没有这样的问题，</strong>因为打电话是等待者的事情，而通知你则是柜台（消息触发机制）的事情，程序没有在两种不同的操作中来回切换。</p><h2 id="3-同步-异步与阻塞-非阻塞"><a href="#3-同步-异步与阻塞-非阻塞" class="headerlink" title="3 同步/异步与阻塞/非阻塞"></a>3 同步/异步与阻塞/非阻塞</h2><h3 id="3-1-同步阻塞形式"><a href="#3-1-同步阻塞形式" class="headerlink" title="3.1. 同步阻塞形式"></a>3.1. 同步阻塞形式</h3><p>效率最低，以上面的例子举例，就是你专心排队，什么别的事情都不做</p><p><strong>实际程序中：</strong>就是未对fd设置<code>O_NONBLOCK</code>标志位的 read/write操作</p><h3 id="3-2-异步阻塞形式"><a href="#3-2-异步阻塞形式" class="headerlink" title="3.2. 异步阻塞形式"></a>3.2. 异步阻塞形式</h3><p>如果是在银行等待办理业务的人，<strong>采用的是异步的方式去等待消息被触发（通知）</strong>，也就是领了一张小纸条，假如在这段时间里他不能离开银行去做其他的事情，那么很显然，这个人被阻塞在了这个等待的操作上面</p><p><strong>异步操作是可以被阻塞的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</strong></p><p>比如select函数，假如传入的最后一个timeout参数为NULL，<strong>那么如果所关注的事件没有一个被触发，程序就会一直阻塞在这个select调用处</strong></p><h3 id="3-3-同步非阻塞形式"><a href="#3-3-同步非阻塞形式" class="headerlink" title="3.3. 同步非阻塞形式"></a>3.3. 同步非阻塞形式</h3><p>实际上效率低下的，2.2已解释了效率低下的原因。很多人会写阻塞的read/write操作，<strong>但是可以对fd设置O_NONBLOCK标志位，这样就可以将同步操作变成非阻塞的了</strong>。</p><h3 id="3-4-异步非阻塞形式"><a href="#3-4-异步非阻塞形式" class="headerlink" title="3.4.异步非阻塞形式"></a>3.4.异步非阻塞形式</h3><p>效率更高，因为打电话是等待者的事情，而通知你是柜台（消息触发机制）的事情，<strong>程序没有在两种不同的操作中来回切换</strong>。</p><p>比如说，这个人突然想出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下(注册一个回调函数)，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p><p>如果使用异步非阻塞的情况，比如aio_<em>组的操作，当发起一个aio_read操作时，<em>*函数会马上返回不会被阻塞，当所关注的事件被触发时会调用之前注册的回调函数进行处理。</em></em></p><blockquote><p>很多人会把同步和阻塞混淆，我想是因为<strong>很多时候同步操作会以阻塞的形式表现出来，但最根本是因为没有区分这两个概念。</strong>比如阻塞的read/write操作中，<strong>其实是把消息通知机制和等待消息通知的状态结合在了一起，</strong>在这里<strong>所关注的消息就是fd是否可读/写，</strong>而<strong>等待消息通知的状态则是对fd可读/写等待过程中程序（线程）的状态</strong>。如果我们将这个fd设置为非阻塞的时候，read/write操作就不会在等待消息通知这里阻塞，如果fd不可读/写,则操作立即返回。</p><p>同样的，很多人也会把异步和非阻塞混淆，<strong>因为异步操作一般都不会在真正的IO操作处被阻塞，</strong>比如如果用select函数，<strong>当select返回可读时再去read一般不会被阻塞，而是在select函数调用处阻塞</strong>。</p></blockquote><h2 id="4-小明的故事"><a href="#4-小明的故事" class="headerlink" title="4.小明的故事"></a>4.小明的故事</h2><p>对上面所讲的概念再次进行一个场景梳理，上面已经明确说过了，<strong>同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序(线程)等待消息通知的状态</strong>。以小明下载文件打个比方，从这两个关注点来再次说明这两组概念，希望能更好的促进大家的理解。</p><p><strong>同步阻塞：小明一直盯着下载进度条，到100%的时候完成</strong></p><blockquote><p>同步体现在：等待下载完成通知</p><p>阻塞体现在：等待下载完成通知的过程中，不能做其他任务处理</p></blockquote><p><strong>同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到100%就完成</strong></p><blockquote><p>同步体现在：等待下载完成通知</p><p>非阻塞体现在：等待下载完成通知的过程中，去干别的任务了，只是时不时会瞄一眼进度条（小明必须要在两个任务间切换，关注下载进度）</p></blockquote><p><strong>异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就”叮”一声，不过小明仍然一直在等待”叮“的声音（看起来很傻）</strong></p><blockquote><p>异步体现在：下载完成”叮”一声通知</p><p>阻塞体现在：等待下载完成后”叮”一声通知中，不能做其他任务处理</p></blockquote><p><strong>异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了</strong></p><blockquote><p>异步体现在：下载完成”叮”一声通知</p><p>阻塞体现在：等待下载完成后”叮”一声通知中，去干别的任务了，只需要接收”叮”的一声通知即可，（软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件”叮”的通知即可</p></blockquote><p>也就是说，<strong>同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务）</strong>，在不同的场景下，同步/异步、阻塞/非阻塞的四种组合都有应用。</p><p>所以综上所述，<strong>同步和异步仅仅是关注的消息如何通知的机制，而阻塞与非阻塞关注的是等待消息通知时的状态。</strong>也就是说，<strong>同步的情况下，是由处理消息者自己去等待消息是否被触发，而异步的情况下是由触发机制来通知处理消息者，</strong>所以在异步机制中，<strong>处理消息和触发机制之间就需要一个连接的桥梁:</strong></p><blockquote><p>银行的例子中，这个桥梁就是小纸条上的号码</p><p>小明的例子中，这个桥梁就是软件”叮”的声音</p></blockquote><p><strong>最后，大家注意理解”消息通知机制”和”等待消息通知时的状态”这两个概念，这是理解四个概念的关键所在。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-同步与异步&quot;&gt;&lt;a href=&quot;#1-同步与异步&quot; class=&quot;headerlink&quot; title=&quot;1 同步与异步&quot;&gt;&lt;/a&gt;1 同步与异步&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;首先来解释下同步和异步的概念，这两个概念和消息的通知机制有关。也就是同步和异步主要是从消息通知机制角度来说的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-1-概念描述&quot;&gt;&lt;a href=&quot;#1-1-概念描述&quot; class=&quot;headerlink&quot; title=&quot;1.1 概念描述&quot;&gt;&lt;/a&gt;1.1 概念描述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;所谓同步就是一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才算完成，这是一种可靠的任务序列。&lt;/strong&gt;要么成功都成功，要么失败都失败，这两个任务的状态可以一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。&lt;/strong&gt;至于依赖的任务最终是否真正完成，依赖它的任务无法确定，&lt;strong&gt;所以它是不可靠的任务序列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.51tietu.net/pic/2016-060411/20160604110705phmiwo32jbb329772.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程状态及切换</title>
    <link href="http://yoursite.com/2020/03/24/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%88%87%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/03/24/Java线程状态及切换/</id>
    <published>2020-03-23T16:00:00.000Z</published>
    <updated>2020-03-23T16:03:39.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、线程的几个重要方法"><a href="#一、线程的几个重要方法" class="headerlink" title="一、线程的几个重要方法"></a>一、线程的几个重要方法</h2><ul><li>start()方法，开始执行该线程</li><li>stop()方法，强制结束该线程执行</li><li>join()方法，等待该线程结束</li><li>sleep()方法，线程进入等待</li><li>run()方法，直接执行线程的run()方法，但是线程调用start()方法时也会运行run()方法，区别就是一个是由线程调度运行run()方法，一个是直接调用了线程中的run()方法</li></ul><p><img src="http://pic1.win4000.com/wallpaper/0/57f86946b178d.jpg" alt><br><a id="more"></a></p><p>至于wait()和notify()他们是Objetc的方法，不是Thread的方法，同时wait()与notify()会配合使用，分别表示线程挂起和线程恢复。</p><p>wait()和sleep()的区别，<strong>wait()会释放对象锁资源，而sleep()不会释放对象锁资源。但是wait和sleep都会释放cpu资源。</strong></p><h2 id="二、Java线程的生命周期"><a href="#二、Java线程的生命周期" class="headerlink" title="二、Java线程的生命周期"></a>二、Java线程的生命周期</h2><ol><li><p>新建(NEW):新建了一个线程对象，并没有调用start()之前</p></li><li><p>可运行(Runnable):就绪状态，<strong>调用start()之后线程就进入就绪状态，但是并不是说只要调用start()线程马上变为当前线程，在变为当前线程之前都是为就绪状态。线程在睡眠和挂起中恢复的时候也会进入就绪状态。</strong> 线程对象创建后，其他线程（比如main线程)调用了该对象的start()方法，该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPI的使用权。</p></li><li><p>运行(Running):可运行状态的线程获得了CPU时间片，执行程序代码。线程被设置为当前线程，开始执行run()方法，就是线程进入了运行状态</p></li><li><p>阻塞(Blocked):阻塞是指线程因为某种原因放弃了cpu使用权，即让出了cpu 时间片，暂时停止运行。知道线程进入可运行状态，才有机会再次获得cpu 时间片转到运行状态。线程被暂停，比如调用sleep()方法后，线程就进入阻塞状态。</p><p>阻塞分为三种情况：</p><ul><li>等待阻塞：运行的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中</li><li>其他阻塞：运行的线程执行Thread.sleep(long ms)或者t.join()方法，或者放出了I/O请求，JVM会把线程设置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行状态</li></ul></li><li><p>死亡(Dead):线程执行结束，线程run()、main()方法执行结束，或者异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ol><p><img src="https://s1.ax1x.com/2020/03/23/8H2gIg.png" alt="8H2gIg.png"></p><h2 id="三、具体状态"><a href="#三、具体状态" class="headerlink" title="三、具体状态"></a>三、具体状态</h2><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态</p><h3 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h3><ol><li>可运行状态只是说你有资格运行，调度程序没有挑选到你，你就永远是可运行状态。</li><li>调用线程的start()方法，此线程进入可运行状态</li><li>当前线程sleep()方法结束、其他线程join()方法结束、等待用户输入完毕、某个线程拿到对象锁，这些线程也将进入可运行状态</li><li>当前线程时间片用完了、调用当前线程的yield()方法，当前线程进入可运行状态</li><li>锁池里的线程拿到对象锁后，进入可运行状态</li></ol><h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一方式</p><h3 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h3><ol><li>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。 <strong>线程一旦死亡，就不能复生</strong></li><li>在一个死去的线程上调用start()方法，会抛出<code>java.lang.IllegalThreadStateException</code>异常</li></ol><h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><ol><li>当前线程T调用Thread.sleep()方法，当前线程进入阻塞状态</li><li>运行在当前线程里的其他线程t2调用join方法，当前线程进入阻塞状态</li><li>等待用户输入时，当前线程进入阻塞状态</li></ol><h3 id="等待队列（本是Object里的方法，但影响了线程）"><a href="#等待队列（本是Object里的方法，但影响了线程）" class="headerlink" title="等待队列（本是Object里的方法，但影响了线程）"></a>等待队列（本是Object里的方法，但影响了线程）</h3><ol><li>调用obj的wait()、notify()方法前，必须获得obj锁，也就是必须写在<code>synchronized(obj)</code>代码段内。</li><li>等待队列相关的步骤和图</li></ol><p><img src="https://s1.ax1x.com/2020/03/23/8H4Kjs.png" alt="8H4Kjs.png"></p><h2 id="四、几个方法的比较"><a href="#四、几个方法的比较" class="headerlink" title="四、几个方法的比较"></a>四、几个方法的比较</h2><ul><li><p>sleep：Thread类的方法，必须带一个时间参数。 <strong>会让当前线程休眠进入阻塞状态并释放CPU( sleep释放cpu，wait也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段)</strong>，提供其他线程运行的机会且不考虑优先级，但如果有同步锁，则sleep不会释放锁，即其他线程无法获得同步锁，可通过调用interrupt()方法来唤醒休眠线程。（interrupt()的作用是，在线程收到阻塞时，抛出一个中断信号，这样线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait，Thread.join和Thread.sleep三种方法之一阻塞，那么它将接收到一个中断异常(<code>InterruptedException</code>)，从而提早终结被阻塞状态）</p></li><li><p>yield：<strong>让出CPU调度</strong>，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间，并且yield()方法 <strong>只能让同优先级的线程</strong>有执行的机会。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入 <strong>可执行状态后</strong>马上又被执行。调用yield()方法只是一个建议，告诉线程调度器，我的工作已经做的差不多了，可以让别的相同优先级的线程使用cpu了，没有任何机制保证采纳</p></li><li><p>wait: Object类的方法(notify()、notifyAll())，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程池等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)，即放入锁池中竞争同步锁</p></li><li><p>join:一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态，直到另一个线程运行结束，等待该线程终止。注意该方法也需要捕捉异常。</p><p>等待调用join方法的线程结束，再继续执行。</p><p><img src="https://s1.ax1x.com/2020/03/23/8H4UgJ.png" alt="8H4UgJ.png"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、线程的几个重要方法&quot;&gt;&lt;a href=&quot;#一、线程的几个重要方法&quot; class=&quot;headerlink&quot; title=&quot;一、线程的几个重要方法&quot;&gt;&lt;/a&gt;一、线程的几个重要方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;start()方法，开始执行该线程&lt;/li&gt;
&lt;li&gt;stop()方法，强制结束该线程执行&lt;/li&gt;
&lt;li&gt;join()方法，等待该线程结束&lt;/li&gt;
&lt;li&gt;sleep()方法，线程进入等待&lt;/li&gt;
&lt;li&gt;run()方法，直接执行线程的run()方法，但是线程调用start()方法时也会运行run()方法，区别就是一个是由线程调度运行run()方法，一个是直接调用了线程中的run()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://pic1.win4000.com/wallpaper/0/57f86946b178d.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Java秒杀系统方案优化 高性能高并发实战</title>
    <link href="http://yoursite.com/2019/06/16/Java%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/06/16/Java秒杀系统方案优化/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-16T15:28:16.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIBt6YAAvmGfwhdgwAALGfwFf6LcAC-Yx733.jpg" alt></p><h2><br>  项目安排<br></h2><h3>1.项目搭建</h3><ul><li><code>SpringBoot</code> 环境搭建</li><li>集成<code>Thymeleaf</code>,<code>Result</code>结果封装</li><li>集成<code>Mybatis</code> + <code>Druid</code></li><li>集成<code>Jedis</code> +<code>Redis</code>安装 + 通用缓存<code>Key</code>封装</li></ul><a id="more"></a><h3>2.实现登录功能</h3><ul><li>数据库设计</li><li>明文密码两次<code>MD5</code>处理</li><li><code>JSR303</code>参数校验 + 全局异常处理器</li><li>分布式<code>Session</code></li></ul><h3>3.实现秒杀功能</h3><ul><li>数据库设计</li><li>商品列表页</li><li>商品详情页</li><li>订单详情页 </li></ul><h4>4.JMeter压测</h4><ul><li><code>JMeter</code>入门</li><li>自定义多变量模拟多用户</li><li><code>JMeter</code>命令行使用</li><li><code>SpringBoot</code>打<code>War</code>包</li></ul><h3>5.页面优化技术</h3><ul><li>页面缓存 + <code>URL</code>缓存 + 对象缓存</li><li>页面静态化 ，前后端分离</li><li>静态资源优化</li><li><code>CDN</code>优化</li></ul><h3>6.接口优化</h3><ul><li><code>Redis</code>预减库存减少数据库访问</li><li>内存标记减少<code>Redis</code>访问</li><li><code>RabbitMQ</code>队列缓冲，异步下单，增强用户体验</li><li><code>RabbitMQ</code>安装与<code>SpringBoot</code>集成</li><li>访问<code>Nginx</code>水平扩展</li><li>分库分表（<code>Mycat</code>)</li><li>压测</li></ul><h3>7.安全优化</h3><ul><li>秒杀接口地址隐藏</li><li>数学公式验证码</li><li>接口防刷</li></ul><hr><h2>1.项目搭建</h2><h3>集成Redis中的问题和笔记</h3><h4>1.Spring注入</h4><p><code>Spring</code>通过<code>DI</code>（依赖注入）实现<code>IOC</code>（控制反转)，常用的注入方式主要有以下三种:</p><ul><li>构造方法注入</li><li><code>setter</code>方法注入</li><li>基于注解的注入</li></ul><h4>构造方法注入</h4><p>在spring的配置文件中注册UserService，将UserDaoJdbc通过constructor-arg标签注入到UserService的<strong>某个</strong>有参数的构造方法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册userService --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.lyu.spring.service.impl.UserService"</span>&gt;</span><br><span class="line">&lt;constructor-arg ref="userDaoJdbc"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册jdbc实现的dao --&gt;</span><br><span class="line">&lt;bean id="userDaoJdbc" class="com.lyu.spring.dao.impl.UserDaoJdbc"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>如果只有一个有参数的构造方法并且参数类型与注入的bean的类型匹配，那就会注入到该构造方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(IUserDao userDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDao.loginUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">// 获取bean对象</span></span><br><span class="line">UserService userService = ac.getBean(UserService.class, <span class="string">"userService"</span>);</span><br><span class="line"><span class="comment">// 模拟用户登录</span></span><br><span class="line">userService.loginUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><h4>setter注入</h4><p>配置文件如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册userService --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.lyu.spring.service.impl.UserService"</span>&gt;</span><br><span class="line">&lt;!-- 写法一 --&gt;</span><br><span class="line">&lt;!-- &lt;property name="UserDao" ref="userDaoMyBatis"&gt;&lt;/property&gt; --&gt;</span><br><span class="line">&lt;!-- 写法二 --&gt;</span><br><span class="line">&lt;property name="userDao" ref="userDaoMyBatis"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册mybatis实现的dao --&gt;</span><br><span class="line">&lt;bean id="userDaoMyBatis" class="com.lyu.spring.dao.impl.UserDaoMyBatis"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>注：上面这两种写法都可以,spring会将name值的每个单词首字母转换成大写，然后再在前面拼接上”set”构成一个方法名,然后去对应的类中查找该方法,通过反射调用,实现注入。</strong></p><p><em>切记：name属性值与类中的成员变量名以及set方法的参数名都无关，只与对应的set方法名有关，下面的这种写法是可以运行成功的</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IUserDao userDao1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(IUserDao userDao1)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao1 = userDao1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDao1.loginUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>还有一点需要注意：如果通过set方法注入属性，那么spring会通过默认的空参构造方法来实例化对象，所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上，否则spring没有办法实例化对象，导致报错。</strong></p><h4>基于注解的注入</h4><p>在介绍注解注入的方式前，先简单了解<code>bean</code>的一个属性<code>autowire</code>，<code>autowire</code>主要有三个属性值：<code>constructor</code>，<code>byName</code>，<code>byType</code>。</p><ul><li><p><code>constructor</code>：通过构造方法进行自动注入，<code>spring</code>会匹配与构造方法参数类型一致的<code>bean</code>进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的<code>bean</code>，那么<code>spring</code>会优先将<code>bean</code>注入到多参数的构造方法中。</p></li><li><p><code>byName</code>：被注入<code>bean</code>的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。</p></li><li><p><code>byType</code>：查找所有的set方法，将符合符合参数类型的bean注入。</p></li></ul><hr><p>主要有四种注解可以注册bean，每种注解可以任意使用，只是语义上有所差异：</p><ul><li><code>@Component</code>：可以用于注册所有bean</li><li><code>@Repository</code>：主要用于注册dao层的bean</li><li><code>@Controller</code>：主要用于注册控制层的bean</li><li><code>@Service</code>：主要用于注册服务层的bean</li></ul><p>描述依赖关系主要有两种：</p><ul><li><code>@Resource</code>：java的注解，默认以byName的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（spring注解）指定某个具体名称的bean。</li><li><code>@Autowired</code>：spring注解，<strong>默认是以byType的方式去匹配类型相同的bean</strong>，如果只匹配到一个，那么就直接注入该bean，无论要注入的 bean 的 name 是什么；如果匹配到多个，就会调用就会调用 <strong><code>DefaultListableBeanFactory</code></strong> 的 <strong><code>determineAutowireCandidate</code></strong> 方法来决定具体注入哪个bean</li></ul><blockquote><p>determineAutowireCandidate 方法的逻辑是：</p><ol><li>先找 Bean 上有@Primary 注解的，有则直接返回 bean 的 name。</li><li>再找 Bean 上有 @Order，@PriorityOrder 注解的，有则返回 bean 的 name。</li><li>最后再以名称匹配（ByName）的方式去查找相匹配的 bean</li></ol></blockquote><p>虽然有这么多的注入方式，但是实际上开发的时候自己编写的类一般用注解的方式注册类，用@Autowired描述依赖进行注入，一般实现类也只有一种（jdbc or hibernate or mybatis），除非项目有大的变动，所以@Qualifier标签用的也较少；但是在使用其他组件的API的时候用的是通过xml配置文件来注册类，描述依赖，因为你不能去改人家源码嘛。</p><h4>2.</h4><p><a href="https://postimg.cc/tYCsYJ80" target="_blank" rel="noopener"><img src="https://i.postimg.cc/Pr1YV84q/WX20190519-182215-2x.png" alt="WX20190519-182215-2x.png"></a></p><h3>2.实现登录</h3><h4>1.两次MD5</h4><ol><li>用户端：PASS = MD5（明文 + 固定Salt)</li><li>服务端：PASS = MD5（用户输入 + 随机Salt）</li></ol><h4>2.数据库三大范式</h4><ul><li>1NF：要求有主键，并且要求每一个字段原子性不可再分</li></ul><blockquote><p>1NF是对属性的<strong>原子性</strong>，要求属性具有原子性，不可再分解；</p><p>表：字段1、 字段2(字段2.1、字段2.2)、字段3 ……</p><p>如学生（学号，姓名，性别，出生年月日），如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不是一范式了，否则就是。</p></blockquote><ul><li>2NF：要求所有非主键字段完全依赖主键，不能产生部分依赖</li></ul><blockquote><p>2NF是对记录的<strong>惟一性</strong>，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；</p><p>表：学号、课程号、姓名、学分;</p><p>这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里<strong>学分依赖课程号</strong>，<strong>姓名依赖与学号</strong>，所以不符合二范式。</p><p><strong>可能会存在问题：</strong></p><ul><li><code>数据冗余:</code>，每条记录都含有相同信息；</li><li><code>删除异常：</code>删除所有学生成绩，就把课程信息全删除了；</li><li><code>插入异常：</code>学生未选课，无法记录进数据库；</li><li><code>更新异常：</code>调整课程学分，所有行都调整。</li></ul><p><strong>正确做法:</strong><br>学生：<code>Student</code>(学号, 姓名)；<br>课程：<code>Course</code>(课程号, 学分)；<br>选课关系：<code>StudentCourse</code>(学号, 课程号, 成绩)。</p></blockquote><ul><li>3NF：所有非主键字段和主键字段之间不能传递依赖</li></ul><blockquote><p>3NF是对字段的<strong>冗余性</strong>，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</p><p>表: 学号, 姓名, 年龄, 学院名称, 学院电话</p><p>因为存在<strong>依赖传递</strong>: (学号) → (学生)→(所在学院) → (学院电话) 。</p><p><strong>可能会存在问题：</strong></p><ul><li><code>数据冗余:</code>有重复值；</li><li><code>更新异常：</code>有重复的冗余信息，修改时需要同时修改多条记录，否则会出现<strong>数据不一致的情况</strong> 。</li></ul><p><strong>正确做法：</strong></p><p>学生：(学号, 姓名, 年龄, 所在学院)；</p><p>学院：(学院, 电话)。</p></blockquote><h4>反范式</h4><p><strong>一般说来，数据库只需满足第三范式（3NF）就行了。</strong></p><blockquote><p>没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余，<strong>达到以空间换时间的目的</strong>。</p><p>〖例〗：有一张存放商品的基本表，如表1所示。“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以<strong>提高查询统计的速度</strong>，这就是以<strong>空间换时间</strong>的作法。</p></blockquote><h4>范式化设计和反范式化设计的优缺点</h4><p><strong>范式化</strong></p><p><strong>优点</strong></p><ul><li>可以尽可能的减少数据冗余</li><li>数据表更新快，体积小</li></ul><p><strong>缺点</strong></p><ul><li>对于查询需要对多个表进行关联，导致性能低</li><li>更难进行索引优化</li></ul><p><strong>反范式化</strong></p><p><strong>优点</strong></p><ul><li>可以减少表的关联</li><li>可以更好进行索引优化</li></ul><p><strong>缺点</strong></p><ul><li>存在数据冗余及数据维护异常</li><li>对数据的修改需要更多的成本</li></ul><h3>五、页面优化</h3><h4>页面缓存</h4><ol><li>取缓存</li><li>手动渲染模板</li><li>结果输出</li></ol><h4>静态资源优化</h4><ol><li>JS/CSS压缩，减少流量</li><li>多个JS/CSS组合，减少连接数</li><li>CDN就近访问</li></ol><h3>六、秒杀接口优化</h3><p><strong>思路：减少数据库访问 </strong></p><ol><li>系统初始化，把商品库存数量加载到Redis</li><li>收到请求，Redis预减库存，库存不足，直接返回，否则进入3</li><li>请求入队，立即返回排队中</li><li>请求出队，生成订单，减少库存</li><li>客户端轮询，是否秒杀成功</li></ol><p><strong>1.<code>SpringBoot</code>集成<code>RabbitMQ</code></strong></p><ol><li>添加依赖<code>spring-boot-starter-amqp</code></li><li>创建消息接受者</li><li>创建消息发送者</li></ol><h3>7.安全优化</h3><ul><li>秒杀接口地址隐藏</li><li>数学公式验证码</li><li>接口防刷</li></ul><p><strong>1.秒杀接口地址隐藏</strong></p><p><strong>思路：秒杀开始之前，先去请求接口获取秒杀地址</strong></p><ol><li>接口改造，带上PathVariable参数</li><li>添加生成地址的接口</li><li>秒杀收到请求，先验证PathVariable</li></ol><p><strong>2.数学公式验证码</strong></p><p><strong>思路：点击秒杀之前，先输入验证码，分散用户的请求</strong></p><ol><li>添加生成验证码的接口</li><li>在获取秒杀路径的时候，验证验证码</li><li>ScriptEngine使用 </li></ol><p><strong>3.接口限流</strong></p><p>把用户访问次数写入缓存，并加上有效时间。（可以用拦截器减少对业务代码的侵入）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIBt6YAAvmGfwhdgwAALGfwFf6LcAC-Yx733.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2&gt;&lt;br&gt;  项目安排&lt;br&gt;&lt;/h2&gt;

&lt;h3&gt;1.项目搭建&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SpringBoot&lt;/code&gt; 环境搭建&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Thymeleaf&lt;/code&gt;,&lt;code&gt;Result&lt;/code&gt;结果封装&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Mybatis&lt;/code&gt; + &lt;code&gt;Druid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Jedis&lt;/code&gt; +&lt;code&gt;Redis&lt;/code&gt;安装 + 通用缓存&lt;code&gt;Key&lt;/code&gt;封装&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="秒杀" scheme="http://yoursite.com/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>并发编程与高并发入门</title>
    <link href="http://yoursite.com/2019/06/11/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/06/11/并发编程入门与高并发笔记/</id>
    <published>2019-06-11T09:15:53.000Z</published>
    <updated>2019-07-15T15:35:30.203Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://996.icu" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/link-996.icu-red.svg"></a></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIFY_6AA3VjT9w7FMAALGfwFCj8AADdWl862.jpg" alt></p><h3>4.线程安全性</h3><br>定义：当多个线程访问某个类时，不管运行时环境采用<b>何种调度方式</b>或者这些进程将如何交替执行，并且在主调代码中<b>不需要任何额外的同步或协同</b>，这个类都能表现出<b>正确的行为</b>，那么就称这个类是线程安全的。<br><br><em> 原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。</em> 可见性：一个线程对主内存的修改可以及时的被其他线程观察到。<br><em> 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。<br><br><a id="more"></a><br><br><b>原子性——Atomic包</b><br><br>- AtomicXXX：CAS、Unsafe.compareAndSwapInt<br>- AtomicLong、LongAdder<br>- AtomicReference、AtomicReferenceFieldUpdater<br>- AtomicStampReference：CAS的ABA问题<br><br><b>原子性——锁</b></em> synchronized：依赖JVM<br><em> Lock：依赖特殊的CPU指令，代码实现，ReentrantLock<br><br><b>原子性——synchronize</b></em> 修饰代码块：大括号括起来的代码，作用于<b>调用对象</b><br><em> 修饰方法：整个方法，作用于<b>调用的对象</b></em> 修饰静态方法：整个静态方法，作用于这个<b>类的所有对象</b><br><em> 修饰类：括号括起来的部分，作用于这个<b>类的所有对象</b><br><br><b>原子性——对比</b></em> Synchronized：不可中断锁，适合竞争不激烈，可读性好<br><em> Lock：可中断锁，多样化同步，竞争激烈时能维持常态</em> Atomic：竞争激烈时能维持常态，比Lock性能好；只能同步一个值<br><br><b>可见性</b><br><br><em> 线程交叉执行</em> 重排序结合线程交叉执行<br><em> 共享变量更新后的值没有在工作内存及主存空间及时更新<br><br><b>可见性</b><br><br><b>JMM(Java Memory Model) 关于synchorized 的两条规定:</b></em> 线程解锁前，必须把共享变量的最新值刷新到主内存<br><em> 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读区最新的值（注意，加锁与解锁是同一把锁)<br><br><b>可见性——volatile</b><br><br>通过加入<b>内存屏障</b>和<b>禁止重排序</b>优化来实现</em> 对volatile变量写操作时，会在写操作后加入一条store 屏障指令，将本地内存中的共享变量值刷新到主内存<br><em> 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量<br><br><b>可见性——volatile使用（适合作为状态标识量）</b><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">context = loadContext();</span><br><span class="line">inited = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="keyword">while</span>(!inited)&#123;</span><br><span class="line">  sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure><br><br><b>有序性</b></em> java内存模型中，允许编译器和处理器对指令进行<b>重排序</b>，但是重排序过程不会影响到<b>单线程</b>程序的执行，却会影响到多线程并发执行的正确性<br><em> volatile、synchronized、Lock<br><br><b>有序性-happens-before原则</b><br><br><b>较重要的原则</b></em> 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br><em> 锁定原则：一个unLock操作先行发生于后面对同一个锁的lock操作</em> volatile变量规则：对一个变量的写操作先行发生于后面这个变量的读操作<br><em> 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br><br><b>显而易见的原则</b></em> 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作<br><em> 线程中断规则：对线程的interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</em> 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br><em> 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br><br><br><br><h3>线程安全性——总结</h3></em> 原子性：Atomic包、CAS算法、synchronized、Lock<br><em> 可见性：synchronized、volatile</em> 有序性：happens-before<br><br><h3>5.安全发布对象</h3><br><a href="https://postimg.cc/sBjb8q95" target="_blank" rel="noopener"><img src="https://i.postimg.cc/3wm7yHkf/WX20190707-225115-2x.png" alt="WX20190707-225115-2x.png"></a><br><br><br><br><strong>UnsafePublish.java</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafePublish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] states = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafePublish unsafePublis = <span class="keyword">new</span> UnsafePublish();</span><br><span class="line">        System.out.println(Arrays.toString(unsafePublis.getStates()));</span><br><span class="line"></span><br><span class="line">        unsafePublis.getStates()[<span class="number">0</span>] = <span class="string">"d"</span>;</span><br><span class="line">        System.out.println(Arrays.toString(unsafePublis.getStates()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>Console</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c]</span><br><span class="line">[d, b, c]</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><br><br><strong>Escape.java（对象溢出）</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Escape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thisCanBeEscape = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Escape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerClass();   <span class="comment">//在构造函数运行时，启动了一个新线程去实例化InnerClass</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"&#123;&#125;"</span>, Escape.<span class="keyword">this</span>.thisCanBeEscape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Escape();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>Console</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 [main] INFO com.interview.concurrency.publish.Escape - 0</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><br><br><strong>安全发布对象</strong><br><br><em>  在静态初始化函数中初始化一个对象引用</em> 将对象的引用保存到<code>volatile</code>类型域或者<code>AtomicReference</code>对象中<br><em> 将对象的引用保存到某个正确构造对象的final类域中</em> 将对象的引用保存到一个由锁保护的域中<br><br><br><br> <strong>（1）线程不安全的单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annotion.NotThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;     <span class="comment">//此处线程不安全</span></span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 并发情况下，两个线程都同时通过if判断，就会导致实例化两个不同的对象。<br><br><br><br><strong>（2）线程安全的单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 饿汉模式————单例实例类装载使用时创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; ​     饿汉模式是线程安全的，当类的构造方法中没有包含过多的操作处理，饿汉模式是可以接受的。<br>&gt;<br>&gt; ​    但他的不足之处在于：当类的构造方法中包含过多的操作处理时， 会导致类加载时特别慢。 因此可能会引    起性能问题；如果使用饿汉模式只进行类的加载，却没有实际调用的话，会造成资源的浪费。<br><br><br><br><strong>（3）线程安全的“懒汉”模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotRecommend;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@NotRecommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonExample3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 加了<code>synchronized</code>关键字，同一时刻只有一个线程可以访问这个方法，保证了线程安全性。<br>&gt;<br>&gt; 通过使用同一时刻只能有一个线程访问的方式来保证线程安全，但是会带来性能的开销。而这个开销是我们所不希望的，所以不建议这种方式。<br><br><strong>（4）双重同步锁单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> * 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. memory = allocate()分配对象内寸空间</span></span><br><span class="line">    <span class="comment">//2. ctorInstance()初始化对象</span></span><br><span class="line">    <span class="comment">//3. instance = memory 设置instance指向刚才分配的内存空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//JVM和cpu优化，发生了指令重排</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. memory = allocate()分配对象内寸空间、</span></span><br><span class="line">    <span class="comment">//3. instance = memory 设置instance指向刚才分配的内存空间</span></span><br><span class="line">    <span class="comment">//2. ctorInstance()初始化对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//双重检测机制          B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4.class) &#123;  <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4(); <span class="comment">//A-3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 在指令重排的情况，（A-3) 未初始化对象带来的线程不安全问题<br><br><br><br><strong>（5）正确的线程安全的懒汉式单例模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.NotThreadSafe;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:22:20</span></span><br><span class="line"><span class="comment"> * 懒汉模式————单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> * 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例对象  volatile + 双重检测机制 -&gt; 禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonExample5 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. memory = allocate()分配对象内寸空间</span></span><br><span class="line">    <span class="comment">//2. ctorInstance()初始化对象</span></span><br><span class="line">    <span class="comment">//3. instance = memory 设置instance指向刚才分配的内存空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//双重检测机制          B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample5.class) &#123;  <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample5(); <span class="comment">//A-3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>（6）最安全的枚举模式</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.concurrency.publish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.Recommend;</span><br><span class="line"><span class="keyword">import</span> com.interview.annoations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/7/15</span></span><br><span class="line"><span class="comment"> * Time:23:13</span></span><br><span class="line"><span class="comment"> * 枚举模式————最安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JVM保证这个方法只调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h3>11.高并发解决思路之扩容思路</h3><p><a href="https://postimg.cc/1f6nzJMw" target="_blank" rel="noopener"><img src="https://i.postimg.cc/m2pQ8nHX/WX20190704-215857-2x.png" alt="WX20190704-215857-2x.png"></a></p><p><a href="https://postimg.cc/2bZbBGms" target="_blank" rel="noopener"><img src="https://i.postimg.cc/bJ6QWV5w/WX20190704-220347-2x.png" alt="WX20190704-220347-2x.png"></a></p><h3>13.高并发解决思路之消息队列</h3><br><strong>特性</strong><br><br><em> 业务无关：只做消息分发</em> FIFO：先投递先到达<br><em> 容灾：节点的动态增删和消息的持久化</em> 性能：吞吐量提升，系统内部通信效率提高<br><br><br><br><strong>为什么需要消息队列</strong><br><br>&gt; 【生产】和【消费】的速度或稳定性等因素不一致<br><br><br><br><strong>消息队列好处</strong><br><br><em> 业务解耦</em> 最终一致性<br><em> 广播</em> 错峰与流控<br><br><br><br><strong>消息队列举例</strong><br><br><em> Kafka<br><br><a href="https://postimg.cc/TpHcT5dg" target="_blank" rel="noopener"><img src="https://i.postimg.cc/mgTpN7KX/WX20190515-221556-2x.png" alt="WX20190515-221556-2x.png"></a></em> RabbitMQ<br><br><a href="https://postimg.cc/yggHrZ8j" target="_blank" rel="noopener"><img src="https://i.postimg.cc/KzQ8j7X6/WX20190515-221940-2x.png" alt="WX20190515-221940-2x.png"></a><br><br><br><br><br><br><br><br><h3>14.高并发解决思路之应用拆分</h3><br><a href="https://postimg.cc/GB5Msxn0" target="_blank" rel="noopener"><img src="https://i.postimg.cc/50xDTsPt/WX20190626-220947-2x.png" alt="WX20190626-220947-2x.png"></a><br><br><br><br><a href="https://postimg.cc/nM0L3NrH" target="_blank" rel="noopener"><img src="https://i.postimg.cc/qMdCvTdC/WX20190704-213601-2x.png" alt="WX20190704-213601-2x.png"></a><br><br><a href="https://postimg.cc/LJvv596c" target="_blank" rel="noopener"><img src="https://i.postimg.cc/yNCGfWq8/WX20190704-213815-2x.png" alt="WX20190704-213815-2x.png"></a><br><br><a href="https://postimg.cc/xJmKvnnT" target="_blank" rel="noopener"><img src="https://i.postimg.cc/gJSNP27R/WX20190704-213920-2x.png" alt="WX20190704-213920-2x.png"></a><br><br><br><br><a href="https://postimg.cc/c62JqwRj" target="_blank" rel="noopener"><img src="https://i.postimg.cc/pXX5FBp2/WX20190704-213959-2x.png" alt="WX20190704-213959-2x.png"></a><br><br><a href="https://postimg.cc/yDJ5M3Tf" target="_blank" rel="noopener"><img src="https://i.postimg.cc/GmzCskT1/WX20190704-214449-2x.png" alt="WX20190704-214449-2x.png"></a><br><br><a href="https://postimg.cc/CRfPPTFX" target="_blank" rel="noopener"><img src="https://i.postimg.cc/T3tzPfBd/WX20190704-214535-2x.png" alt="WX20190704-214535-2x.png"></a><br><br><h3>15.高并发之应用限流思路</h3><p><a href="https://postimg.cc/k2FXL5vt" target="_blank" rel="noopener"><img src="https://i.postimg.cc/sgbQQQBK/WX20190704-221013-2x.png" alt="WX20190704-221013-2x.png"></a></p><p><a href="https://postimg.cc/HrJgHkmL" target="_blank" rel="noopener"><img src="https://i.postimg.cc/13B5G8YD/WX20190704-221221-2x.png" alt="WX20190704-221221-2x.png"></a></p><p><a href="https://postimg.cc/HrB1Q8t3" target="_blank" rel="noopener"><img src="https://i.postimg.cc/KYychn3X/WX20190704-222107-2x.png" alt="WX20190704-222107-2x.png"></a></p><p><a href="https://postimg.cc/S2z0FTbt" target="_blank" rel="noopener"><img src="https://i.postimg.cc/wvw9NZfH/WX20190704-222138-2x.png" alt="WX20190704-222138-2x.png"></a></p><p><a href="https://postimg.cc/Z9BsCWsW" target="_blank" rel="noopener"><img src="https://i.postimg.cc/JhKfYJb5/WX20190704-222258-2x.png" alt="WX20190704-222258-2x.png"></a></p><p><a href="https://postimg.cc/bdDnWQDD" target="_blank" rel="noopener"><img src="https://i.postimg.cc/QNSqBmjb/WX20190704-222545-2x.png" alt="WX20190704-222545-2x.png"></a></p><p></p><h3>16.高并发之服务降级与服务熔断思路</h3><br><img src="https://i.postimg.cc/J0hYqZdq/WX20190707-205833-2x.png" alt><p></p><p><a href="https://postimg.cc/JD4GgdQb" target="_blank" rel="noopener"><img src="https://i.postimg.cc/tTFWsKZm/WX20190707-210322-2x.png" alt="WX20190707-210322-2x.png"></a></p><p><a href="https://postimg.cc/dLv8V9vp" target="_blank" rel="noopener"><img src="https://i.postimg.cc/kXRwwjHJ/WX20190707-213457-2x.png" alt="WX20190707-213457-2x.png"></a></p><p><a href="https://postimg.cc/2bRxFNR8" target="_blank" rel="noopener"><img src="https://i.postimg.cc/d1DSFJ5d/WX20190707-213551-2x.png" alt="WX20190707-213551-2x.png"></a></p><p><a href="https://postimg.cc/hJFmN8C2" target="_blank" rel="noopener"><img src="https://i.postimg.cc/vmTvg35w/WX20190707-213654-2x.png" alt="WX20190707-213654-2x.png"></a></p><p></p><h3>17.高并发之数据库切库分库分表思路</h3><br><a href="https://postimg.cc/mh0mNnMn" target="_blank" rel="noopener"><img src="https://i.postimg.cc/3Jwz75w3/WX20190707-222739-2x.png" alt="WX20190707-222739-2x.png"></a><p></p><p><a href="https://postimg.cc/3WCZmw8k" target="_blank" rel="noopener"><img src="https://i.postimg.cc/pV31N93J/WX20190707-222913-2x.png" alt="WX20190707-222913-2x.png"></a></p><p><a href="https://postimg.cc/TyVKFpHm" target="_blank" rel="noopener"><img src="https://i.postimg.cc/s285BWYn/WX20190707-223004-2x.png" alt="WX20190707-223004-2x.png"></a></p><p><a href="https://postimg.cc/Hj4fnHF2" target="_blank" rel="noopener"><img src="https://i.postimg.cc/CMWYvxNW/WX20190707-223138-2x.png" alt="WX20190707-223138-2x.png"></a></p><p><a href="https://postimg.cc/5XNHT4Wk" target="_blank" rel="noopener"><img src="https://i.postimg.cc/htV9Jvyg/WX20190707-223929-2x.png" alt="WX20190707-223929-2x.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://996.icu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/link-996.icu-red.svg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIFY_6AA3VjT9w7FMAALGfwFCj8AADdWl862.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3&gt;4.线程安全性&lt;/h3&gt;&lt;br&gt;定义：当多个线程访问某个类时，不管运行时环境采用&lt;b&gt;何种调度方式&lt;/b&gt;或者这些进程将如何交替执行，并且在主调代码中&lt;b&gt;不需要任何额外的同步或协同&lt;/b&gt;，这个类都能表现出&lt;b&gt;正确的行为&lt;/b&gt;，那么就称这个类是线程安全的。&lt;br&gt;&lt;br&gt;&lt;em&gt; 原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。
&lt;/em&gt; 可见性：一个线程对主内存的修改可以及时的被其他线程观察到。&lt;br&gt;&lt;em&gt; 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="高并发" scheme="http://yoursite.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下shadowsocks 配合SwitchyOmega科学上网</title>
    <link href="http://yoursite.com/2017/11/03/Ubuntu%E4%B8%8B%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://yoursite.com/2017/11/03/Ubuntu下科学上网/</id>
    <published>2017-11-02T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.867Z</updated>
    
    <content type="html"><![CDATA[<p>最近重新装起了阔别已久的ubuntu，第一件事当然是科学上网啊。大概需要下面几步</p><h3 id="1-一个代理服务账号"><a href="#1-一个代理服务账号" class="headerlink" title="1.一个代理服务账号"></a>1.一个代理服务账号</h3><p>&nbsp;&nbsp;这里我推荐 <a href="https://jikess.org/" target="_blank" rel="noopener">jikess</a>，一个月只需要12大洋，200G代理流量，速度也很客观。自行注册购买，或者也可以先领几十M先体验下。</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/02/08/ChMkJlbKzWGIZIhdAAQNZj09ufQAALJAQMP9cYABA1-499.jpg" alt></p><a id="more"></a><h3 id="2-ubuntu使用shadowsocks"><a href="#2-ubuntu使用shadowsocks" class="headerlink" title="2. ubuntu使用shadowsocks"></a>2. ubuntu使用shadowsocks</h3><p> <b>1.安装shadowsocks命令行程序，配置命令。</b></p><p> 2.安装shadowsocks GUI图形界面程序，配置。<br></p><h4 id="第一种安装shadowsocks命令行程序"><a href="#第一种安装shadowsocks命令行程序" class="headerlink" title="第一种安装shadowsocks命令行程序"></a>第一种安装shadowsocks命令行程序</h4><p>用PIP安装很简单</p><pre><code>sudo apt-get updatesudo apt-get install python-pipsudo apt-get install python-setuptools m2crypto</code></pre><p>接着安装shadowsocks</p><pre><code>pip install shadowsocks</code></pre><p>如果是ubuntu16.04 直接 (16.04 里可以直接用apt 而不用 apt-get 这是一项改进）</p><pre><code>sudo apt install shadowsocks</code></pre><p>当然你在安装时候肯定有提示需要安装一些依赖比如<code>python-setuptools m2crypto</code> ，依照提示安装然后再安装就好。也可以网上搜索有很多教程的。</p><h4>启动shadowsocks</h4><p>安装好后，在本地我们要用到sslocal ，终端输入sslocal –help 可以查看帮助，像这样</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-04%2017-03-17%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>通过帮助提示我们知道各个参数怎么配置，比如 sslocal -c 后面加上我们的json配置文件，或者像下面这样直接命令参数写上运行。</p><p>比如</p><pre><code>sslocal -s 11.22.33.44 -p 50003 -k &quot;123456&quot; -l 1080 -t 600 -m aes-256-cfb</code></pre><p> -s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加””）, -t超时默认300,-m是加密方法默认<code>aes-256-cfb</code>，</p><p> <b>为了方便我推荐直接用sslcoal -c 配置文件路径 这样的方式，简单好用。</b></p><p>我们可以在/home/{user}/ 下新建个文件shadowsocks.json  ({user}是你自己电脑上的用户名)。内容是这样：</p><pre><code>{    &quot;server&quot;:&quot;11.22.33.44&quot;,    &quot;server_port&quot;:50003,    &quot;local_port&quot;:1080,    &quot;password&quot;:&quot;123456&quot;,    &quot;timeout&quot;:600,    &quot;method&quot;:&quot;aes-256-cfb&quot;}</code></pre><p>server  你服务端的IP<br>servier_port  你服务端的端口<br>local_port  本地端口，一般默认1080<br>passwd  ss服务端设置的密码<br>timeout  超时设置 和服务端一样<br>method  加密方法 和服务端一样</p><p>确定上面的配置文件没有问题，然后我们就可以在终端输入 <code>sslocal -c /home/{user}/shadowsocks.json</code> 回车运行。如果没有问题的话，下面会是这样…</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-04%2017-11-06%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h4 id="第二种-安装图形界面"><a href="#第二种-安装图形界面" class="headerlink" title="第二种 安装图形界面"></a>第二种 安装图形界面</h4><p><b>在 Ubuntu下 通过PPA源安装，仅支持Ubuntu 14.04或更高版本。</b></p><pre><code>sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5</code></pre><p>由于是图形界面，配置和windows基本没啥差别就不赘述了。</p><p>经过上面两种方式的配置，你只是启动了sslocal 但是要上网你还需要配置下浏览器到指定到代理端口比如1080才可以正式上网。你可以去系统的代理设置按照说明设置代理，但一般是全局的，然而我们访问baidu,taobao等着些网站如果用代理就有点绕了，而且还会浪费服务器流量。我们最好配置我们的浏览器让它可以自动切换，该用代理用代理该直接连接自动直接连接。所以请看配置浏览器。</p><h3 id="3-配置浏览器（chrome"><a href="#3-配置浏览器（chrome" class="headerlink" title="3.配置浏览器（chrome)"></a>3.配置浏览器（chrome)</h3><p>我们需要给chrome安装SwitchyOmega插件，但是没有代理之前是不能从谷歌商店安装这个插件的，但是我们可以从Github上直接下载最新版 <a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases/</a> （这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。</p><p><b>上面也是我之前一直用的方法，屡试不爽。但是这次不知道为啥在拖进chrome后始终没反应，无法离线安装。于是我决定先配置全局代理，这样chrome可以直接访问谷歌商店，然后再直接在线安装SwitchyOmega，实现代理自动切换的目的。</b></p><h4>先配置全局代理</h4><p>1、安装GenPAC<br>GenPAC 是基于gfwlist的代理自动配置（Proxy Auto-config）文件生成工具，支持自定义规则。在多数情况下，我们更希望使用PAC模式的代理，让我们访问国内网站时不再先绕地球跑一圈，在Windows和Mac上的shadowsocks客户端可以轻松切换到PAC模式，而在Ubuntu上我们需要使用pac文件来设置系统代理以达到相同的效果</p><pre><code>sudo pip install genpacpip install --upgrade genpac</code></pre><p>2、使用GenPAC生成pac文件</p><pre><code>genpac -p &quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output=&quot;autoproxy.pac&quot;</code></pre><p>3、设置全局代理</p><p>点击：System settings &gt; Network &gt; Network Proxy，选择 Method 为 Automatic，设置 Configuration URL 为 autoproxy.pac 文件的路径，点击 Apply System Wide。<br>格式如：<code>file:///home/{user}/autoproxy.pac</code></p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-28-09%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>4、安装switchyOmega<br>  此时应该可以按照一定过滤规则访问外网了，但仍配置下浏览器（毕竟善始善终）</p><p>  <img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-32-26%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h4> 配置switchyOmega</h4><p>1.配置代理地址</p><p>安装好插件会自动跳到设置选项，有提示你可以跳过。左边新建情景模式-选择代理服务器-比如命名为proxy（叫什么无所谓）其他默认之后创建，之后在代理协议选择SOCKS5，地址为127.0.0.1,端口默认1080 。然后保存即应用选项。</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-35-17%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>2.设置自动切换</p><p>接着点击自动切换 ( Auto switch）上面的不用管，在按照规则列表匹配请求后面选择刚才新建的proxy，默认情景模式选择直接连接。点击应用选项保存。再往下规则列表设置选择AutoProxy 然后将这个地址(<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>) 填进去，点击下面的立即更新情景模式，会有提示更新成功！</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-37-58%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p><b>点击浏览器右上角的SwitchyOmega图标，下面选择自动切换，然后打开google.com试试，其他的就不在这贴图了。</b></p><h4>至此shadowsocks搭建完成，天高任鸟飞，海阔任鱼跃。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近重新装起了阔别已久的ubuntu，第一件事当然是科学上网啊。大概需要下面几步&lt;/p&gt;
&lt;h3 id=&quot;1-一个代理服务账号&quot;&gt;&lt;a href=&quot;#1-一个代理服务账号&quot; class=&quot;headerlink&quot; title=&quot;1.一个代理服务账号&quot;&gt;&lt;/a&gt;1.一个代理服务账号&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;这里我推荐 &lt;a href=&quot;https://jikess.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jikess&lt;/a&gt;，一个月只需要12大洋，200G代理流量，速度也很客观。自行注册购买，或者也可以先领几十M先体验下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/02/08/ChMkJlbKzWGIZIhdAAQNZj09ufQAALJAQMP9cYABA1-499.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ShadowSocks" scheme="http://yoursite.com/tags/ShadowSocks/"/>
    
  </entry>
  
  <entry>
    <title>SSH整合过程中的问题</title>
    <link href="http://yoursite.com/2017/01/13/SSH%E6%95%B4%E5%90%88%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/01/13/SSH整合出现的一些异常/</id>
    <published>2017-01-12T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.866Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="首先介绍下博主的工作环境"><a href="#首先介绍下博主的工作环境" class="headerlink" title="首先介绍下博主的工作环境"></a>首先介绍下博主的工作环境</h2><p><strong></strong></p><ul><li>系统：<code>Ubuntu 16.04 LTS</code></li><li>IDE: <code>Myeclispe 2015</code></li><li>Server: <code>Myeclipse2015</code>自带的<code>Myeclipse Tomcat v7.0</code></li><li>框架版本: <code>Struts 2.1</code>  <code>Spring 4.1</code> <code>Hibernate 4.1.4</code></li></ul><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g2/M00/01/0E/Cg-4WlU4niOIChfEAAtm0dNCMiIAACHugPmzzsAC2bp782.jpg" alt></p><a id="more"></a><h2 id="先介绍下-SSH-经典架构（大神请跳过"><a href="#先介绍下-SSH-经典架构（大神请跳过" class="headerlink" title="先介绍下 SSH 经典架构（大神请跳过)"></a>先介绍下 <code>SSH</code> 经典架构（大神请跳过)</h2><p>首先，SSH不是一个框架，而是多个框架（struts+spring+hibernate）的集成，是目前较流行的一种Web应用程序开源集成框架，用于构建灵活、易于扩展的多层Web应用程序。</p><p>集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层（实体层）。</p><p>Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，控制业务跳转，利用Hibernate框架对持久层提供支持。Spring一方面作为一个轻量级的IoC容器，负责查找、定位、创建和管理对象及对象之间的依赖关系，另一方面能使Struts和Hibernate更好地工作。</p><h2 id="以下是最近做项目时遇到的一些问题"><a href="#以下是最近做项目时遇到的一些问题" class="headerlink" title="以下是最近做项目时遇到的一些问题"></a>以下是最近做项目时遇到的一些问题</h2><h3 id="1-Struts2自带的antlr-2-7-2-jar与Hibernate4-1-4自带的antlr-2-7-7-jar发生冲突"><a href="#1-Struts2自带的antlr-2-7-2-jar与Hibernate4-1-4自带的antlr-2-7-7-jar发生冲突" class="headerlink" title="1.Struts2自带的antlr-2.7.2.jar与Hibernate4.1.4自带的antlr-2.7.7.jar发生冲突"></a>1.Struts2自带的<code>antlr-2.7.2.jar</code>与Hibernate4.1.4自带的<code>antlr-2.7.7.jar</code>发生冲突</h3><p>  <strong> 报错内容如下: </strong></p><pre><code>java.lang.NoSuchMethodError: antlr.collections.AST.getLine()I</code></pre><h3 id="这是一个ssh整合的经典bug-解决方案是"><a href="#这是一个ssh整合的经典bug-解决方案是" class="headerlink" title="这是一个ssh整合的经典bug ,解决方案是:"></a>这是一个ssh整合的经典bug ,解决方案是:</h3><p>  <strong> 在Myeclipse2015中打开<code>window -&gt; perference -&gt; project libraries</code>在里面找到<code>struts2.1 Libraries-&gt; core-&gt;  antlr-2.7.2.jar</code> 点击取消勾选这个jar包， 然后点击Apply ，最后重新部署下工程就ok了</strong></p><h3 id="2-Spring事务管理出错"><a href="#2-Spring事务管理出错" class="headerlink" title="2.Spring事务管理出错"></a>2.Spring事务管理出错</h3><p>   <strong> 报错内容如下: </strong></p><pre><code>Write operations are not allowed in read-only mode (FlushMode.MANUAL): Turn your Session into FlushMode.COMMIT/AUTO or remove &apos;readOnly&apos; markerfrom transaction definition.</code></pre><p><strong> 大意是：只读模式下(FlushMode.NEVER/MANUAL)写操作不被允许：把你的Session改成FlushMode.COMMIT/AUTO或者清除事务定义中的readOnly标记。</strong></p><h3 id="解决方案是-配置Spring的事务管理"><a href="#解决方案是-配置Spring的事务管理" class="headerlink" title="解决方案是:配置Spring的事务管理"></a>解决方案是:配置Spring的事务管理</h3><p>  在applicationContext.xml中加入</p><pre><code>&lt;tx:advice id=&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;&lt;tx:attributes&gt;  &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;modify*&quot; propagation=&quot;REQUIRED&quot;    rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt;&lt;aop:pointcut id=&quot;daoMethod&quot; expression=&quot;execution(* com.muke.employee.daoImpl.*.*(..))&quot; /&gt;&lt;aop:advisor pointcut-ref=&quot;daoMethod&quot; advice-ref=&quot;txadvice&quot; /&gt;&lt;/aop:config&gt;</code></pre><ul><li><code>expression=&quot;execution( com.dao..(..))&quot;</code>其中第一个<em>代表返回值，第二代表daoImpl下子包，第三个代表方法名，“（..）”代表方法参数。</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;首先介绍下博主的工作环境&quot;&gt;&lt;a href=&quot;#首先介绍下博主的工作环境&quot; class=&quot;headerlink&quot; title=&quot;首先介绍下博主的工作环境&quot;&gt;&lt;/a&gt;首先介绍下博主的工作环境&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统：&lt;code&gt;Ubuntu 16.04 LTS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;IDE: &lt;code&gt;Myeclispe 2015&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Server: &lt;code&gt;Myeclipse2015&lt;/code&gt;自带的&lt;code&gt;Myeclipse Tomcat v7.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;框架版本: &lt;code&gt;Struts 2.1&lt;/code&gt;  &lt;code&gt;Spring 4.1&lt;/code&gt; &lt;code&gt;Hibernate 4.1.4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g2/M00/01/0E/Cg-4WlU4niOIChfEAAtm0dNCMiIAACHugPmzzsAC2bp782.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="http://yoursite.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架整合</title>
    <link href="http://yoursite.com/2017/01/10/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
    <id>http://yoursite.com/2017/01/10/SSM框架整合/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.867Z</updated>
    
    <content type="html"><![CDATA[<hr><b>这里的SSM指的是（<code>Spring-Springmvc-Mybatis</code>)三大框架</b><h4>前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;我们看招聘信息的时候，经常会看到这一点，需要具备<code>SSH</code>(<code>Struts-Spring-Hibernate</code>)框架的技能；而且在大部分教学课堂中，也会把<code>SSH</code>作为最核心的教学内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;但是，我们在实际应用中发现，<code>SpringMVC</code>可以完全替代<code>Struts</code>，配合注解的方式，编程非常快捷，而且通过restful风格定义url，让地址看起来非常优雅。<br>&nbsp;&nbsp;&nbsp;&nbsp;另外，<code>MyBatis</code>也可以替换<code>hibernate</code>，正因为<code>MyBatis</code>的半自动特点，我们程序猿可以完全掌控SQL，这会让有数据库经验的程序猿能开发出高效率的SQL语句，而且XML配置管理起来也非常方便。<br>&nbsp;&nbsp;&nbsp;&nbsp;下面我们开始进行SSM框架的整合。</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIJK4PAAfFWxl1L9IAALJAQM0wFQAB8Vz309.jpg" alt></p><a id="more"></a><p></p><h4>介绍</h4><br>在整合之前先介绍一下这三个框架，之前有了解的可以跳过.这里尽量通俗易懂的简单讲解一下。<p></p><ul><li><p>Springmvc<br>  &nbsp;&nbsp;&nbsp;&nbsp;它用于web层，相当于controller（等价于传统的servlet和struts的action），用来处理用户请求。举个例子，用户在地址栏输入<a href="http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法，（中间可能包含验证用户名和密码的业务逻辑，以及查询数据库操作，但这些都不是springmvc的职责），最终把结果返回给用户，并且返回相应的页面（当然也可以只反馈josn/xml等格式数据）。springmvc就是做前面和后面过程的活，与用户打交道！！" target="_blank" rel="noopener">http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法，（中间可能包含验证用户名和密码的业务逻辑，以及查询数据库操作，但这些都不是springmvc的职责），最终把结果返回给用户，并且返回相应的页面（当然也可以只反馈josn/xml等格式数据）。springmvc就是做前面和后面过程的活，与用户打交道！！</a></p></li><li><p>Spring<br>&nbsp;&nbsp;&nbsp;&nbsp; 太强大了，以至于我无法用一个词或一句话来概括它。但与我们平时开发接触最多的估计就是IOC容器，它可以装载bean（也就是我们Java中的类，当然也包括service dao里面的），有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。</p></li></ul><ul><li>Mybatis<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你问我它跟鼎鼎大名的Hibernate有什么区别？我只想说，他更符合我的需求。第一，它能自由控制sql，这会让有数据库经验的人编写的代码能搞提升数据库访问的效率。第二，它可以使用xml的方式来组织管理我们的sql，因为一般程序出错很多情况下是sql出错，别人接手代码后能快速找到出错地方，甚至可以优化原来写的sql。</li></ul><p></p><h4>SSM框架整合配置</h4><br>&nbsp;&nbsp;&nbsp;&nbsp;首先在Myeclipse中建立一个<code>Maven Web</code>工程。(对这步有疑问的可以看我之前的博客<a href="http://blog.pockerface.cn/2016/10/20/使用项目管理利器Maven/" target="_blank" rel="noopener">使用项目管理工具 <code>Maven</code></a>)<br>这是相应的项目目录<p></p><center><br><img src="http://7xta11.com1.z0.glb.clouddn.com/SSM.png" alt><br></center><br><strong>这里介绍下Maven目录规范下各目录的作用</strong><br><del>====</del><br><br>| 文件名           | 作用          |<br>| ————- |:————-:|<br>|src           |根目录，没什么好说的，下面有main和test |<br>|main    |主要目录，可以放java代码和一些资源文件|<br>|java    |存放我们的java代码 |<br>|resources    | 存放资源文件，譬如各种的spring，mybatis，log配置文件|<br>mapper    |存放dao中每个方法对应的sql，在这里配置，无需写daoImpl|<br>|spring        |这里当然是存放spring相关的配置文件，有dao service web三层|<br>|test    |这里是测试分支|<br>|java    |测试java代码，应遵循包名相同的原则，这个文件夹同样要使用Build Path -&gt; Use as Source Folder，这样看包结构会方便很多|<br>|resources    |没什么好说的，好像也很少用到，但这个是maven的规范|<br>webapp    |用来存放我们前端的静态资源，如jsp js css|<br>|resources    |这里的资源是指项目的静态资源，如js css images等|<br>|WEB-INF    |很重要的一个目录，外部浏览器无法访问，只有羡慕内部才能访问，可以把jsp放在这里，另外就是web.xml了。你可能有疑问了，为什么上面java中的resources里面的配置文件不妨在这里，那么是不是会被外部窃取到？你想太多了，部署时候基本上只有webapp里的会直接输出到根目录，其他都会放入WEB-INF里面，项目内部依然可以使用classpath:XXX来访问，好像IDE里可以设置部署输出目录|<br><br><strong>讲解几个必要的包，顺便讲解一下每个包的作用.</strong><br><center><br><img src="http://7xta11.com1.z0.glb.clouddn.com/SSM2.png" alt><br></center><table><thead><tr><th>包名</th><th style="text-align:center">名称</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td>dao</td><td style="text-align:center">数据访问层（接口）</td><td style="text-align:right">与数据打交道，可以是数据库操作，也可以是文件读写操作，甚至是redis缓存操作，总之与数据操作有关的都放在这里，也有人叫做dal或者数据持久层都差不多意思。为什么没有daoImpl，因为我们用的是mybatis，所以可以直接在配置文件中实现接口的每个方法。</td></tr><tr><td>entity</td><td style="text-align:center">实体类</td><td style="text-align:right">一般与数据库的表相对应，封装dao层取出来的数据为一个对象，也就是我们常说的pojo，一般只在dao层与service层之间传输</td></tr><tr><td>dto</td><td style="text-align:center">数据传输层</td><td style="text-align:right">刚学框架的人可能不明白这个有什么用，其实就是用于service层与web层之间传输，为什么不直接用entity（pojo）？其实在实际开发中发现，很多时候一个entity并不能满足我们的业务需求，可能呈现给用户的信息十分之多，这时候就有了dto，也相当于vo，记住一定不要把这个混杂在entity里面</td></tr><tr><td>service</td><td style="text-align:center">业务逻辑（接口）</td><td style="text-align:right">写我们的业务逻辑，也有人叫bll，在设计业务接口时候应该站在“使用者”的角度</td></tr><tr><td>impl</td><td style="text-align:center">业务逻辑（实现）</td><td style="text-align:right">实现我们业务接口，一般事务控制是写在这里</td></tr><tr><td>web</td><td style="text-align:center">控制器</td><td style="text-align:right">springmvc就是在这里发挥作用的，一般人叫做controller控制器，相当于struts中的action</td></tr></tbody></table><p><strong>添加依赖</strong><br>    SSM整合需要导入相应的jar包,我们使用maven来管理我们的jar，所以只需要在<code>pom.xml</code>中加入相应的依赖。如果没有使用maven的话,可以自己去官网下载相应的jar包，然后放到项目的WEB-INF/lib目录下.</p><p><b>三个主要框架版本</b></p><ul><li><code>Spring---4.3.3.RELEASE</code><ul><li><code>spring mvc ---- 4.3.3.RELEASE</code></li><li><code>mybatis ---- 3.2.5</code></li></ul></li></ul><p><b>其他</b></p><ul><li><p><code>junit ---- 4.8.1</code></p></li><li><p><code>MySQL ---- 5.1.38</code></p></li><li><p><code>log4j ---- 1.2.17</code></p></li><li><p><code>c3p0 ---- 0.9.2.1</code></p></li><li><p><code>mybatis-spring ---- 1.3.0</code>  </p></li><li><p><code>jstl ---- 1.2</code></p></li></ul><p><b>pom.xml文件如下</b></p><pre><code>  &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.fendo.ssm&lt;/groupId&gt;    &lt;artifactId&gt;fendo-SSM&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;fendo-SSM Maven Webapp&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;      &lt;!-- 初始化框架的版本号 --&gt;      &lt;properties&gt;          &lt;spring.version&gt;4.3.3.RELEASE&lt;/spring.version&gt;      &lt;/properties&gt;    &lt;dependencies&gt;      &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;3.8.1&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;      &lt;/dependency&gt;           &lt;!-- 加入ServletAPI --&gt;          &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;          &lt;dependency&gt;              &lt;groupId&gt;javax.servlet&lt;/groupId&gt;              &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;              &lt;version&gt;2.3&lt;/version&gt;              &lt;scope&gt;provided&lt;/scope&gt;          &lt;/dependency&gt;          &lt;!-- MySQL依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;mysql&lt;/groupId&gt;              &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;              &lt;version&gt;5.1.38&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- MySQL依赖 end --&gt;          &lt;!-- 加入MyBatis 依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.mybatis&lt;/groupId&gt;              &lt;artifactId&gt;mybatis&lt;/artifactId&gt;              &lt;version&gt;3.2.5&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 加入MyBatis 依赖 end --&gt;          &lt;!-- Log4j start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;log4j&lt;/groupId&gt;              &lt;artifactId&gt;log4j&lt;/artifactId&gt;              &lt;version&gt;1.2.17&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- Log4j end --&gt;             &lt;!-- 引入Spring(包含SpringMVC) 依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-core&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-web&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-test&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 引入Spring 依赖 end --&gt;          &lt;!-- 引用c3p0 依赖 start--&gt;          &lt;dependency&gt;              &lt;groupId&gt;com.mchange&lt;/groupId&gt;              &lt;artifactId&gt;c3p0&lt;/artifactId&gt;              &lt;version&gt;0.9.2.1&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 引用c3p0 依赖 end--&gt;          &lt;!-- 引用插件依赖：MyBatis整合Spring --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.mybatis&lt;/groupId&gt;              &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;              &lt;version&gt;1.3.0&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- JSTL --&gt;          &lt;dependency&gt;              &lt;groupId&gt;jstl&lt;/groupId&gt;              &lt;artifactId&gt;jstl&lt;/artifactId&gt;              &lt;version&gt;1.2&lt;/version&gt;          &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;      &lt;finalName&gt;fendo-SSM&lt;/finalName&gt;      &lt;plugins&gt;        &lt;!-- 加入Tomcat插件 --&gt;          &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;                  &lt;configuration&gt;                       &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt;                      &lt;username&gt;admin&lt;/username&gt;                        &lt;password&gt;admin&lt;/password&gt;                  &lt;/configuration&gt;           &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/build&gt;  &lt;/project&gt;</code></pre><p>   </p><h4>编码配置文件</h4><br>      <b>第一步：</b>我们先在spring文件夹里新建<code>spring-dao.xml</code>文件，因为spring的配置太多，我们这里分三层，分别是dao, service , web.<p></p><ol><li>读入数据库连接相关参数（可选）</li><li><p>配置数据连接池</p><ol><li>配置连接属性，可以不读配置项文件直接在这里写死</li><li>配置c3p0，只配了几个常用的</li></ol></li><li><p>配置SqlSessionFactory对象（mybatis）</p></li><li><p>扫描dao层接口，动态实现dao接口，也就是说不需要daoImpl，sql和参数都写在xml文件上</p><p><b>spring-dao.xml</b></p></li></ol><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     &quot;&gt;     &lt;context:annotation-config /&gt;    &lt;!-- 配置整合MyBatis过程 --&gt;    &lt;!-- 1.配置数据库相关参数properties的属性:${url} --&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;    &lt;!--2.数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!-- 配置连接池属性 --&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;        &lt;!-- c3p0私有属性 --&gt;        &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;&gt;&lt;/property&gt;        &lt;!-- 关闭连接后不自动commit --&gt;        &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;&gt;&lt;/property&gt;        &lt;!-- 获取连接超时时间 --&gt;        &lt;property name=&quot;checkoutTimeout&quot; value=&quot;1000&quot;&gt;&lt;/property&gt;        &lt;!-- 当获取连接失败重试次数 --&gt;        &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 3.配置sqlSessionFactory对象 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 注入数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;        &lt;!-- 配置MyBatis全局配置文件:myBatis-config.xml --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;        &lt;!-- 扫描entity包，使用别名 --&gt;        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;org.seckill.entity&quot;&gt;&lt;/property&gt;        &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!-- 注入sqlSessionFactory --&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;        &lt;!-- 给出需要扫描的Dao接口包 --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.blog.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>&nbsp;&nbsp;因为数据库配置相关参数是读取配置文件，所以在resources文件夹里新建一个jdbc.properties文件，存放我们4个最常见的数据库连接属性，这是我本地的，大家记得修改.如果大家上传github时记得删掉密码，不然别人就很容易得到你服务器的数据库配置信息.    </p><p><b>jdbc.properties</b></p><pre><code>jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://127.0.0.1\:3306/personBlogjdbc.username=rootjdbc.password=</code></pre><p><b>友情提示：</b>配置文件中的jdbc.username，如果写成username，可能会与系统环境中的username变量冲突，所以到时候真正连接数据库的时候，用户名就被替换成系统中的用户名（有得可能是administrator），那肯定是连接不成功的，这里有个小坑,需要大家注意.</p><p>这里用到了mybatis,所以接下来需要配置mybatis核心文件,在<code>resources</code>文件夹下新建<code>mybatis-config.xml</code>文件</p> <li>  使用自增主键</li><br><li> 使用列别名</li><br> <li>   开启驼峰命名转换 create_time -&gt; createTime</li><p><b>mybatis-config.xml</b></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 配置全局属性 --&gt;    &lt;settings&gt;        &lt;!-- 使用jdbc的getGenerateKeys获取数据库自增主键 --&gt;        &lt;setting name=&quot;useGererateKeys&quot; value=&quot;true&quot; /&gt;        &lt;!-- 使用列别名替换列名 默认：true --&gt;        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt;        &lt;!-- 开启驼峰命名转换 --&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt;    &lt;/settings&gt;&lt;/configuration&gt;</code></pre><p><b>第二步:</b>刚弄好dao层，接下来到service层了。在spring文件夹里新建<code>spring-service.xml</code>文件。    </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;                 xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans             http://    www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     &quot;&gt;    &lt;!-- 扫描service包下所有使用注解的类型 --&gt;    &lt;context:component-scan base-package=&quot;com.blog.service&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 注入事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot;        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!-- 注入数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置基于注解的声明式事务 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt;</code></pre><p><b>第三步:</b>配置web层，在spring文件夹里新建spring-web.xml文件.</p><ol><li><p>开启SpringMVC注解模式，可以使用@RequestMapping，@PathVariable，@ResponseBody等</p><ol><li>对静态资源处理，如js，css，jpg等</li><li>配置jsp 显示ViewResolver，例如在controller中某个方法返回一个string类型的 “login”，实际上会返回”/WEB-INF/login.jsp”</li><li>扫描web层 @Controller</li></ol><p><b>spring-web.xml</b></p></li></ol><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     http://www.springframework.org/schema/mvc     http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd     &quot;&gt;    &lt;!-- 配置springMVC --&gt;    &lt;!-- 1:开启springMVC注解模式 --&gt;    &lt;!-- 简化配置： （1）自动注册DefaultAnnotationHandlerMapping,AnnotationMethodHandlerAdapter         (2)提供一系列：数据绑定，数字和日期的format @NumberFormat ,@DataTimeFormat ,xml ,json默认读写支持 --&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!-- 2.静态资源默认servlet配置        1：允许加入对静态资源的处理：js,gif,png        2:允许使用&quot;/&quot;做整体映射     --&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!--3：配置jsp 显示ViewResolver--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 4:扫描web相关的bean --&gt;    &lt;context:component-scan base-package=&quot;org.seckill.web&quot;/&gt;&lt;/beans&gt;</code></pre><p>  <b>第四步:</b>最后就是修改web.xml文件了，它在webapp的<code>WEB-INF</code>下。<br><b>web.xml</b></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;&lt;!-- maven命令创建的servlet版本较低，默认没有打开JSTL，所以更改servlet版本为3.0 --&gt;  &lt;!-- 配置DispatcherServlet --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;blog-dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- 配置springMVC需要加载的配置文件            spring-dao.xml ,spring-service.xml ,spring-web.xml            Mybatis -&gt;spring -&gt;springMVC         --&gt;         &lt;init-param&gt;             &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;             &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;         &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;blog-dispatcher&lt;/servlet-name&gt;        &lt;!-- 默认匹配所有请求 --&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>我们在项目中经常会使用到日志，所以这里还有配置日志xml，在<code>resources</code>文件夹里新建<code>logback.xml</code>文件，所给出的日志输出格式也是最基本的控制台呼出，大家有兴趣查看<code>logback官方文档</code>。</p><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;configuration debug=&quot;true&quot;&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!-- encoders are by default assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n            &lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=&quot;debug&quot;&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;&lt;/configuration&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;b&gt;这里的SSM指的是（&lt;code&gt;Spring-Springmvc-Mybatis&lt;/code&gt;)三大框架&lt;/b&gt;

&lt;h4&gt;前言&lt;/h4&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们看招聘信息的时候，经常会看到这一点，需要具备&lt;code&gt;SSH&lt;/code&gt;(&lt;code&gt;Struts-Spring-Hibernate&lt;/code&gt;)框架的技能；而且在大部分教学课堂中，也会把&lt;code&gt;SSH&lt;/code&gt;作为最核心的教学内容。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;但是，我们在实际应用中发现，&lt;code&gt;SpringMVC&lt;/code&gt;可以完全替代&lt;code&gt;Struts&lt;/code&gt;，配合注解的方式，编程非常快捷，而且通过restful风格定义url，让地址看起来非常优雅。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;另外，&lt;code&gt;MyBatis&lt;/code&gt;也可以替换&lt;code&gt;hibernate&lt;/code&gt;，正因为&lt;code&gt;MyBatis&lt;/code&gt;的半自动特点，我们程序猿可以完全掌控SQL，这会让有数据库经验的程序猿能开发出高效率的SQL语句，而且XML配置管理起来也非常方便。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下面我们开始进行SSM框架的整合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIJK4PAAfFWxl1L9IAALJAQM0wFQAB8Vz309.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb三大框架之Hibernate初识</title>
    <link href="http://yoursite.com/2017/01/01/JavaWeb%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8BHibernate%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2017/01/01/JavaWeb三大框架之Hibernate初识/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.865Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>ORM</strong><br>    <code>ORM (Object / Relationship Mapping)</code> : 对象/关系映射<br>    </p><p>它的好处是使让习惯于面向对象编程的开发人员少写于底层数据库有关的<code>sql</code>语句，方便了程序的维护与修改，及跨平台性。</p><p></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/0A/ChMkJ1bKzzSIOgDcAAj_4khgui4AALJSwDm3zIACP_6935.jpg" alt></p><a id="more"></a><hr><p><strong>Hibernate</strong><br>    <code>Hibernate</code>就是<code>Java</code>中一种成熟的基于<code>ORM</code>的框架</p><hr><p><strong>Hibernate开发的基本步骤</strong></p><ol><li>编写配置文档 <code>hibernate.cfg.xml</code></li><li>编写实体类 (需要遵循<code>JavaBean</code>的设计规范)</li><li>生成对应实体类的映射文件（如 <code>Student</code>类的映射文件<code>Student.hbm.xml</code>)并添加到配置文档<code>hibernate.cfg.xml</code>中 </li><li>调用<code>Hibernate API</code>进行测试</li></ol><hr><p><strong>Session</strong></p><p><code>Hibernate</code>对数据库的操作都需要使用到<code>Session</code>对象，就类似于<code>JDBC</code>开发中的<code>Connection</code>对象。本质上讲<code>Hibernate</code>操作数据库，就是通过调用<code>Session</code>对象的各种函数实现的。</p><p>单表操作的常用方法：<code>save . delete .  update .  get / load</code>对应相应的<code>增删查改</code></p><p>其中查询方法<code>get</code>与<code>load</code>的主要区别在于：<code>get</code>在使用的时候立即发送<code>sql</code>语句，且获得的就是实体类的对象类型。而<code>load</code>是在使用到对象的非主键属性时才会发送sql语句，且它返回的是一个代理对象.</p><pre><code>Writren on 6.April.2016 Rainday</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;ORM&lt;/strong&gt;&lt;br&gt;    &lt;code&gt;ORM (Object / Relationship Mapping)&lt;/code&gt; : 对象/关系映射&lt;br&gt;    &lt;/p&gt;&lt;p&gt;它的好处是使让习惯于面向对象编程的开发人员少写于底层数据库有关的&lt;code&gt;sql&lt;/code&gt;语句，方便了程序的维护与修改，及跨平台性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/0A/ChMkJ1bKzzSIOgDcAAj_4khgui4AALJSwDm3zIACP_6935.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate" scheme="http://yoursite.com/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 笔记</title>
    <link href="http://yoursite.com/2016/12/20/Mysql%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/12/20/Mysql笔记/</id>
    <published>2016-12-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.866Z</updated>
    
    <content type="html"><![CDATA[<h4>外键(foreign key)</h4><p>定义:如果一个实体的某个字段指向另一个实体的主键,这个字段就是这个实体的外键.</p><p>&nbsp;&nbsp;被指向的实体，称之为主实体(主表),也叫父实体(父表).<br>&nbsp;&nbsp;负责指向的实体，称之为从实体(从表),也叫子实体(子表).</p><center><br><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIGD1xAAlbi8UmgHEAALJAQMblhoACVuj729.jpg" alt><br></center> <a id="more"></a><h4>一 : 外键约束</h4><p> MySQL通过外键约束来保证表与表之间的数据的<code>完整性</code>和<code>准确性</code>。</p> <h4>外键使用条件</h4><ul><li><p>两个表必须是InnoDB表，MyISAM表暂时不支持外键（据说以后的版本有可能支持，但至少目前不支持）</p><ul><li><p>外键列必须建立了索引，MySQL 4.1.2以后的版本在建立外键时会自动创建索引，但如果在较早的版本则需要显示建立</p></li><li><p>外键关系的两个表的列必须是数据类型相似，也就是可以相互转换类型的列，比如int和tinyint可以，而int和char则不可以</p></li></ul><p>外键的好处 : 可以使得两张表关联，保证数据的一致性和实现一些级联操作.</p><h4>创建外键语法:</h4><p>  [CONSTRAINT [symbol]] FOREIGN KEY<br>[index_name] (index_col_name, …)<br>REFERENCES tbl_name (index_col_name,…)<br>[ON DELETE reference_option]<br>[ON UPDATE reference_option]</p></li></ul><p>例如:</p><pre><code>&lt;!--Blog表  子表--&gt;   CREATE TABLE `t_blog` (  `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &apos;博客类型&apos;,  `title` VARCHAR(200) NOT NULL COMMENT &apos;博客题目&apos;,  `summary` VARCHAR(400) DEFAULT NULL COMMENT &apos;博客摘要&apos;,  `releaseDate` DATETIME DEFAULT NULL COMMENT &apos;发布日期&apos;,  `clickHit` INT(11) DEFAULT NULL COMMENT &apos;评论次数&apos;,  `replyHit` INT(11) DEFAULT NULL COMMENT &apos;回复次数&apos;,  `content` TEXT COMMENT &apos;博客内容&apos;,  `keyWord` VARCHAR(200) DEFAULT NULL COMMENT &apos;关键字&apos;,  `type_id` INT(11) DEFAULT NULL COMMENT &apos;外键关联博客类别&apos;,  PRIMARY KEY (`id`),  KEY `type_id` (`type_id`),  CONSTRAINT `t_blog_ibfk_1` FOREIGN KEY (`type_id`) REFERENCES `t_blogtype` (`id`)   //创建外键) ENGINE=INNODB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8;&lt;!--BlogType表  父表--&gt;  CREATE TABLE `t_blogtype` (  `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &apos;博客id&apos;,  `typeName` VARCHAR(30) DEFAULT NULL COMMENT &apos;博客类别&apos;,  `orderNum` INT(11) DEFAULT NULL COMMENT &apos;博客排序&apos;,  PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;</code></pre><p><b>注意:</b></p><p>&nbsp;&nbsp;如果子表试图创建一个在父表中不存在的外键值，InnoDB会拒绝任何<code>INSERT</code>或<code>UPDATE</code>操作。如果父表试图<code>UPDATE</code>或者<code>DELETE</code>任何子表中存在或匹配的外键值，最终动作取决于外键约束定义中的<code>ON UPDATE</code>和<code>ON DELETE</code>选项。InnoDB支持5种不同的动作，如果没有指定<code>ON DELETE</code>或者<code>ON UPDATE</code>，默认的动作为<code>RESTRICT</code>:</p><ol><li><p><code>CASCADE</code>:从父表中删除或更新对应的行，同时自动的删除或更新子表中匹配的行。<code>ON DELETE CANSCADE</code>和<code>ON UPDATE CANSCADE</code>都被InnoDB所支持。</p><ol><li><p><code>SET NULL</code>: 从父表中删除或更新对应的行，同时将子表中的外键列设为空。注意，这些在外键列没有被设为NOT NULL时才有效。<code>ON DELETE SET NULL</code>和<code>ON UPDATE SET SET NULL</code>都被InnoDB所支持。</p></li><li><p><code>NO ACTION</code>: InnoDB拒绝删除或者更新父表。</p></li><li><p><code>RESTRICT</code>: 拒绝删除或者更新父表。指定RESTRICT（或者NO ACTION）和忽略<code>ON DELETE</code>或者<code>ON UPDATE</code>选项的效果是一样的。</p></li><li><p><code>SET DEFAULT</code>: InnoDB目前不支持。</p></li></ol><p><b>外键约束使用最多的两种情况：</b></p><ol><li>父表更新时子表也更新，父表删除时如果子表有匹配的项，删除失败.</li></ol></li><li><p>父表更新时子表也更新，父表删除时子表匹配的项也删除。</p><p>前一种情况，在外键定义中，我们使用<code>ON UPDATE CASCADE ON DELETE RESTRICT</code>；</p><p>后一种情况，可以使用<code>ON UPDATE CASCADE ON DELETE CASCADE</code>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;外键(foreign key)&lt;/h4&gt;

&lt;p&gt;定义:如果一个实体的某个字段指向另一个实体的主键,这个字段就是这个实体的外键.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;被指向的实体，称之为主实体(主表),也叫父实体(父表).&lt;br&gt;&amp;nbsp;&amp;nbsp;负责指向的实体，称之为从实体(从表),也叫子实体(子表).&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIGD1xAAlbi8UmgHEAALJAQMblhoACVuj729.jpg&quot; alt&gt;&lt;br&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat绑定域名发布应用</title>
    <link href="http://yoursite.com/2016/10/30/tomcat%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%E5%8F%8A%E5%8F%91%E5%B8%83%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/10/30/tomcat绑定域名及发布应用/</id>
    <published>2016-10-30T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<hr><p><b>我们使用<code>Tomcat</code>发布应用时，默认是绑定在<code>8080</code>端口，这种情况一般在测试后使用。如果应用需要部署到服务器上则需要修改端口为<code>80</code>，并通过域名直接访问。具体如何做呢？<br></b></p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/ChMkJ1cghZGIbfOAAARV4Pwpv4QAAQsDQJ9YssABFX4485.jpg" alt></p><h4 id="打包应用为war"><a href="#打包应用为war" class="headerlink" title="打包应用为war"></a>打包应用为war</h4><p><b>首先打包应用为.war文件，具体步骤为在<code>Myeclipse</code>中点击<code>File-&gt;Export</code>选择<code>web-&gt;war file</code>下一步之后选择要打包的应用，重命名为发布名称，比如<code>test.war</code>确定之后即打包。</b></p><a id="more"></a><p><b>我们把War包传到主机上去，放到Tomcat的webapps下，启动tomcat的startup.bat，会自动解压项目；到了这里，还不够。我们只能通过 <a href="http://外网IP:8080/项目名称访问；" target="_blank" rel="noopener">http://外网IP:8080/项目名称访问；</a> (<a href="http://外网IP:8080/项目名称访问；" target="_blank" rel="noopener">http://外网IP:8080/项目名称访问；</a>)</b></p><p><strong>我们现在要干两个事情，第一个是去掉端口，第二个是去掉项目名称。</strong></p><h4 id="配置容器"><a href="#配置容器" class="headerlink" title="配置容器"></a>配置容器</h4><h4>1.这里是在本地调试时的修改，真正部署可以跳过这段，看下个段落</h4><p>修改tomcat安装目录下的conf下的server.xml</p><blockquote><p>找到Connector节点，将其port改为80后保存，结果如下：</p></blockquote><pre><code>&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;        connectionTimeout=&quot;20000&quot;        redirectPort=&quot;8443&quot; /&gt;</code></pre><blockquote><p>绑定域名</p></blockquote><p>这里博主假设域名是<code>testphoto.com</code><em>(注意域名没有大小写之分，就算是大写也会被浏览器解析成小写)</em> 要绑定的项目时WebPhoto</p><p><b>1.首先因为是在本地访问该域名，所以需要修改Hosts文件，ubuntu系统下修改/<code>etc/hosts</code>加上一条记录</b></p><pre><code>127.0.0.1      testphoto.com</code></pre><p><b>2.之后修改server.xml文件</b></p><p>  找到 Engine节点,在里面添加一个 Host 节点，Engine其中有一个默认的<code>Hostname=&quot;localhost&quot;</code>的Host 节点，增添的Host节点:</p><pre><code>&lt;Host name=&quot;testphoto.com&quot;   appBase=&quot;webapps&quot;      unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;&lt;/Host&gt;</code></pre><p>此时在启动tomcat后，输入绑定的域名<code>testphoto.com</code>就可以看到tomcat了，但是要访问我们的项目，还是要在后面加上项目名称，<br>如<code>testphoto.com/WebPhoto</code></p><p><b>3.绑定项目到域名</b></p><p>  在第二步的基础上，在<host>节点中加入下面的配置</host></p><pre><code>&lt;Context path=&quot;/&quot; docBase=&quot;/opt/tomcat7/webapps/WebPhoto&quot;&gt;&lt;/Context&gt;</code></pre><p>  <code>docBase</code>是你的应用的绝对路径。</p><h4 id="此时通过testphoto-com就可以访问你的页面了"><a href="#此时通过testphoto-com就可以访问你的页面了" class="headerlink" title="此时通过testphoto.com就可以访问你的页面了"></a>此时通过<code>testphoto.com</code>就可以访问你的页面了</h4><p><img src="http://7xta11.com1.z0.glb.clouddn.com/1.png" alt></p><h4>2.真正部署应用到网上的配置</h4><p>  和在本地调试配置步骤一样，只不过这里是在服务器上配置。</p><blockquote><p>修改端口，改成80端口</p></blockquote><pre><code>&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;        connectionTimeout=&quot;20000&quot;        redirectPort=&quot;8443&quot; /&gt;</code></pre><blockquote><p>绑定域名</p></blockquote><pre><code>&lt;Host name=&quot;top.pockerface.cn&quot;  appBase=&quot;webapps&quot;        unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;&lt;Context path=&quot;/&quot; docBase=&quot;/opt/tomcat7/webapps/WebPhoto&quot;&gt;&lt;/Context&gt;&lt;/Host&gt;</code></pre><p><b>这里的<code>top.pockerface.cn</code>是博主的二级域名，需要在DNS解析中，解析域名指向你的服务器。</b></p><h4 id="此时通过top-pockerface-cn就可以访问你的页面了"><a href="#此时通过top-pockerface-cn就可以访问你的页面了" class="headerlink" title="此时通过top.pockerface.cn就可以访问你的页面了"></a>此时通过<code>top.pockerface.cn</code>就可以访问你的页面了</h4><p><img src="http://7xta11.com1.z0.glb.clouddn.com/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;b&gt;我们使用&lt;code&gt;Tomcat&lt;/code&gt;发布应用时，默认是绑定在&lt;code&gt;8080&lt;/code&gt;端口，这种情况一般在测试后使用。如果应用需要部署到服务器上则需要修改端口为&lt;code&gt;80&lt;/code&gt;，并通过域名直接访问。具体如何做呢？&lt;br&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xta11.com1.z0.glb.clouddn.com/ChMkJ1cghZGIbfOAAARV4Pwpv4QAAQsDQJ9YssABFX4485.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;打包应用为war&quot;&gt;&lt;a href=&quot;#打包应用为war&quot; class=&quot;headerlink&quot; title=&quot;打包应用为war&quot;&gt;&lt;/a&gt;打包应用为war&lt;/h4&gt;&lt;p&gt;&lt;b&gt;首先打包应用为.war文件，具体步骤为在&lt;code&gt;Myeclipse&lt;/code&gt;中点击&lt;code&gt;File-&amp;gt;Export&lt;/code&gt;选择&lt;code&gt;web-&amp;gt;war file&lt;/code&gt;下一步之后选择要打包的应用，重命名为发布名称，比如&lt;code&gt;test.war&lt;/code&gt;确定之后即打包。&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>解决Ubuntu下搜狗输入法无法输入中文问题</title>
    <link href="http://yoursite.com/2016/10/20/%E8%A7%A3%E5%86%B3ubuntu%E4%B8%8B%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/10/20/解决ubuntu下搜狗输入法无法输入中文问题/</id>
    <published>2016-10-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<h1>解决ubuntu16.04下搜狗输入法无法输入中文问题</h1><p>今天打开电脑,突然发现一直正常使用的搜狗输入法无法无法输入中文(<b>具体现象是，可以呼出搜狗输入法界面，但是候选词列表无显示</b>).在查阅了别人的博客后解决了这个问题，下面是解决方案.</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/0D/06/ChMkJ1ojqAGISeb1AAexeXbMtcgAAiwQAPGnzMAB7GR200.jpg" alt></p><a id="more"></a><p>我的版本号:</p><ul><li>OS：<code>Ubuntu16.04LST</code></li><li>搜狗版本:<code>sogoupinyin_2.1.0.0082_amd64.deb</code><br><center><br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1490240967&amp;di=a8c79abaa880c6efe8cd7a471576e4b1&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fwww.xiazaizhijia.com%2Fuploads%2Fallimg%2F140217%2F36-14021GAA2615.png" alt></center></li></ul><p></p><p></p><h3>方法一:</h3><br>重启搜狗输入法,看是否有效<p></p><pre><code>~$ killall fcitx~$ killall sogou-qinpanel~$ fcitx</code></pre><p></p><h3>方法二：检查修复安装依赖</h3><br>我本机依赖完好,所以应该不是依赖的问题。但如果刚安装搜狗无法使用,可以尝试下修复依赖.<p></p><pre><code>~$ sudo apt  install -f</code></pre><p></p><h3>方法三:删除配置文件,重启搜狗</h3><br>ubuntu下搜狗配置文件在~/.config下的3个文件夹内:<br>    <code>SogouPY</code>,<code>SogouPY.users</code>、<code>sogou-qimpanel</code><br>    删除这3个文件夹,之后重启.<p></p><p><b>注:我就是用这个方法解决了无法输入中文问题</b></p><p></p><h3>总结</h3><br>Linux下软件经常会因为配置问题而崩溃，最直观的现象就是无法正常使用.因此，如果Linux下正常使用的软件，突然崩溃无法使用，可以尝试删除或修改配置文件的方式尝试解决。<p></p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;解决ubuntu16.04下搜狗输入法无法输入中文问题&lt;/h1&gt;

&lt;p&gt;今天打开电脑,突然发现一直正常使用的搜狗输入法无法无法输入中文(&lt;b&gt;具体现象是，可以呼出搜狗输入法界面，但是候选词列表无显示&lt;/b&gt;).在查阅了别人的博客后解决了这个问题，下面是解决方案.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/0D/06/ChMkJ1ojqAGISeb1AAexeXbMtcgAAiwQAPGnzMAB7GR200.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ngrok神器映射外网</title>
    <link href="http://yoursite.com/2016/09/20/%E7%A5%9E%E5%99%A8Ngrok%E6%98%A0%E5%B0%84%E5%A4%96%E7%BD%91/"/>
    <id>http://yoursite.com/2016/09/20/神器Ngrok映射外网/</id>
    <published>2016-09-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<p><b>ngrok 服务可以分配给你一个域名让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API (比如微信公众号，企业号的开发) </b></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJ1lkKOSIMAebABMY8g_U_F0AAeWIQDF5hoAExkK642.jpg"></p><a id="more"></a><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ul><li>下载linux版本的客户端，解压到你喜欢的目录,注意：要给ngrok文件的可执行权限<a href="http://pan.baidu.com/s/1jG4fEGu" target="_blank" rel="noopener">Ubuntu 64 位下载地址</a></li></ul><ul><li>在命令行下进入到<code>path/to/linux_amd64/</code>下</li><li>执行 <code>./ngrok -config=ngrok.cfg -subdomain xxx 8080</code> //(<code>xxx</code> 是你自定义的域名前缀，<code>8080</code>是你本机服务器对应的端口，由于我用的是<code>Apache Tomcat 7</code>所以端口是<code>8080</code>)</li><li>如果开启成功 你就可以使用 <code>xxx.tunnel.qydev.com</code> 来访问你本机的 <code>127.0.0.1:80</code> 的服务啦</li><li>如果你自己有顶级域名，想通过自己的域名来访问本机的项目，那么先将自己的顶级域名解析到<code>123.57.165.240</code> (域名需要已备案哦),然后执行<code>./ngrok -config=ngrok.cfg -hostname xxx.xxx.xxx 8080</code> //(xxx.xxx.xxx是你自定义的顶级域名)</li><li>如果开启成功 你就可以使用你的顶级域名来访问你本机的 <code>127.0.0.1:8080</code> 的服务啦</li></ul><p><b>参考文献:<a href="http://qydev.com/#" target="_blank" rel="noopener">http://qydev.com/#</a></b></p><pre><code>Writen on 11.Apri.2016</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;ngrok 服务可以分配给你一个域名让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API (比如微信公众号，企业号的开发) &lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJ1lkKOSIMAebABMY8g_U_F0AAeWIQDF5hoAExkK642.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ngrok" scheme="http://yoursite.com/tags/Ngrok/"/>
    
  </entry>
  
  <entry>
    <title>Git使用ssh密钥</title>
    <link href="http://yoursite.com/2016/09/13/Git%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5/"/>
    <id>http://yoursite.com/2016/09/13/Git使用ssh密钥/</id>
    <published>2016-09-13T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJllkKMeIJ6CSAAdGdB9XHNIAAeWIAJf87AAB0aM436.jpg" alt></p><a id="more"></a><hr><p><b><br>git使用https协议，每次pull, push都要输入密码，相当的烦。<br>使用git协议，然后使用ssh密钥。这样可以省去每次都输密码。<br></b></p><hr><p>大概需要三个步骤：</p><ol><li>本地生成密钥对；</li><li>设置github上的公钥；</li><li>修改git的remote url为git协议。</li></ol><hr><h2 id="详细讲解第3部分"><a href="#详细讲解第3部分" class="headerlink" title="详细讲解第3部分"></a>详细讲解第3部分</h2><p>修改你本地的ssh remote url. 不用https协议，改用git 协议</p><p>可以用<code>git remote -v</code>查看你当前的<code>remote url</code></p><pre><code>$ git remote -vorigin    https://github.com/Helloxyw/Helloxyw.github.io.git (fetch)origin    https://github.com/Helloxyw/Helloxyw.github.io.git (push)</code></pre><p>可以看到是使用https协议进行访问的。</p><p>你可以使用浏览器登陆你的github，在上面可以看到你的ssh协议相应的url。类似如下：</p><pre><code>git@github.com:someaccount/someproject.git</code></pre><p>这时，你可以使用<code>git remote set-url</code> 来调整你的<code>url</code>。</p><pre><code>git remote set-url origin git@github.com:someaccount/someproject.git</code></pre><p>完了之后，你便可以再用<code>git remote -v</code> 查看一下。<br>    $ git remote -v<br>    origin    git@github.com:Helloxyw/Helloxyw.github.io.git (fetch)<br>    origin    git@github.com:Helloxyw/Helloxyw.github.io.git (push)</p><p> 至此，OK。</p><p>你可以用<code>git fetch, git pull , git push</code>， 现在进行远程操作，应该就不需要输入密码那么烦了。</p><pre><code>Writhen On 18-Apr-2016 By Ricardo Xu</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJllkKMeIJ6CSAAdGdB9XHNIAAeWIAJf87AAB0aM436.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>高并发秒杀项目</title>
    <link href="http://yoursite.com/2016/04/20/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2016/04/20/高并发秒杀项目/</id>
    <published>2016-04-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-springmvc-Mybatis"><a href="#spring-springmvc-Mybatis" class="headerlink" title="spring-springmvc-Mybatis"></a>spring-springmvc-Mybatis</h1><h3>SSM整合实现Java高并发秒杀</h3><p><strong> 选择使用<code>springmvc</code> + <code>spring</code> +<code>mybatis</code>三大框架原因是:</strong></p><ul><li>轻量</li><li>易使用</li></ul><p><strong>主要使用到的技术：</strong></p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/mybatis-spring.png" alt></p><a id="more"></a><h4>Mysql</h4><ul><li>表设计</li><li>SQL技巧</li><li>事务和行级锁</li></ul><h4>MyBatis</h4><ul><li>DAO层设计开发</li><li>MyBatis全程使用</li><li>MyBatis与Spring整合</li><li>推荐XML配置Sql</li></ul><h4>Spring</h4><ul><li>IOC整合Service</li><li>声明式事务运用</li></ul><p></p><h4>Spring MVC</h4><p></p><ul><li>Restful接口设计使用</li><li>框架运作流程</li><li>Controller开发技巧</li></ul><p></p><h4>前端</h4><p></p><ul><li>交互设计</li><li>Bootstrap</li><li>jQuery</li></ul><h3 id="所用到的包的依赖-pom-xml文件"><a href="#所用到的包的依赖-pom-xml文件" class="headerlink" title="所用到的包的依赖(pom.xml文件)"></a>所用到的包的依赖(pom.xml文件)</h3><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.seckill&lt;/groupId&gt;    &lt;artifactId&gt;seckill&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;name&gt;seckill Maven Webapp&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;dependencies&gt;        &lt;!-- 补全项目依赖 --&gt;        &lt;!-- 使用junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.11&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- 1:日志 java日志： slf4j,log4j,logback,common-logging slf4j是规范/接口 日志实现：log4j,logback,common-logging            使用:slf4j + logback --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;1.7.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-core&lt;/artifactId&gt;            &lt;version&gt;1.1.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;1.1.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 数据库相关依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.35&lt;/version&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;c3p0&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- DAO框架：Mybatis依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.2.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Servlet web 依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;taglibs&lt;/groupId&gt;            &lt;artifactId&gt;standard&lt;/artifactId&gt;            &lt;version&gt;1.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jstl&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;            &lt;version&gt;2.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;            &lt;version&gt;2.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Spring 依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Spring dao层依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Spring web依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;4.2.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc-portlet&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring test依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;4.2.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- redis客户端:Jedis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;redis.clients&lt;/groupId&gt;            &lt;artifactId&gt;jedis&lt;/artifactId&gt;            &lt;version&gt;2.7.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- protostuff序列化依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;            &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt;            &lt;version&gt;1.0.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;            &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;            &lt;version&gt;1.0.8&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;seckill&lt;/finalName&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spring-springmvc-Mybatis&quot;&gt;&lt;a href=&quot;#spring-springmvc-Mybatis&quot; class=&quot;headerlink&quot; title=&quot;spring-springmvc-Mybatis&quot;&gt;&lt;/a&gt;spring-springmvc-Mybatis&lt;/h1&gt;&lt;h3&gt;SSM整合实现Java高并发秒杀&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt; 选择使用&lt;code&gt;springmvc&lt;/code&gt; + &lt;code&gt;spring&lt;/code&gt; +&lt;code&gt;mybatis&lt;/code&gt;三大框架原因是:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轻量&lt;/li&gt;
&lt;li&gt;易使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;主要使用到的技术：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xta11.com1.z0.glb.clouddn.com/mybatis-spring.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下安装java</title>
    <link href="http://yoursite.com/2015/09/20/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85jdk%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/09/20/Ubuntu下安装jdk两种方式/</id>
    <published>2015-09-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.867Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-通过ppa-源-方式安装"><a href="#1-通过ppa-源-方式安装" class="headerlink" title="1.通过ppa(源) 方式安装."></a>1.通过ppa(源) 方式安装.</h3><p><b>这里推荐第1种,因为可以通过 <code>apt-get upgrade</code> 方式方便获得jdk的升级</b></p><h4>在我们继续了解如何安装Java之前，让我们快速地了解<code>JRE、OpenJDK</code>和<code>Oracle JDK</code>之间的不同之处。</h4><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/04/ChMkJlpZZLeIGFB8AATf7vf_nYQAAkD4wFg_xEABOAG369.jpg"><br><a id="more"></a></p><h4><code>JRE（Java Runtime Environment）</code>，它是你运行一个基于Java语言应用程序的所正常需要的环境。如果你不是一个程序员的话，这些足够你的需要。</h4><h4>JDK代表Java开发工具包，如果你想做一些有关Java的开发（阅读程序），这正是你所需要的。</h4><h4>OpenJDK是Java开发工具包的开源实现，Oracle JDK是Java开发工具包的官方Oracle版本。尽管OpenJDK已经足够满足大多数的案例，但是许多程序比如Android Studio建议使用Oracle JDK，以避免UI/性能问题。</h4><h3 id="检查Java是否已经安装在Ubuntu上"><a href="#检查Java是否已经安装在Ubuntu上" class="headerlink" title="检查Java是否已经安装在Ubuntu上"></a>检查Java是否已经安装在Ubuntu上</h3><p><strong>打开终端输入命令：</strong></p><pre><code>java -version</code></pre><p><strong>如果有看到类似以下的输出，则表明你的电脑上已经安装好了JDK，否则就是没有安装：</strong></p><pre><code>java version &quot;1.8.0_73&quot;Java(TM) SE Runtime Environment (build 1.8.0_73-b02)Java HotSpot(TM) 64-Bit Server VM (build 25.73-b02, mixed mode)</code></pre><p><strong>安装Oracle JDK</strong></p><pre><code>sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installer</code></pre><p><strong>    设置 Java 8 环境变量：</strong></p><pre><code>sudo apt-get install oracle-java8-set-default</code></pre><p><strong>此时打开配置文件</strong></p><pre><code>sudo gedit ~/.bashrc</code></pre><p><strong>在打开的文本编辑器末尾换行添加如下内容：(部分内容在安装时可能已经自动配置好了)</strong></p><pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-oracleexport JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH</code></pre><p><strong>右上角保存后，在终端输入 <code>java -version</code> 或 <code>java</code> 或者<code>javac</code>回车，如果显示了版本信息或者一些帮助信息，则表示配置成功</strong></p><h3 id="2-通过官网下载安装包安装"><a href="#2-通过官网下载安装包安装" class="headerlink" title="2:通过官网下载安装包安装."></a>2:通过官网下载安装包安装.</h3><h4 id="首先去官网下载最新的jdk-8u92-linux-x64-tar-gz"><a href="#首先去官网下载最新的jdk-8u92-linux-x64-tar-gz" class="headerlink" title="首先去官网下载最新的jdk-8u92-linux-x64.tar.gz"></a>首先去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">官网</a>下载最新的<code>jdk-8u92-linux-x64.tar.gz</code></h4><h4 id="打开终端创建Java目标路径文件"><a href="#打开终端创建Java目标路径文件" class="headerlink" title="打开终端创建Java目标路径文件"></a>打开终端创建Java目标路径文件</h4><pre><code>sudo mkdir /usr/lib/jvm</code></pre><h4 id="解压jdk文件到目标文件下"><a href="#解压jdk文件到目标文件下" class="headerlink" title="解压jdk文件到目标文件下"></a>解压jdk文件到目标文件下</h4><pre><code>sudo tar -C /usr/lib/jvm -xzf (你下载的路径)/jdk-8u92-linux-x64.tar.gz</code></pre><h4 id="查看本机上是否还有java可选"><a href="#查看本机上是否还有java可选" class="headerlink" title="查看本机上是否还有java可选"></a>查看本机上是否还有java可选</h4><pre><code>sudo update-alternatives --list java</code></pre><h4 id="若显示-update-alternatives-错误-无-java-的候选项-则表示系统中没有java可选，可以进行以下步骤"><a href="#若显示-update-alternatives-错误-无-java-的候选项-则表示系统中没有java可选，可以进行以下步骤" class="headerlink" title="若显示   update-alternatives: 错误: 无 java 的候选项  则表示系统中没有java可选，可以进行以下步骤"></a>若显示   <code>update-alternatives: 错误: 无 java 的候选项</code>  则表示系统中没有java可选，可以进行以下步骤</h4><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><pre><code>sudo gedit ~/.bashrc</code></pre><h4 id="在打开的文本编辑器末尾换行添加如下内容："><a href="#在打开的文本编辑器末尾换行添加如下内容：" class="headerlink" title="在打开的文本编辑器末尾换行添加如下内容："></a>在打开的文本编辑器末尾换行添加如下内容：</h4><pre><code>export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_92   export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH</code></pre><p><strong>右上角保存后，在终端输入 <code>java -version</code> 或 <code>java</code> 或者<code>javac</code>回车，如果显示了版本信息或者一些帮助信息，则表示配置成功</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-通过ppa-源-方式安装&quot;&gt;&lt;a href=&quot;#1-通过ppa-源-方式安装&quot; class=&quot;headerlink&quot; title=&quot;1.通过ppa(源) 方式安装.&quot;&gt;&lt;/a&gt;1.通过ppa(源) 方式安装.&lt;/h3&gt;&lt;p&gt;&lt;b&gt;这里推荐第1种,因为可以通过 &lt;code&gt;apt-get upgrade&lt;/code&gt; 方式方便获得jdk的升级&lt;/b&gt;&lt;/p&gt;
&lt;h4&gt;在我们继续了解如何安装Java之前，让我们快速地了解&lt;code&gt;JRE、OpenJDK&lt;/code&gt;和&lt;code&gt;Oracle JDK&lt;/code&gt;之间的不同之处。&lt;/h4&gt;



&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/04/ChMkJlpZZLeIGFB8AATf7vf_nYQAAkD4wFg_xEABOAG369.jpg&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
