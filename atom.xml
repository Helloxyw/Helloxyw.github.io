<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RicardoXu博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-16T15:28:16.615Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>RicardoXu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java秒杀系统方案优化 高性能高并发实战</title>
    <link href="http://yoursite.com/2019/06/16/Java%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/06/16/Java秒杀系统方案优化/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-16T15:28:16.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIBt6YAAvmGfwhdgwAALGfwFf6LcAC-Yx733.jpg" alt></p><h2><br>  项目安排<br></h2><h3>1.项目搭建</h3><ul><li><code>SpringBoot</code> 环境搭建</li><li>集成<code>Thymeleaf</code>,<code>Result</code>结果封装</li><li>集成<code>Mybatis</code> + <code>Druid</code></li><li>集成<code>Jedis</code> +<code>Redis</code>安装 + 通用缓存<code>Key</code>封装</li></ul><a id="more"></a><h3>2.实现登录功能</h3><ul><li>数据库设计</li><li>明文密码两次<code>MD5</code>处理</li><li><code>JSR303</code>参数校验 + 全局异常处理器</li><li>分布式<code>Session</code></li></ul><h3>3.实现秒杀功能</h3><ul><li>数据库设计</li><li>商品列表页</li><li>商品详情页</li><li>订单详情页 </li></ul><h4>4.JMeter压测</h4><ul><li><code>JMeter</code>入门</li><li>自定义多变量模拟多用户</li><li><code>JMeter</code>命令行使用</li><li><code>SpringBoot</code>打<code>War</code>包</li></ul><h3>5.页面优化技术</h3><ul><li>页面缓存 + <code>URL</code>缓存 + 对象缓存</li><li>页面静态化 ，前后端分离</li><li>静态资源优化</li><li><code>CDN</code>优化</li></ul><h3>6.接口优化</h3><ul><li><code>Redis</code>预减库存减少数据库访问</li><li>内存标记减少<code>Redis</code>访问</li><li><code>RabbitMQ</code>队列缓冲，异步下单，增强用户体验</li><li><code>RabbitMQ</code>安装与<code>SpringBoot</code>集成</li><li>访问<code>Nginx</code>水平扩展</li><li>分库分表（<code>Mycat</code>)</li><li>压测</li></ul><h3>7.安全优化</h3><ul><li>秒杀接口地址隐藏</li><li>数学公式验证码</li><li>接口防刷</li></ul><hr><h2>1.项目搭建</h2><h3>集成Redis中的问题和笔记</h3><h4>1.Spring注入</h4><p><code>Spring</code>通过<code>DI</code>（依赖注入）实现<code>IOC</code>（控制反转)，常用的注入方式主要有以下三种:</p><ul><li>构造方法注入</li><li><code>setter</code>方法注入</li><li>基于注解的注入</li></ul><h4>构造方法注入</h4><p>在spring的配置文件中注册UserService，将UserDaoJdbc通过constructor-arg标签注入到UserService的<strong>某个</strong>有参数的构造方法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册userService --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.lyu.spring.service.impl.UserService"</span>&gt;</span><br><span class="line">&lt;constructor-arg ref="userDaoJdbc"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册jdbc实现的dao --&gt;</span><br><span class="line">&lt;bean id="userDaoJdbc" class="com.lyu.spring.dao.impl.UserDaoJdbc"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>如果只有一个有参数的构造方法并且参数类型与注入的bean的类型匹配，那就会注入到该构造方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(IUserDao userDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDao.loginUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">// 获取bean对象</span></span><br><span class="line">UserService userService = ac.getBean(UserService.class, <span class="string">"userService"</span>);</span><br><span class="line"><span class="comment">// 模拟用户登录</span></span><br><span class="line">userService.loginUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><h4>setter注入</h4><p>配置文件如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册userService --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.lyu.spring.service.impl.UserService"</span>&gt;</span><br><span class="line">&lt;!-- 写法一 --&gt;</span><br><span class="line">&lt;!-- &lt;property name="UserDao" ref="userDaoMyBatis"&gt;&lt;/property&gt; --&gt;</span><br><span class="line">&lt;!-- 写法二 --&gt;</span><br><span class="line">&lt;property name="userDao" ref="userDaoMyBatis"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册mybatis实现的dao --&gt;</span><br><span class="line">&lt;bean id="userDaoMyBatis" class="com.lyu.spring.dao.impl.UserDaoMyBatis"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>注：上面这两种写法都可以,spring会将name值的每个单词首字母转换成大写，然后再在前面拼接上”set”构成一个方法名,然后去对应的类中查找该方法,通过反射调用,实现注入。</strong></p><p><em>切记：name属性值与类中的成员变量名以及set方法的参数名都无关，只与对应的set方法名有关，下面的这种写法是可以运行成功的</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IUserDao userDao1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(IUserDao userDao1)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao1 = userDao1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDao1.loginUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>还有一点需要注意：如果通过set方法注入属性，那么spring会通过默认的空参构造方法来实例化对象，所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上，否则spring没有办法实例化对象，导致报错。</strong></p><h4>基于注解的注入</h4><p>在介绍注解注入的方式前，先简单了解<code>bean</code>的一个属性<code>autowire</code>，<code>autowire</code>主要有三个属性值：<code>constructor</code>，<code>byName</code>，<code>byType</code>。</p><ul><li><p><code>constructor</code>：通过构造方法进行自动注入，<code>spring</code>会匹配与构造方法参数类型一致的<code>bean</code>进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的<code>bean</code>，那么<code>spring</code>会优先将<code>bean</code>注入到多参数的构造方法中。</p></li><li><p><code>byName</code>：被注入<code>bean</code>的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。</p></li><li><p><code>byType</code>：查找所有的set方法，将符合符合参数类型的bean注入。</p></li></ul><hr><p>主要有四种注解可以注册bean，每种注解可以任意使用，只是语义上有所差异：</p><ul><li><code>@Component</code>：可以用于注册所有bean</li><li><code>@Repository</code>：主要用于注册dao层的bean</li><li><code>@Controller</code>：主要用于注册控制层的bean</li><li><code>@Service</code>：主要用于注册服务层的bean</li></ul><p>描述依赖关系主要有两种：</p><ul><li><code>@Resource</code>：java的注解，默认以byName的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（spring注解）指定某个具体名称的bean。</li><li><code>@Autowired</code>：spring注解，<strong>默认是以byType的方式去匹配类型相同的bean</strong>，如果只匹配到一个，那么就直接注入该bean，无论要注入的 bean 的 name 是什么；如果匹配到多个，就会调用就会调用 <strong><code>DefaultListableBeanFactory</code></strong> 的 <strong><code>determineAutowireCandidate</code></strong> 方法来决定具体注入哪个bean</li></ul><blockquote><p>determineAutowireCandidate 方法的逻辑是：</p><ol><li>先找 Bean 上有@Primary 注解的，有则直接返回 bean 的 name。</li><li>再找 Bean 上有 @Order，@PriorityOrder 注解的，有则返回 bean 的 name。</li><li>最后再以名称匹配（ByName）的方式去查找相匹配的 bean</li></ol></blockquote><p>虽然有这么多的注入方式，但是实际上开发的时候自己编写的类一般用注解的方式注册类，用@Autowired描述依赖进行注入，一般实现类也只有一种（jdbc or hibernate or mybatis），除非项目有大的变动，所以@Qualifier标签用的也较少；但是在使用其他组件的API的时候用的是通过xml配置文件来注册类，描述依赖，因为你不能去改人家源码嘛。</p><h4>2.</h4><p><a href="https://postimg.cc/tYCsYJ80" target="_blank" rel="noopener"><img src="https://i.postimg.cc/Pr1YV84q/WX20190519-182215-2x.png" alt="WX20190519-182215-2x.png"></a></p><h3>2.实现登录</h3><h4>1.两次MD5</h4><ol><li>用户端：PASS = MD5（明文 + 固定Salt)</li><li>服务端：PASS = MD5（用户输入 + 随机Salt）</li></ol><h4>2.数据库三大范式</h4><ul><li>1NF：要求有主键，并且要求每一个字段原子性不可再分</li></ul><blockquote><p>1NF是对属性的<strong>原子性</strong>，要求属性具有原子性，不可再分解；</p><p>表：字段1、 字段2(字段2.1、字段2.2)、字段3 ……</p><p>如学生（学号，姓名，性别，出生年月日），如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不是一范式了，否则就是。</p></blockquote><ul><li>2NF：要求所有非主键字段完全依赖主键，不能产生部分依赖</li></ul><blockquote><p>2NF是对记录的<strong>惟一性</strong>，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；</p><p>表：学号、课程号、姓名、学分;</p><p>这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里<strong>学分依赖课程号</strong>，<strong>姓名依赖与学号</strong>，所以不符合二范式。</p><p><strong>可能会存在问题：</strong></p><ul><li><code>数据冗余:</code>，每条记录都含有相同信息；</li><li><code>删除异常：</code>删除所有学生成绩，就把课程信息全删除了；</li><li><code>插入异常：</code>学生未选课，无法记录进数据库；</li><li><code>更新异常：</code>调整课程学分，所有行都调整。</li></ul><p><strong>正确做法:</strong><br>学生：<code>Student</code>(学号, 姓名)；<br>课程：<code>Course</code>(课程号, 学分)；<br>选课关系：<code>StudentCourse</code>(学号, 课程号, 成绩)。</p></blockquote><ul><li>3NF：所有非主键字段和主键字段之间不能传递依赖</li></ul><blockquote><p>3NF是对字段的<strong>冗余性</strong>，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</p><p>表: 学号, 姓名, 年龄, 学院名称, 学院电话</p><p>因为存在<strong>依赖传递</strong>: (学号) → (学生)→(所在学院) → (学院电话) 。</p><p><strong>可能会存在问题：</strong></p><ul><li><code>数据冗余:</code>有重复值；</li><li><code>更新异常：</code>有重复的冗余信息，修改时需要同时修改多条记录，否则会出现<strong>数据不一致的情况</strong> 。</li></ul><p><strong>正确做法：</strong></p><p>学生：(学号, 姓名, 年龄, 所在学院)；</p><p>学院：(学院, 电话)。</p></blockquote><h4>反范式</h4><p><strong>一般说来，数据库只需满足第三范式（3NF）就行了。</strong></p><blockquote><p>没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余，<strong>达到以空间换时间的目的</strong>。</p><p>〖例〗：有一张存放商品的基本表，如表1所示。“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以<strong>提高查询统计的速度</strong>，这就是以<strong>空间换时间</strong>的作法。</p></blockquote><h4>范式化设计和反范式化设计的优缺点</h4><p><strong>范式化</strong></p><p><strong>优点</strong></p><ul><li>可以尽可能的减少数据冗余</li><li>数据表更新快，体积小</li></ul><p><strong>缺点</strong></p><ul><li>对于查询需要对多个表进行关联，导致性能低</li><li>更难进行索引优化</li></ul><p><strong>反范式化</strong></p><p><strong>优点</strong></p><ul><li>可以减少表的关联</li><li>可以更好进行索引优化</li></ul><p><strong>缺点</strong></p><ul><li>存在数据冗余及数据维护异常</li><li>对数据的修改需要更多的成本</li></ul><h3>五、页面优化</h3><h4>页面缓存</h4><ol><li>取缓存</li><li>手动渲染模板</li><li>结果输出</li></ol><h4>静态资源优化</h4><ol><li>JS/CSS压缩，减少流量</li><li>多个JS/CSS组合，减少连接数</li><li>CDN就近访问</li></ol><h3>六、秒杀接口优化</h3><p><strong>思路：减少数据库访问 </strong></p><ol><li>系统初始化，把商品库存数量加载到Redis</li><li>收到请求，Redis预减库存，库存不足，直接返回，否则进入3</li><li>请求入队，立即返回排队中</li><li>请求出队，生成订单，减少库存</li><li>客户端轮询，是否秒杀成功</li></ol><p><strong>1.<code>SpringBoot</code>集成<code>RabbitMQ</code></strong></p><ol><li>添加依赖<code>spring-boot-starter-amqp</code></li><li>创建消息接受者</li><li>创建消息发送者</li></ol><h3>7.安全优化</h3><ul><li>秒杀接口地址隐藏</li><li>数学公式验证码</li><li>接口防刷</li></ul><p><strong>1.秒杀接口地址隐藏</strong></p><p><strong>思路：秒杀开始之前，先去请求接口获取秒杀地址</strong></p><ol><li>接口改造，带上PathVariable参数</li><li>添加生成地址的接口</li><li>秒杀收到请求，先验证PathVariable</li></ol><p><strong>2.数学公式验证码</strong></p><p><strong>思路：点击秒杀之前，先输入验证码，分散用户的请求</strong></p><ol><li>添加生成验证码的接口</li><li>在获取秒杀路径的时候，验证验证码</li><li>ScriptEngine使用 </li></ol><p><strong>3.接口限流</strong></p><p>把用户访问次数写入缓存，并加上有效时间。（可以用拦截器减少对业务代码的侵入）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIBt6YAAvmGfwhdgwAALGfwFf6LcAC-Yx733.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2&gt;&lt;br&gt;  项目安排&lt;br&gt;&lt;/h2&gt;

&lt;h3&gt;1.项目搭建&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SpringBoot&lt;/code&gt; 环境搭建&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Thymeleaf&lt;/code&gt;,&lt;code&gt;Result&lt;/code&gt;结果封装&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Mybatis&lt;/code&gt; + &lt;code&gt;Druid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Jedis&lt;/code&gt; +&lt;code&gt;Redis&lt;/code&gt;安装 + 通用缓存&lt;code&gt;Key&lt;/code&gt;封装&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="秒杀" scheme="http://yoursite.com/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>并发编程与高并发入门</title>
    <link href="http://yoursite.com/2019/06/11/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/06/11/并发编程入门与高并发笔记/</id>
    <published>2019-06-11T09:15:53.000Z</published>
    <updated>2019-06-26T14:11:25.715Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://996.icu" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/link-996.icu-red.svg"></a></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIFY_6AA3VjT9w7FMAALGfwFCj8AADdWl862.jpg" alt></p><h3>4.线程安全性</h3><p>定义：当多个线程访问某个类时，不管运行时环境采用<b>何种调度方式</b>或者这些进程将如何交替执行，并且在主调代码中<b>不需要任何额外的同步或协同</b>，这个类都能表现出<b>正确的行为</b>，那么就称这个类是线程安全的。</p><ul><li>原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。</li><li>可见性：一个线程对主内存的修改可以及时的被其他线程观察到。</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。</li></ul><a id="more"></a><p><b>原子性——Atomic包</b></p><ul><li>AtomicXXX：CAS、Unsafe.compareAndSwapInt</li><li>AtomicLong、LongAdder</li><li>AtomicReference、AtomicReferenceFieldUpdater</li><li>AtomicStampReference：CAS的ABA问题</li></ul><p><b>原子性——锁</b></p><ul><li>synchronized：依赖JVM</li><li>Lock：依赖特殊的CPU指令，代码实现，ReentrantLock</li></ul><p><b>原子性——synchronize</b></p><ul><li>修饰代码块：大括号括起来的代码，作用于<b>调用对象</b></li><li>修饰方法：整个方法，作用于<b>调用的对象</b></li><li>修饰静态方法：整个静态方法，作用于这个<b>类的所有对象</b></li><li>修饰类：括号括起来的部分，作用于这个<b>类的所有对象</b></li></ul><p><b>原子性——对比</b></p><ul><li>Synchronized：不可中断锁，适合竞争不激烈，可读性好</li><li>Lock：可中断锁，多样化同步，竞争激烈时能维持常态</li><li>Atomic：竞争激烈时能维持常态，比Lock性能好；只能同步一个值</li></ul><p><b>可见性</b></p><ul><li>线程交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存及主存空间及时更新</li></ul><p><b>可见性</b></p><p><b>JMM(Java Memory Model) 关于synchorized 的两条规定:</b></p><ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读区最新的值（注意，加锁与解锁是同一把锁)</li></ul><p><b>可见性——volatile</b></p><p>通过加入<b>内存屏障</b>和<b>禁止重排序</b>优化来实现</p><ul><li>对volatile变量写操作时，会在写操作后加入一条store 屏障指令，将本地内存中的共享变量值刷新到主内存</li><li>对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量</li></ul><p><b>可见性——volatile使用（适合作为状态标识量）</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">context = loadContext();</span><br><span class="line">inited = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="keyword">while</span>(!inited)&#123;</span><br><span class="line">  sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure><p><b>有序性</b></p><ul><li>java内存模型中，允许编译器和处理器对指令进行<b>重排序</b>，但是重排序过程不会影响到<b>单线程</b>程序的执行，却会影响到多线程并发执行的正确性</li><li>volatile、synchronized、Lock</li></ul><p><b>有序性-happens-before原则</b></p><p><b>较重要的原则</b></p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定原则：一个unLock操作先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li></ul><p><b>显而易见的原则</b></p><ul><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作</li><li>线程中断规则：对线程的interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><h3>线程安全性——总结</h3><ul><li>原子性：Atomic包、CAS算法、synchronized、Lock</li><li>可见性：synchronized、volatile</li><li>有序性：happens-before</li></ul><h3>13.高并发解决思路之消息队列</h3><p><strong>特性</strong></p><ul><li>业务无关：只做消息分发</li><li>FIFO：先投递先到达</li><li>容灾：节点的动态增删和消息的持久化</li><li>性能：吞吐量提升，系统内部通信效率提高</li></ul><p><strong>为什么需要消息队列</strong></p><blockquote><p>【生产】和【消费】的速度或稳定性等因素不一致</p></blockquote><p><strong>消息队列好处</strong></p><ul><li>业务解耦</li><li>最终一致性</li><li>广播</li><li>错峰与流控</li></ul><p><strong>消息队列举例</strong></p><ul><li>Kafka</li></ul><p><a href="https://postimg.cc/TpHcT5dg" target="_blank" rel="noopener"><img src="https://i.postimg.cc/mgTpN7KX/WX20190515-221556-2x.png" alt="WX20190515-221556-2x.png"></a></p><ul><li>RabbitMQ</li></ul><p><a href="https://postimg.cc/yggHrZ8j" target="_blank" rel="noopener"><img src="https://i.postimg.cc/KzQ8j7X6/WX20190515-221940-2x.png" alt="WX20190515-221940-2x.png"></a></p><h3>14.高并发解决思路之应用拆分</h3><p><a href="https://postimg.cc/GB5Msxn0" target="_blank" rel="noopener"><img src="https://i.postimg.cc/50xDTsPt/WX20190626-220947-2x.png" alt="WX20190626-220947-2x.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://996.icu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/link-996.icu-red.svg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/01/0E/ChMkJlbKweiIFY_6AA3VjT9w7FMAALGfwFCj8AADdWl862.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3&gt;4.线程安全性&lt;/h3&gt;

&lt;p&gt;定义：当多个线程访问某个类时，不管运行时环境采用&lt;b&gt;何种调度方式&lt;/b&gt;或者这些进程将如何交替执行，并且在主调代码中&lt;b&gt;不需要任何额外的同步或协同&lt;/b&gt;，这个类都能表现出&lt;b&gt;正确的行为&lt;/b&gt;，那么就称这个类是线程安全的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。&lt;/li&gt;
&lt;li&gt;可见性：一个线程对主内存的修改可以及时的被其他线程观察到。&lt;/li&gt;
&lt;li&gt;有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="高并发" scheme="http://yoursite.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://yoursite.com/2019/05/15/%E5%89%91%E6%8C%87Offer/"/>
    <id>http://yoursite.com/2019/05/15/剑指Offer/</id>
    <published>2019-05-15T13:15:53.000Z</published>
    <updated>2019-06-26T14:00:02.055Z</updated>
    
    <content type="html"><![CDATA[<p><img src="data:image/png;base64,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" alt></p><h3>4.Redis</h3><ul><li>数据类型丰富</li><li>支持数据磁盘持久化存储</li><li>支持主从</li><li>支持分片</li></ul><p><img src="https://i.postimg.cc/sfnpFq6R/redis.png" alt></p><a id="more"></a><h3>为什么Redis能这么快</h3><h4>支持10000+QPS（query per second,每秒内查询次数）</h4><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高</li><li>数据结构简单，对数据操作也简单</li><li>主线程采用单线程，单线程也能处理高并发请求，想多核也可启动多实例</li></ul><h3>供用户使用的数据类型</h3><ul><li><p>String : 最基本的数据类型，二进制安全</p></li><li><p>Hash: String 元素组成的字典，适合用于存储对象</p></li><li><p>List: 列表，按照String元素插入排序</p></li><li><p>Set: String元素组成的无序集合，通过哈希表实现，不允许重复</p></li><li><p>Sorted Set : 通过分数来为集合中的成员进行从小到大的排序</p></li><li><p>用于计数的HyperLongLong，用于支持存储地理位置信息的Geo</p></li></ul><h3>问题1：从海量key里查询出某一固定前缀的key</h3><p><b>留意细节</b></p><ul><li>摸清数据规模，即问清边界</li></ul><ol><li><p>方案1:<code>KEYS pattern</code>: 查找所有符合给定模式pattern的key</p><p>存在的问题：</p><ul><li>KEYS指令一次性返回所有匹配的key</li><li>键的数量过大会使服务卡顿</li></ul></li><li><p>方案2:<code>SCAN cursor [MATCH pattern][COUNT count]</code></p><ul><li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程</li><li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历</li><li>不保证每次执行都返回某个给定数量的元素，支持模糊查询</li><li>一次返回的数量不可控，只能是大概率符合count参数</li></ul></li></ol><h3>问题2：如何通过Redis实现分布式锁</h3><blockquote><p>分布式锁：是用来控制分布式系统中互斥访问共享资源的一种手段，从而避免并行导致的结果不可控。基本的实现原理和单进程锁是一致的，通过一个共享标识来确定唯一性，对共享标识进行修改时能保证原子性和对锁服务调用方的可见性。</p><p>分布式锁一般要能保证：</p><ul><li>同一时刻只能有一个线程持有锁</li><li>锁能够可重入</li><li>不会发生死锁</li><li>具备阻塞锁特性，且能够及时从阻塞状态唤醒</li><li>锁服务保证高性能和高可用</li></ul></blockquote><p><strong>分布式锁需要解决的问题</strong></p><ul><li>互斥性</li><li>安全性</li><li>死锁</li><li>容错</li></ul><h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><p><code>SETNX key value</code>：如果key不存在，则创建并赋值</p><ul><li>时间复杂度<code>O(1)</code></li><li>返回值：设置成功，返回1；设置失败，返回0</li></ul><p><strong>其中需要解决SETNX长期有效问题</strong></p><p><code>EXPIRE key seconds</code></p><ul><li>设置key的生存时间，当key过期时（生命时间为0），会被自动删除</li></ul><p><strong>该方案一的伪代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RedisService redisService = SpringUtils.getBean(RedisService.class);</span><br><span class="line"><span class="keyword">long</span> status = redisService.setnx(key,<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(status == <span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//设置key的生存时间</span></span><br><span class="line">  redisService.expire(key,expire);</span><br><span class="line">  <span class="comment">//执行独占资源逻辑</span></span><br><span class="line">  doOcuppiedWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点：原子性得不到满足</strong></p><h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><p><code>SET key value [EX seconds][PX milliseconds][NX|XX]</code></p><ul><li>EX seconds :设置键的过期时间为second秒</li><li>PX milliseconds： 设置键的过期时间为milliseconds毫秒</li><li>NX:只在键不存在时，才对键进行设置操作</li><li>XX:只在键已经存在时，才对键进行设置操作</li><li>SET操作成功完成时，返回OK,否则返回nil</li></ul><p><strong>该方案二的伪代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RedisService redisService = SpringUtils.getBean(RedisService.class);</span><br><span class="line">String result = redisService.set(localKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"OK"</span>.equals(result))&#123;</span><br><span class="line">  <span class="comment">//执行独占资源逻辑</span></span><br><span class="line">  doOcuppiedWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>大量的key同时过期的注意事项</h4><p><strong>集中过期，由于清除大量的key很耗时，会出现短暂的卡顿现象</strong></p><ul><li>解决方案：在设置key的过期时间的时候，给每个key加上随机值</li></ul><h3>问题3:如何使用Redis做异步队列</h3><p><strong>方案一 </strong></p><p>使用<code>List</code>做队列，<code>RPUSH</code>生产消息，<code>LPOP</code>消费消息</p><ul><li>缺点：没有等待队列里有值就直接消费</li><li>弥补：可以在应用层引入<code>Sleep</code>机制去调用<code>LPOP</code>重试</li></ul><p><strong>方案二</strong></p><p><code>BLPOP key[key...] timeout</code>:阻塞直到消息队列有消息或者超时</p><ul><li>缺点：只能供一个消费者消费</li></ul><p><strong>方案三</strong></p><p><code>PUB/SUB</code> :主题订阅者模式</p><p><img src="https://i.postimg.cc/KjDWk3RC/WX20190512-011155-2x.png" alt></p><ul><li><p>发送者（<code>PUB</code>）发送消息，订阅者（<code>SUB</code>）接收消息</p></li><li><p>订阅者可以订阅任意数量的频道</p></li><li><p>缺点：消息的发布是无状态的，无法保证可达（需要专业的消息队列如<code>kafka</code>)</p></li></ul><h3>问题4:Redis如何做持久化</h3><p><strong>方案一</strong></p><p><strong>RDB（快照）持久化：保存某个时间点的全量数据快照</strong></p><ul><li><code>SAVE</code>: 阻塞Redis的服务器进程，直到RDB文件被创建完毕</li><li><strong><code>BGSAVE</code>: <code>FORK</code>出一个子进程来创建RDB文件，不阻塞服务器进程</strong></li></ul><p><strong><code>RDB</code>持久化缺点：</strong> </p><ul><li>内存数据的全量同步，数据量大会由于<code>I/O</code>而严重影响性能</li><li>可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据</li></ul><p><strong>方案二</strong></p><p><strong>AOF(<code>Append-only- File</code>)持久化：保存写状态</strong></p><ul><li>记录下除了查询以外的所有变更数据数据库状态的指令</li><li>以append的形式追加保存到AOF文件中（增量）</li></ul><h3>问题5:使用Pipeline的好处</h3><ul><li><code>Pipeline</code>和Linux的管道类似</li><li>Redis基于请求/响应模型，单个请求处理需要一一应答</li><li><code>Pipeline</code>批量执行指令，节省多次I/O往返时间</li><li>有顺序依赖的指令建议分批发送</li></ul><h3>问题6:Redis的同步机制</h3><p><a href="https://postimg.cc/9wFfG847" target="_blank" rel="noopener"><img src="https://i.postimg.cc/mk7FWKB8/image.png" alt="image.png"></a></p><p><strong>全同步原理</strong></p><ol><li>Salve发送sync命令到Master</li><li>Master启动一个后台进程，将redis中的数据快照保存到文件中</li><li>Master将保存数据快照期间接收到的写命令缓存起来</li><li>Master完成文件写操作后，将该文件发送给Slav e</li><li>使用新的AOF文件替换掉旧的AOF文件</li><li>Master将这期间收集的增量写命令发送给Slave端</li></ol><p><strong>增量同步机制</strong></p><ol><li>Master接收到用户的操作指令，判断是否需要传播到Slave</li><li>将操作记录追加到AOF文件</li><li>将操作传播到其他Slave: 1、对齐主从库；2、往响应缓存写入指令</li><li>将缓存中的数据发送给Slave</li></ol><p><strong>Redis Sentinel</strong></p><p><strong>解决主从同步Master宕机后的主从切换问题</strong></p><ul><li>监控：检查主从服务器是否运行正常</li><li>提醒：通过API向管理员或者其他应用程序发送故障通知</li><li>自动故障迁移：主从切换</li></ul><p><strong>流言协议Gossip</strong></p><blockquote><p>在杂乱无章中寻求一致</p></blockquote><ul><li>每个节点都随机地与对方通信，最终所有节点的状态达成一致</li><li>种子节点定期随机向其他节点发送节点列表以及需要传播的消息</li><li>不保证信息一定会传递给所有节点，但是最终会趋于一致</li></ul><h3>Redis的集群原理</h3><p><strong>如何从海量数据里快速找到所需</strong></p><ul><li>分片：按照某种规则去划分数据，分散存储在多个节点上</li><li>常规的按照哈希划分无法实现节点的动态增减</li></ul><p><strong>一致性哈希算法</strong></p><ol><li><p>对2^32取模，将哈希值空间组织成虚拟的圆环</p></li><li><p>将数据key使用相同的函数Hash计算出哈希值</p><p><img src="https://i.postimg.cc/7YQRzk9d/WX20190515-210010-2x.png" alt></p></li><li><p>Hash环数据倾斜问题</p><p><a href="https://postimg.cc/WDwbQpnc" target="_blank" rel="noopener"><img src="https://i.postimg.cc/q79h6z6q/WX20190515-210423-2x.png" alt="WX20190515-210423-2x.png"></a></p></li><li><p>引入虚拟节点解决数据倾斜问题</p><p><a href="https://postimg.cc/hhzRmPd4" target="_blank" rel="noopener"><img src="https://i.postimg.cc/y6n1wD6R/WX20190515-210621-2x.png" alt="WX20190515-210621-2x.png"></a></p></li></ol><h3>6.JAVA底层知识</h3><p><img src="http://img0.pconline.com.cn/pconline/1303/12/3208685_java-01.jpg" alt></p><h4>6.1谈谈你对Java的理解</h4><ul><li>平台无关性（一次编译，到处运行）</li><li>GC(垃圾回收机制)</li><li>语言特性（范型、反射、lmbda表达式）</li><li>面向对象（继承、封装、多态）</li><li>类库（集合、并发库、网络库、IO、NIO）</li><li>异常处理</li></ul><h4>6.2平台无关性如何实现</h4><p><a href="https://postimg.cc/jnfGKnn2" target="_blank" rel="noopener"><img src="https://i.postimg.cc/6qbwrd9r/WX20190617-235712-2x.png" alt="WX20190617-235712-2x.png"></a></p><p><strong>为什么JVM不直接将源码解析成机器码去执行</strong></p><ul><li>准备工作：每次执行前都需要各种检查</li><li>兼容性：也可以将别的语言解析成字节码</li></ul><h4>6.3 JVM如何加载.class文件</h4><p>JVM之所以存在的原因就是<strong>屏蔽底层操作系统平台的不同，并且降低基于原生语言开发的复杂性</strong>。这里需要抓住一个重点</p><blockquote><p>JVM是一个内存中的虚拟机，JVM的存储就是内存。我们所写的类、常量、变量、方法都在内存中</p></blockquote><p>这决定着我们写的代码是否健壮，是否高效</p><p><a href="https://postimg.cc/xkYxNFJ0" target="_blank" rel="noopener"><img src="https://i.postimg.cc/R0Jj8kvn/WX20190618-000650-2x.png" alt="WX20190618-000650-2x.png"></a></p><h4>6.4什么是反射</h4><blockquote><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 </p></blockquote><p><strong>Robot.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pcakage com.interview.javabasic.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(String helloSentence)</span></span>&#123;</span><br><span class="line">    System.out.println(helloSentence + <span class="string">""</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> String <span class="title">throwHello</span><span class="params">(String tag)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"hello "</span> + tag; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReflectSample.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pcakage com.interview.javabasic.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSample</span></span>&#123;</span><br><span class="line">  Class rc = Class.forName(<span class="string">"com.interview.javabasic.reflect.Robot"</span>);</span><br><span class="line">  Robot r = (Robot)arc.newInstance();</span><br><span class="line">  System.out.println(<span class="string">"Class name is"</span> + rc.getName());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取所有的方法</span></span><br><span class="line">  Method getHello = rc.getDeclareMethod(<span class="string">"throwHello"</span>, String.class);</span><br><span class="line">  getHello.setAccessible(<span class="keyword">true</span>);  <span class="comment">//该方法是私有方法</span></span><br><span class="line">  Object str = getHello.invoke(r,<span class="string">"Bob"</span>);</span><br><span class="line">  System.out.println(<span class="string">"getHello result is"</span> + str);</span><br><span class="line">  </span><br><span class="line">  Method sayHi = rc.getMethod(<span class="string">"sayHi"</span>, String.class);</span><br><span class="line">  sayHi.invoke(r, <span class="string">"welcome"</span>);</span><br><span class="line">  </span><br><span class="line">  Field name = rc.getDeclareField(<span class="string">"name"</span>);</span><br><span class="line">  name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">  name.set(r, <span class="string">"Alice"</span>);</span><br><span class="line">  sayHi.invoke(r, <span class="string">"welcome"</span>);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>6.5谈谈ClassLoader</h4><p><img src="https://i.postimg.cc/J0qw25G0/WX20190619-231034-2x.png" alt="WX20190619-231034-2x.png"></p><p><a href="https://postimg.cc/FdBXnhDm" target="_blank" rel="noopener"><img src="https://i.postimg.cc/KjZcjzTK/WX20190619-231219-2x.png" alt="WX20190619-231219-2x.png"></a></p><p> <a href="https://postimg.cc/pyrs2fXs" target="_blank" rel="noopener"><img src="https://i.postimg.cc/zDS6FpmY/WX20190619-232415-2x.png" alt="WX20190619-232415-2x.png"></a></p><p><a href="https://postimg.cc/wtmQypGM" target="_blank" rel="noopener"><img src="https://i.postimg.cc/wBWfrx5X/WX20190619-234626-2x.png" alt="WX20190619-234626-2x.png"></a></p><p><strong>MyClassLoader.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.basic.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/6/19</span></span><br><span class="line"><span class="comment"> * Time:23:42</span></span><br><span class="line"><span class="comment"> * 自定义ClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String path, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于寻找类文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于加载类文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] loadClassData(String name)&#123;</span><br><span class="line">        name = path + name + <span class="string">".class"</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name));</span><br><span class="line">            out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((i = in.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MyClassLoaderCheck.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.basic.reflect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IDEA</span></span><br><span class="line"><span class="comment"> * author:RicardoXu</span></span><br><span class="line"><span class="comment"> * Date:2019/6/20</span></span><br><span class="line"><span class="comment"> * Time:00:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderCheck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//要扫描的class路径</span></span><br><span class="line">        String path = <span class="string">"xx/xxx/xxx"</span>;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(path,<span class="string">"myClassLoader"</span>);</span><br><span class="line">        <span class="comment">//test.class</span></span><br><span class="line">        Class c = myClassLoader.loadClass(<span class="string">"test"</span>);</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        c.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><a href="https://postimg.cc/ZCZWSSmZ" target="_blank" rel="noopener"><img src="https://i.postimg.cc/9FwZymN4/WX20190620-001931-2x.png" alt="WX20190620-001931-2x.png"></a></p><h4>6.6 ClassLoader的双亲委派机制</h4><p><a href="https://postimg.cc/fk5GwGSm" target="_blank" rel="noopener"><img src="https://i.postimg.cc/PrkTMht3/WX20190620-002428-2x.png" alt="WX20190620-002428-2x.png"></a></p><p><strong>ClassLoader.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://postimg.cc/R6PqQPh8" target="_blank" rel="noopener"><img src="https://i.postimg.cc/nrx7xgJH/WX20190620-003548-2x.png" alt="WX20190620-003548-2x.png"></a></p><h4>6.7类的加载方式</h4><ul><li>隐式加载： new</li><li>显式加载：loadClass , forName等</li></ul><p><a href="https://postimg.cc/grQqm7cP" target="_blank" rel="noopener"><img src="https://i.postimg.cc/m22dNx0h/WX20190626-213715-2x.png" alt="WX20190626-213715-2x.png"></a></p><p><a href="https://postimg.cc/hzzLF8dr" target="_blank" rel="noopener"><img src="https://i.postimg.cc/9M1J7JXv/WX20190626-214427-2x.png" alt="WX20190626-214427-2x.png"></a></p><p><strong>疑问：既然<code>forName</code>已经可以完成类的初始化了，为什么还需要<code>loadClass</code>呢？</strong></p><p>存在即合理。<code>SpringIOC</code>的<code>LazyLoading</code>（延迟加载技术） ,<code>SpringIOC</code>为了加快初始化速度，因此大量使用了延时加载技术。而使用<code>ClassLoader.loadClass</code>不需要执行类中的初始化代码，可以加快加载速度，把类的初始化工作留到实际使用这个类的时候。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt&gt;&lt;/p&gt;
&lt;h3&gt;4.Redis&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;数据类型丰富&lt;/li&gt;
&lt;li&gt;支持数据磁盘持久化存储&lt;/li&gt;
&lt;li&gt;支持主从&lt;/li&gt;
&lt;li&gt;支持分片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/sfnpFq6R/redis.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下shadowsocks 配合SwitchyOmega科学上网</title>
    <link href="http://yoursite.com/2017/11/03/Ubuntu%E4%B8%8B%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://yoursite.com/2017/11/03/Ubuntu下科学上网/</id>
    <published>2017-11-02T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.867Z</updated>
    
    <content type="html"><![CDATA[<p>最近重新装起了阔别已久的ubuntu，第一件事当然是科学上网啊。大概需要下面几步</p><h3 id="1-一个代理服务账号"><a href="#1-一个代理服务账号" class="headerlink" title="1.一个代理服务账号"></a>1.一个代理服务账号</h3><p>&nbsp;&nbsp;这里我推荐 <a href="https://jikess.org/" target="_blank" rel="noopener">jikess</a>，一个月只需要12大洋，200G代理流量，速度也很客观。自行注册购买，或者也可以先领几十M先体验下。</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/02/08/ChMkJlbKzWGIZIhdAAQNZj09ufQAALJAQMP9cYABA1-499.jpg" alt></p><a id="more"></a><h3 id="2-ubuntu使用shadowsocks"><a href="#2-ubuntu使用shadowsocks" class="headerlink" title="2. ubuntu使用shadowsocks"></a>2. ubuntu使用shadowsocks</h3><p> <b>1.安装shadowsocks命令行程序，配置命令。</b></p><p> 2.安装shadowsocks GUI图形界面程序，配置。<br></p><h4 id="第一种安装shadowsocks命令行程序"><a href="#第一种安装shadowsocks命令行程序" class="headerlink" title="第一种安装shadowsocks命令行程序"></a>第一种安装shadowsocks命令行程序</h4><p>用PIP安装很简单</p><pre><code>sudo apt-get updatesudo apt-get install python-pipsudo apt-get install python-setuptools m2crypto</code></pre><p>接着安装shadowsocks</p><pre><code>pip install shadowsocks</code></pre><p>如果是ubuntu16.04 直接 (16.04 里可以直接用apt 而不用 apt-get 这是一项改进）</p><pre><code>sudo apt install shadowsocks</code></pre><p>当然你在安装时候肯定有提示需要安装一些依赖比如<code>python-setuptools m2crypto</code> ，依照提示安装然后再安装就好。也可以网上搜索有很多教程的。</p><h4>启动shadowsocks</h4><p>安装好后，在本地我们要用到sslocal ，终端输入sslocal –help 可以查看帮助，像这样</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-04%2017-03-17%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>通过帮助提示我们知道各个参数怎么配置，比如 sslocal -c 后面加上我们的json配置文件，或者像下面这样直接命令参数写上运行。</p><p>比如</p><pre><code>sslocal -s 11.22.33.44 -p 50003 -k &quot;123456&quot; -l 1080 -t 600 -m aes-256-cfb</code></pre><p> -s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加””）, -t超时默认300,-m是加密方法默认<code>aes-256-cfb</code>，</p><p> <b>为了方便我推荐直接用sslcoal -c 配置文件路径 这样的方式，简单好用。</b></p><p>我们可以在/home/{user}/ 下新建个文件shadowsocks.json  ({user}是你自己电脑上的用户名)。内容是这样：</p><pre><code>{    &quot;server&quot;:&quot;11.22.33.44&quot;,    &quot;server_port&quot;:50003,    &quot;local_port&quot;:1080,    &quot;password&quot;:&quot;123456&quot;,    &quot;timeout&quot;:600,    &quot;method&quot;:&quot;aes-256-cfb&quot;}</code></pre><p>server  你服务端的IP<br>servier_port  你服务端的端口<br>local_port  本地端口，一般默认1080<br>passwd  ss服务端设置的密码<br>timeout  超时设置 和服务端一样<br>method  加密方法 和服务端一样</p><p>确定上面的配置文件没有问题，然后我们就可以在终端输入 <code>sslocal -c /home/{user}/shadowsocks.json</code> 回车运行。如果没有问题的话，下面会是这样…</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-04%2017-11-06%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h4 id="第二种-安装图形界面"><a href="#第二种-安装图形界面" class="headerlink" title="第二种 安装图形界面"></a>第二种 安装图形界面</h4><p><b>在 Ubuntu下 通过PPA源安装，仅支持Ubuntu 14.04或更高版本。</b></p><pre><code>sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5</code></pre><p>由于是图形界面，配置和windows基本没啥差别就不赘述了。</p><p>经过上面两种方式的配置，你只是启动了sslocal 但是要上网你还需要配置下浏览器到指定到代理端口比如1080才可以正式上网。你可以去系统的代理设置按照说明设置代理，但一般是全局的，然而我们访问baidu,taobao等着些网站如果用代理就有点绕了，而且还会浪费服务器流量。我们最好配置我们的浏览器让它可以自动切换，该用代理用代理该直接连接自动直接连接。所以请看配置浏览器。</p><h3 id="3-配置浏览器（chrome"><a href="#3-配置浏览器（chrome" class="headerlink" title="3.配置浏览器（chrome)"></a>3.配置浏览器（chrome)</h3><p>我们需要给chrome安装SwitchyOmega插件，但是没有代理之前是不能从谷歌商店安装这个插件的，但是我们可以从Github上直接下载最新版 <a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases/</a> （这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。</p><p><b>上面也是我之前一直用的方法，屡试不爽。但是这次不知道为啥在拖进chrome后始终没反应，无法离线安装。于是我决定先配置全局代理，这样chrome可以直接访问谷歌商店，然后再直接在线安装SwitchyOmega，实现代理自动切换的目的。</b></p><h4>先配置全局代理</h4><p>1、安装GenPAC<br>GenPAC 是基于gfwlist的代理自动配置（Proxy Auto-config）文件生成工具，支持自定义规则。在多数情况下，我们更希望使用PAC模式的代理，让我们访问国内网站时不再先绕地球跑一圈，在Windows和Mac上的shadowsocks客户端可以轻松切换到PAC模式，而在Ubuntu上我们需要使用pac文件来设置系统代理以达到相同的效果</p><pre><code>sudo pip install genpacpip install --upgrade genpac</code></pre><p>2、使用GenPAC生成pac文件</p><pre><code>genpac -p &quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output=&quot;autoproxy.pac&quot;</code></pre><p>3、设置全局代理</p><p>点击：System settings &gt; Network &gt; Network Proxy，选择 Method 为 Automatic，设置 Configuration URL 为 autoproxy.pac 文件的路径，点击 Apply System Wide。<br>格式如：<code>file:///home/{user}/autoproxy.pac</code></p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-28-09%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>4、安装switchyOmega<br>  此时应该可以按照一定过滤规则访问外网了，但仍配置下浏览器（毕竟善始善终）</p><p>  <img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-32-26%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h4> 配置switchyOmega</h4><p>1.配置代理地址</p><p>安装好插件会自动跳到设置选项，有提示你可以跳过。左边新建情景模式-选择代理服务器-比如命名为proxy（叫什么无所谓）其他默认之后创建，之后在代理协议选择SOCKS5，地址为127.0.0.1,端口默认1080 。然后保存即应用选项。</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-35-17%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>2.设置自动切换</p><p>接着点击自动切换 ( Auto switch）上面的不用管，在按照规则列表匹配请求后面选择刚才新建的proxy，默认情景模式选择直接连接。点击应用选项保存。再往下规则列表设置选择AutoProxy 然后将这个地址(<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>) 填进去，点击下面的立即更新情景模式，会有提示更新成功！</p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/2018-01-05%2014-37-58%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p><b>点击浏览器右上角的SwitchyOmega图标，下面选择自动切换，然后打开google.com试试，其他的就不在这贴图了。</b></p><h4>至此shadowsocks搭建完成，天高任鸟飞，海阔任鱼跃。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近重新装起了阔别已久的ubuntu，第一件事当然是科学上网啊。大概需要下面几步&lt;/p&gt;
&lt;h3 id=&quot;1-一个代理服务账号&quot;&gt;&lt;a href=&quot;#1-一个代理服务账号&quot; class=&quot;headerlink&quot; title=&quot;1.一个代理服务账号&quot;&gt;&lt;/a&gt;1.一个代理服务账号&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;这里我推荐 &lt;a href=&quot;https://jikess.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jikess&lt;/a&gt;，一个月只需要12大洋，200G代理流量，速度也很客观。自行注册购买，或者也可以先领几十M先体验下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1024x768c5/g5/M00/02/08/ChMkJlbKzWGIZIhdAAQNZj09ufQAALJAQMP9cYABA1-499.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ShadowSocks" scheme="http://yoursite.com/tags/ShadowSocks/"/>
    
  </entry>
  
  <entry>
    <title>SSH整合过程中的问题</title>
    <link href="http://yoursite.com/2017/01/13/SSH%E6%95%B4%E5%90%88%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/01/13/SSH整合出现的一些异常/</id>
    <published>2017-01-12T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.866Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="首先介绍下博主的工作环境"><a href="#首先介绍下博主的工作环境" class="headerlink" title="首先介绍下博主的工作环境"></a>首先介绍下博主的工作环境</h2><p><strong></strong></p><ul><li>系统：<code>Ubuntu 16.04 LTS</code></li><li>IDE: <code>Myeclispe 2015</code></li><li>Server: <code>Myeclipse2015</code>自带的<code>Myeclipse Tomcat v7.0</code></li><li>框架版本: <code>Struts 2.1</code>  <code>Spring 4.1</code> <code>Hibernate 4.1.4</code></li></ul><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g2/M00/01/0E/Cg-4WlU4niOIChfEAAtm0dNCMiIAACHugPmzzsAC2bp782.jpg" alt></p><a id="more"></a><h2 id="先介绍下-SSH-经典架构（大神请跳过"><a href="#先介绍下-SSH-经典架构（大神请跳过" class="headerlink" title="先介绍下 SSH 经典架构（大神请跳过)"></a>先介绍下 <code>SSH</code> 经典架构（大神请跳过)</h2><p>首先，SSH不是一个框架，而是多个框架（struts+spring+hibernate）的集成，是目前较流行的一种Web应用程序开源集成框架，用于构建灵活、易于扩展的多层Web应用程序。</p><p>集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层（实体层）。</p><p>Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，控制业务跳转，利用Hibernate框架对持久层提供支持。Spring一方面作为一个轻量级的IoC容器，负责查找、定位、创建和管理对象及对象之间的依赖关系，另一方面能使Struts和Hibernate更好地工作。</p><h2 id="以下是最近做项目时遇到的一些问题"><a href="#以下是最近做项目时遇到的一些问题" class="headerlink" title="以下是最近做项目时遇到的一些问题"></a>以下是最近做项目时遇到的一些问题</h2><h3 id="1-Struts2自带的antlr-2-7-2-jar与Hibernate4-1-4自带的antlr-2-7-7-jar发生冲突"><a href="#1-Struts2自带的antlr-2-7-2-jar与Hibernate4-1-4自带的antlr-2-7-7-jar发生冲突" class="headerlink" title="1.Struts2自带的antlr-2.7.2.jar与Hibernate4.1.4自带的antlr-2.7.7.jar发生冲突"></a>1.Struts2自带的<code>antlr-2.7.2.jar</code>与Hibernate4.1.4自带的<code>antlr-2.7.7.jar</code>发生冲突</h3><p>  <strong> 报错内容如下: </strong></p><pre><code>java.lang.NoSuchMethodError: antlr.collections.AST.getLine()I</code></pre><h3 id="这是一个ssh整合的经典bug-解决方案是"><a href="#这是一个ssh整合的经典bug-解决方案是" class="headerlink" title="这是一个ssh整合的经典bug ,解决方案是:"></a>这是一个ssh整合的经典bug ,解决方案是:</h3><p>  <strong> 在Myeclipse2015中打开<code>window -&gt; perference -&gt; project libraries</code>在里面找到<code>struts2.1 Libraries-&gt; core-&gt;  antlr-2.7.2.jar</code> 点击取消勾选这个jar包， 然后点击Apply ，最后重新部署下工程就ok了</strong></p><h3 id="2-Spring事务管理出错"><a href="#2-Spring事务管理出错" class="headerlink" title="2.Spring事务管理出错"></a>2.Spring事务管理出错</h3><p>   <strong> 报错内容如下: </strong></p><pre><code>Write operations are not allowed in read-only mode (FlushMode.MANUAL): Turn your Session into FlushMode.COMMIT/AUTO or remove &apos;readOnly&apos; markerfrom transaction definition.</code></pre><p><strong> 大意是：只读模式下(FlushMode.NEVER/MANUAL)写操作不被允许：把你的Session改成FlushMode.COMMIT/AUTO或者清除事务定义中的readOnly标记。</strong></p><h3 id="解决方案是-配置Spring的事务管理"><a href="#解决方案是-配置Spring的事务管理" class="headerlink" title="解决方案是:配置Spring的事务管理"></a>解决方案是:配置Spring的事务管理</h3><p>  在applicationContext.xml中加入</p><pre><code>&lt;tx:advice id=&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;&lt;tx:attributes&gt;  &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;modify*&quot; propagation=&quot;REQUIRED&quot;    rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot; /&gt;  &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt;&lt;aop:pointcut id=&quot;daoMethod&quot; expression=&quot;execution(* com.muke.employee.daoImpl.*.*(..))&quot; /&gt;&lt;aop:advisor pointcut-ref=&quot;daoMethod&quot; advice-ref=&quot;txadvice&quot; /&gt;&lt;/aop:config&gt;</code></pre><ul><li><code>expression=&quot;execution( com.dao..(..))&quot;</code>其中第一个<em>代表返回值，第二代表daoImpl下子包，第三个代表方法名，“（..）”代表方法参数。</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;首先介绍下博主的工作环境&quot;&gt;&lt;a href=&quot;#首先介绍下博主的工作环境&quot; class=&quot;headerlink&quot; title=&quot;首先介绍下博主的工作环境&quot;&gt;&lt;/a&gt;首先介绍下博主的工作环境&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统：&lt;code&gt;Ubuntu 16.04 LTS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;IDE: &lt;code&gt;Myeclispe 2015&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Server: &lt;code&gt;Myeclipse2015&lt;/code&gt;自带的&lt;code&gt;Myeclipse Tomcat v7.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;框架版本: &lt;code&gt;Struts 2.1&lt;/code&gt;  &lt;code&gt;Spring 4.1&lt;/code&gt; &lt;code&gt;Hibernate 4.1.4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g2/M00/01/0E/Cg-4WlU4niOIChfEAAtm0dNCMiIAACHugPmzzsAC2bp782.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSH" scheme="http://yoursite.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架整合</title>
    <link href="http://yoursite.com/2017/01/10/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
    <id>http://yoursite.com/2017/01/10/SSM框架整合/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.867Z</updated>
    
    <content type="html"><![CDATA[<hr><b>这里的SSM指的是（<code>Spring-Springmvc-Mybatis</code>)三大框架</b><h4>前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;我们看招聘信息的时候，经常会看到这一点，需要具备<code>SSH</code>(<code>Struts-Spring-Hibernate</code>)框架的技能；而且在大部分教学课堂中，也会把<code>SSH</code>作为最核心的教学内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;但是，我们在实际应用中发现，<code>SpringMVC</code>可以完全替代<code>Struts</code>，配合注解的方式，编程非常快捷，而且通过restful风格定义url，让地址看起来非常优雅。<br>&nbsp;&nbsp;&nbsp;&nbsp;另外，<code>MyBatis</code>也可以替换<code>hibernate</code>，正因为<code>MyBatis</code>的半自动特点，我们程序猿可以完全掌控SQL，这会让有数据库经验的程序猿能开发出高效率的SQL语句，而且XML配置管理起来也非常方便。<br>&nbsp;&nbsp;&nbsp;&nbsp;下面我们开始进行SSM框架的整合。</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIJK4PAAfFWxl1L9IAALJAQM0wFQAB8Vz309.jpg" alt></p><a id="more"></a><p></p><h4>介绍</h4><br>在整合之前先介绍一下这三个框架，之前有了解的可以跳过.这里尽量通俗易懂的简单讲解一下。<p></p><ul><li><p>Springmvc<br>  &nbsp;&nbsp;&nbsp;&nbsp;它用于web层，相当于controller（等价于传统的servlet和struts的action），用来处理用户请求。举个例子，用户在地址栏输入<a href="http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法，（中间可能包含验证用户名和密码的业务逻辑，以及查询数据库操作，但这些都不是springmvc的职责），最终把结果返回给用户，并且返回相应的页面（当然也可以只反馈josn/xml等格式数据）。springmvc就是做前面和后面过程的活，与用户打交道！！" target="_blank" rel="noopener">http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法，（中间可能包含验证用户名和密码的业务逻辑，以及查询数据库操作，但这些都不是springmvc的职责），最终把结果返回给用户，并且返回相应的页面（当然也可以只反馈josn/xml等格式数据）。springmvc就是做前面和后面过程的活，与用户打交道！！</a></p></li><li><p>Spring<br>&nbsp;&nbsp;&nbsp;&nbsp; 太强大了，以至于我无法用一个词或一句话来概括它。但与我们平时开发接触最多的估计就是IOC容器，它可以装载bean（也就是我们Java中的类，当然也包括service dao里面的），有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。</p></li></ul><ul><li>Mybatis<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你问我它跟鼎鼎大名的Hibernate有什么区别？我只想说，他更符合我的需求。第一，它能自由控制sql，这会让有数据库经验的人编写的代码能搞提升数据库访问的效率。第二，它可以使用xml的方式来组织管理我们的sql，因为一般程序出错很多情况下是sql出错，别人接手代码后能快速找到出错地方，甚至可以优化原来写的sql。</li></ul><p></p><h4>SSM框架整合配置</h4><br>&nbsp;&nbsp;&nbsp;&nbsp;首先在Myeclipse中建立一个<code>Maven Web</code>工程。(对这步有疑问的可以看我之前的博客<a href="http://blog.pockerface.cn/2016/10/20/使用项目管理利器Maven/" target="_blank" rel="noopener">使用项目管理工具 <code>Maven</code></a>)<br>这是相应的项目目录<p></p><center><br><img src="http://7xta11.com1.z0.glb.clouddn.com/SSM.png" alt><br></center><br><strong>这里介绍下Maven目录规范下各目录的作用</strong><br><del>====</del><br><br>| 文件名           | 作用          |<br>| ————- |:————-:|<br>|src           |根目录，没什么好说的，下面有main和test |<br>|main    |主要目录，可以放java代码和一些资源文件|<br>|java    |存放我们的java代码 |<br>|resources    | 存放资源文件，譬如各种的spring，mybatis，log配置文件|<br>mapper    |存放dao中每个方法对应的sql，在这里配置，无需写daoImpl|<br>|spring        |这里当然是存放spring相关的配置文件，有dao service web三层|<br>|test    |这里是测试分支|<br>|java    |测试java代码，应遵循包名相同的原则，这个文件夹同样要使用Build Path -&gt; Use as Source Folder，这样看包结构会方便很多|<br>|resources    |没什么好说的，好像也很少用到，但这个是maven的规范|<br>webapp    |用来存放我们前端的静态资源，如jsp js css|<br>|resources    |这里的资源是指项目的静态资源，如js css images等|<br>|WEB-INF    |很重要的一个目录，外部浏览器无法访问，只有羡慕内部才能访问，可以把jsp放在这里，另外就是web.xml了。你可能有疑问了，为什么上面java中的resources里面的配置文件不妨在这里，那么是不是会被外部窃取到？你想太多了，部署时候基本上只有webapp里的会直接输出到根目录，其他都会放入WEB-INF里面，项目内部依然可以使用classpath:XXX来访问，好像IDE里可以设置部署输出目录|<br><br><strong>讲解几个必要的包，顺便讲解一下每个包的作用.</strong><br><center><br><img src="http://7xta11.com1.z0.glb.clouddn.com/SSM2.png" alt><br></center><table><thead><tr><th>包名</th><th style="text-align:center">名称</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td>dao</td><td style="text-align:center">数据访问层（接口）</td><td style="text-align:right">与数据打交道，可以是数据库操作，也可以是文件读写操作，甚至是redis缓存操作，总之与数据操作有关的都放在这里，也有人叫做dal或者数据持久层都差不多意思。为什么没有daoImpl，因为我们用的是mybatis，所以可以直接在配置文件中实现接口的每个方法。</td></tr><tr><td>entity</td><td style="text-align:center">实体类</td><td style="text-align:right">一般与数据库的表相对应，封装dao层取出来的数据为一个对象，也就是我们常说的pojo，一般只在dao层与service层之间传输</td></tr><tr><td>dto</td><td style="text-align:center">数据传输层</td><td style="text-align:right">刚学框架的人可能不明白这个有什么用，其实就是用于service层与web层之间传输，为什么不直接用entity（pojo）？其实在实际开发中发现，很多时候一个entity并不能满足我们的业务需求，可能呈现给用户的信息十分之多，这时候就有了dto，也相当于vo，记住一定不要把这个混杂在entity里面</td></tr><tr><td>service</td><td style="text-align:center">业务逻辑（接口）</td><td style="text-align:right">写我们的业务逻辑，也有人叫bll，在设计业务接口时候应该站在“使用者”的角度</td></tr><tr><td>impl</td><td style="text-align:center">业务逻辑（实现）</td><td style="text-align:right">实现我们业务接口，一般事务控制是写在这里</td></tr><tr><td>web</td><td style="text-align:center">控制器</td><td style="text-align:right">springmvc就是在这里发挥作用的，一般人叫做controller控制器，相当于struts中的action</td></tr></tbody></table><p><strong>添加依赖</strong><br>    SSM整合需要导入相应的jar包,我们使用maven来管理我们的jar，所以只需要在<code>pom.xml</code>中加入相应的依赖。如果没有使用maven的话,可以自己去官网下载相应的jar包，然后放到项目的WEB-INF/lib目录下.</p><p><b>三个主要框架版本</b></p><ul><li><code>Spring---4.3.3.RELEASE</code><ul><li><code>spring mvc ---- 4.3.3.RELEASE</code></li><li><code>mybatis ---- 3.2.5</code></li></ul></li></ul><p><b>其他</b></p><ul><li><p><code>junit ---- 4.8.1</code></p></li><li><p><code>MySQL ---- 5.1.38</code></p></li><li><p><code>log4j ---- 1.2.17</code></p></li><li><p><code>c3p0 ---- 0.9.2.1</code></p></li><li><p><code>mybatis-spring ---- 1.3.0</code>  </p></li><li><p><code>jstl ---- 1.2</code></p></li></ul><p><b>pom.xml文件如下</b></p><pre><code>  &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.fendo.ssm&lt;/groupId&gt;    &lt;artifactId&gt;fendo-SSM&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;fendo-SSM Maven Webapp&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;      &lt;!-- 初始化框架的版本号 --&gt;      &lt;properties&gt;          &lt;spring.version&gt;4.3.3.RELEASE&lt;/spring.version&gt;      &lt;/properties&gt;    &lt;dependencies&gt;      &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;3.8.1&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;      &lt;/dependency&gt;           &lt;!-- 加入ServletAPI --&gt;          &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;          &lt;dependency&gt;              &lt;groupId&gt;javax.servlet&lt;/groupId&gt;              &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;              &lt;version&gt;2.3&lt;/version&gt;              &lt;scope&gt;provided&lt;/scope&gt;          &lt;/dependency&gt;          &lt;!-- MySQL依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;mysql&lt;/groupId&gt;              &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;              &lt;version&gt;5.1.38&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- MySQL依赖 end --&gt;          &lt;!-- 加入MyBatis 依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.mybatis&lt;/groupId&gt;              &lt;artifactId&gt;mybatis&lt;/artifactId&gt;              &lt;version&gt;3.2.5&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 加入MyBatis 依赖 end --&gt;          &lt;!-- Log4j start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;log4j&lt;/groupId&gt;              &lt;artifactId&gt;log4j&lt;/artifactId&gt;              &lt;version&gt;1.2.17&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- Log4j end --&gt;             &lt;!-- 引入Spring(包含SpringMVC) 依赖 start --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-core&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-web&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-test&lt;/artifactId&gt;              &lt;version&gt;${spring.version}&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 引入Spring 依赖 end --&gt;          &lt;!-- 引用c3p0 依赖 start--&gt;          &lt;dependency&gt;              &lt;groupId&gt;com.mchange&lt;/groupId&gt;              &lt;artifactId&gt;c3p0&lt;/artifactId&gt;              &lt;version&gt;0.9.2.1&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- 引用c3p0 依赖 end--&gt;          &lt;!-- 引用插件依赖：MyBatis整合Spring --&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.mybatis&lt;/groupId&gt;              &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;              &lt;version&gt;1.3.0&lt;/version&gt;          &lt;/dependency&gt;          &lt;!-- JSTL --&gt;          &lt;dependency&gt;              &lt;groupId&gt;jstl&lt;/groupId&gt;              &lt;artifactId&gt;jstl&lt;/artifactId&gt;              &lt;version&gt;1.2&lt;/version&gt;          &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;      &lt;finalName&gt;fendo-SSM&lt;/finalName&gt;      &lt;plugins&gt;        &lt;!-- 加入Tomcat插件 --&gt;          &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;                  &lt;configuration&gt;                       &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt;                      &lt;username&gt;admin&lt;/username&gt;                        &lt;password&gt;admin&lt;/password&gt;                  &lt;/configuration&gt;           &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/build&gt;  &lt;/project&gt;</code></pre><p>   </p><h4>编码配置文件</h4><br>      <b>第一步：</b>我们先在spring文件夹里新建<code>spring-dao.xml</code>文件，因为spring的配置太多，我们这里分三层，分别是dao, service , web.<p></p><ol><li>读入数据库连接相关参数（可选）</li><li><p>配置数据连接池</p><ol><li>配置连接属性，可以不读配置项文件直接在这里写死</li><li>配置c3p0，只配了几个常用的</li></ol></li><li><p>配置SqlSessionFactory对象（mybatis）</p></li><li><p>扫描dao层接口，动态实现dao接口，也就是说不需要daoImpl，sql和参数都写在xml文件上</p><p><b>spring-dao.xml</b></p></li></ol><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     &quot;&gt;     &lt;context:annotation-config /&gt;    &lt;!-- 配置整合MyBatis过程 --&gt;    &lt;!-- 1.配置数据库相关参数properties的属性:${url} --&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;    &lt;!--2.数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!-- 配置连接池属性 --&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;        &lt;!-- c3p0私有属性 --&gt;        &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;&gt;&lt;/property&gt;        &lt;!-- 关闭连接后不自动commit --&gt;        &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;&gt;&lt;/property&gt;        &lt;!-- 获取连接超时时间 --&gt;        &lt;property name=&quot;checkoutTimeout&quot; value=&quot;1000&quot;&gt;&lt;/property&gt;        &lt;!-- 当获取连接失败重试次数 --&gt;        &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 3.配置sqlSessionFactory对象 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 注入数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;        &lt;!-- 配置MyBatis全局配置文件:myBatis-config.xml --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;        &lt;!-- 扫描entity包，使用别名 --&gt;        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;org.seckill.entity&quot;&gt;&lt;/property&gt;        &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!-- 注入sqlSessionFactory --&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;        &lt;!-- 给出需要扫描的Dao接口包 --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.blog.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>&nbsp;&nbsp;因为数据库配置相关参数是读取配置文件，所以在resources文件夹里新建一个jdbc.properties文件，存放我们4个最常见的数据库连接属性，这是我本地的，大家记得修改.如果大家上传github时记得删掉密码，不然别人就很容易得到你服务器的数据库配置信息.    </p><p><b>jdbc.properties</b></p><pre><code>jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://127.0.0.1\:3306/personBlogjdbc.username=rootjdbc.password=</code></pre><p><b>友情提示：</b>配置文件中的jdbc.username，如果写成username，可能会与系统环境中的username变量冲突，所以到时候真正连接数据库的时候，用户名就被替换成系统中的用户名（有得可能是administrator），那肯定是连接不成功的，这里有个小坑,需要大家注意.</p><p>这里用到了mybatis,所以接下来需要配置mybatis核心文件,在<code>resources</code>文件夹下新建<code>mybatis-config.xml</code>文件</p> <li>  使用自增主键</li><br><li> 使用列别名</li><br> <li>   开启驼峰命名转换 create_time -&gt; createTime</li><p><b>mybatis-config.xml</b></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 配置全局属性 --&gt;    &lt;settings&gt;        &lt;!-- 使用jdbc的getGenerateKeys获取数据库自增主键 --&gt;        &lt;setting name=&quot;useGererateKeys&quot; value=&quot;true&quot; /&gt;        &lt;!-- 使用列别名替换列名 默认：true --&gt;        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt;        &lt;!-- 开启驼峰命名转换 --&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt;    &lt;/settings&gt;&lt;/configuration&gt;</code></pre><p><b>第二步:</b>刚弄好dao层，接下来到service层了。在spring文件夹里新建<code>spring-service.xml</code>文件。    </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;                 xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans             http://    www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     &quot;&gt;    &lt;!-- 扫描service包下所有使用注解的类型 --&gt;    &lt;context:component-scan base-package=&quot;com.blog.service&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 注入事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot;        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!-- 注入数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置基于注解的声明式事务 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt;</code></pre><p><b>第三步:</b>配置web层，在spring文件夹里新建spring-web.xml文件.</p><ol><li><p>开启SpringMVC注解模式，可以使用@RequestMapping，@PathVariable，@ResponseBody等</p><ol><li>对静态资源处理，如js，css，jpg等</li><li>配置jsp 显示ViewResolver，例如在controller中某个方法返回一个string类型的 “login”，实际上会返回”/WEB-INF/login.jsp”</li><li>扫描web层 @Controller</li></ol><p><b>spring-web.xml</b></p></li></ol><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd     http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd     http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.0.xsd     http://www.springframework.org/schema/mvc     http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd     &quot;&gt;    &lt;!-- 配置springMVC --&gt;    &lt;!-- 1:开启springMVC注解模式 --&gt;    &lt;!-- 简化配置： （1）自动注册DefaultAnnotationHandlerMapping,AnnotationMethodHandlerAdapter         (2)提供一系列：数据绑定，数字和日期的format @NumberFormat ,@DataTimeFormat ,xml ,json默认读写支持 --&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!-- 2.静态资源默认servlet配置        1：允许加入对静态资源的处理：js,gif,png        2:允许使用&quot;/&quot;做整体映射     --&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!--3：配置jsp 显示ViewResolver--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 4:扫描web相关的bean --&gt;    &lt;context:component-scan base-package=&quot;org.seckill.web&quot;/&gt;&lt;/beans&gt;</code></pre><p>  <b>第四步:</b>最后就是修改web.xml文件了，它在webapp的<code>WEB-INF</code>下。<br><b>web.xml</b></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;&lt;!-- maven命令创建的servlet版本较低，默认没有打开JSTL，所以更改servlet版本为3.0 --&gt;  &lt;!-- 配置DispatcherServlet --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;blog-dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- 配置springMVC需要加载的配置文件            spring-dao.xml ,spring-service.xml ,spring-web.xml            Mybatis -&gt;spring -&gt;springMVC         --&gt;         &lt;init-param&gt;             &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;             &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;         &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;blog-dispatcher&lt;/servlet-name&gt;        &lt;!-- 默认匹配所有请求 --&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>我们在项目中经常会使用到日志，所以这里还有配置日志xml，在<code>resources</code>文件夹里新建<code>logback.xml</code>文件，所给出的日志输出格式也是最基本的控制台呼出，大家有兴趣查看<code>logback官方文档</code>。</p><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;configuration debug=&quot;true&quot;&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!-- encoders are by default assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n            &lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=&quot;debug&quot;&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;&lt;/configuration&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;b&gt;这里的SSM指的是（&lt;code&gt;Spring-Springmvc-Mybatis&lt;/code&gt;)三大框架&lt;/b&gt;

&lt;h4&gt;前言&lt;/h4&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们看招聘信息的时候，经常会看到这一点，需要具备&lt;code&gt;SSH&lt;/code&gt;(&lt;code&gt;Struts-Spring-Hibernate&lt;/code&gt;)框架的技能；而且在大部分教学课堂中，也会把&lt;code&gt;SSH&lt;/code&gt;作为最核心的教学内容。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;但是，我们在实际应用中发现，&lt;code&gt;SpringMVC&lt;/code&gt;可以完全替代&lt;code&gt;Struts&lt;/code&gt;，配合注解的方式，编程非常快捷，而且通过restful风格定义url，让地址看起来非常优雅。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;另外，&lt;code&gt;MyBatis&lt;/code&gt;也可以替换&lt;code&gt;hibernate&lt;/code&gt;，正因为&lt;code&gt;MyBatis&lt;/code&gt;的半自动特点，我们程序猿可以完全掌控SQL，这会让有数据库经验的程序猿能开发出高效率的SQL语句，而且XML配置管理起来也非常方便。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下面我们开始进行SSM框架的整合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIJK4PAAfFWxl1L9IAALJAQM0wFQAB8Vz309.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb三大框架之Hibernate初识</title>
    <link href="http://yoursite.com/2017/01/01/JavaWeb%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8BHibernate%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2017/01/01/JavaWeb三大框架之Hibernate初识/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2019-05-08T14:23:10.865Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>ORM</strong><br>    <code>ORM (Object / Relationship Mapping)</code> : 对象/关系映射<br>    </p><p>它的好处是使让习惯于面向对象编程的开发人员少写于底层数据库有关的<code>sql</code>语句，方便了程序的维护与修改，及跨平台性。</p><p></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/0A/ChMkJ1bKzzSIOgDcAAj_4khgui4AALJSwDm3zIACP_6935.jpg" alt></p><a id="more"></a><hr><p><strong>Hibernate</strong><br>    <code>Hibernate</code>就是<code>Java</code>中一种成熟的基于<code>ORM</code>的框架</p><hr><p><strong>Hibernate开发的基本步骤</strong></p><ol><li>编写配置文档 <code>hibernate.cfg.xml</code></li><li>编写实体类 (需要遵循<code>JavaBean</code>的设计规范)</li><li>生成对应实体类的映射文件（如 <code>Student</code>类的映射文件<code>Student.hbm.xml</code>)并添加到配置文档<code>hibernate.cfg.xml</code>中 </li><li>调用<code>Hibernate API</code>进行测试</li></ol><hr><p><strong>Session</strong></p><p><code>Hibernate</code>对数据库的操作都需要使用到<code>Session</code>对象，就类似于<code>JDBC</code>开发中的<code>Connection</code>对象。本质上讲<code>Hibernate</code>操作数据库，就是通过调用<code>Session</code>对象的各种函数实现的。</p><p>单表操作的常用方法：<code>save . delete .  update .  get / load</code>对应相应的<code>增删查改</code></p><p>其中查询方法<code>get</code>与<code>load</code>的主要区别在于：<code>get</code>在使用的时候立即发送<code>sql</code>语句，且获得的就是实体类的对象类型。而<code>load</code>是在使用到对象的非主键属性时才会发送sql语句，且它返回的是一个代理对象.</p><pre><code>Writren on 6.April.2016 Rainday</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;ORM&lt;/strong&gt;&lt;br&gt;    &lt;code&gt;ORM (Object / Relationship Mapping)&lt;/code&gt; : 对象/关系映射&lt;br&gt;    &lt;/p&gt;&lt;p&gt;它的好处是使让习惯于面向对象编程的开发人员少写于底层数据库有关的&lt;code&gt;sql&lt;/code&gt;语句，方便了程序的维护与修改，及跨平台性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/0A/ChMkJ1bKzzSIOgDcAAj_4khgui4AALJSwDm3zIACP_6935.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate" scheme="http://yoursite.com/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 笔记</title>
    <link href="http://yoursite.com/2016/12/20/Mysql%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/12/20/Mysql笔记/</id>
    <published>2016-12-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.866Z</updated>
    
    <content type="html"><![CDATA[<h4>外键(foreign key)</h4><p>定义:如果一个实体的某个字段指向另一个实体的主键,这个字段就是这个实体的外键.</p><p>&nbsp;&nbsp;被指向的实体，称之为主实体(主表),也叫父实体(父表).<br>&nbsp;&nbsp;负责指向的实体，称之为从实体(从表),也叫子实体(子表).</p><center><br><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIGD1xAAlbi8UmgHEAALJAQMblhoACVuj729.jpg" alt><br></center> <a id="more"></a><h4>一 : 外键约束</h4><p> MySQL通过外键约束来保证表与表之间的数据的<code>完整性</code>和<code>准确性</code>。</p> <h4>外键使用条件</h4><ul><li><p>两个表必须是InnoDB表，MyISAM表暂时不支持外键（据说以后的版本有可能支持，但至少目前不支持）</p><ul><li><p>外键列必须建立了索引，MySQL 4.1.2以后的版本在建立外键时会自动创建索引，但如果在较早的版本则需要显示建立</p></li><li><p>外键关系的两个表的列必须是数据类型相似，也就是可以相互转换类型的列，比如int和tinyint可以，而int和char则不可以</p></li></ul><p>外键的好处 : 可以使得两张表关联，保证数据的一致性和实现一些级联操作.</p><h4>创建外键语法:</h4><p>  [CONSTRAINT [symbol]] FOREIGN KEY<br>[index_name] (index_col_name, …)<br>REFERENCES tbl_name (index_col_name,…)<br>[ON DELETE reference_option]<br>[ON UPDATE reference_option]</p></li></ul><p>例如:</p><pre><code>&lt;!--Blog表  子表--&gt;   CREATE TABLE `t_blog` (  `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &apos;博客类型&apos;,  `title` VARCHAR(200) NOT NULL COMMENT &apos;博客题目&apos;,  `summary` VARCHAR(400) DEFAULT NULL COMMENT &apos;博客摘要&apos;,  `releaseDate` DATETIME DEFAULT NULL COMMENT &apos;发布日期&apos;,  `clickHit` INT(11) DEFAULT NULL COMMENT &apos;评论次数&apos;,  `replyHit` INT(11) DEFAULT NULL COMMENT &apos;回复次数&apos;,  `content` TEXT COMMENT &apos;博客内容&apos;,  `keyWord` VARCHAR(200) DEFAULT NULL COMMENT &apos;关键字&apos;,  `type_id` INT(11) DEFAULT NULL COMMENT &apos;外键关联博客类别&apos;,  PRIMARY KEY (`id`),  KEY `type_id` (`type_id`),  CONSTRAINT `t_blog_ibfk_1` FOREIGN KEY (`type_id`) REFERENCES `t_blogtype` (`id`)   //创建外键) ENGINE=INNODB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8;&lt;!--BlogType表  父表--&gt;  CREATE TABLE `t_blogtype` (  `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &apos;博客id&apos;,  `typeName` VARCHAR(30) DEFAULT NULL COMMENT &apos;博客类别&apos;,  `orderNum` INT(11) DEFAULT NULL COMMENT &apos;博客排序&apos;,  PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;</code></pre><p><b>注意:</b></p><p>&nbsp;&nbsp;如果子表试图创建一个在父表中不存在的外键值，InnoDB会拒绝任何<code>INSERT</code>或<code>UPDATE</code>操作。如果父表试图<code>UPDATE</code>或者<code>DELETE</code>任何子表中存在或匹配的外键值，最终动作取决于外键约束定义中的<code>ON UPDATE</code>和<code>ON DELETE</code>选项。InnoDB支持5种不同的动作，如果没有指定<code>ON DELETE</code>或者<code>ON UPDATE</code>，默认的动作为<code>RESTRICT</code>:</p><ol><li><p><code>CASCADE</code>:从父表中删除或更新对应的行，同时自动的删除或更新子表中匹配的行。<code>ON DELETE CANSCADE</code>和<code>ON UPDATE CANSCADE</code>都被InnoDB所支持。</p><ol><li><p><code>SET NULL</code>: 从父表中删除或更新对应的行，同时将子表中的外键列设为空。注意，这些在外键列没有被设为NOT NULL时才有效。<code>ON DELETE SET NULL</code>和<code>ON UPDATE SET SET NULL</code>都被InnoDB所支持。</p></li><li><p><code>NO ACTION</code>: InnoDB拒绝删除或者更新父表。</p></li><li><p><code>RESTRICT</code>: 拒绝删除或者更新父表。指定RESTRICT（或者NO ACTION）和忽略<code>ON DELETE</code>或者<code>ON UPDATE</code>选项的效果是一样的。</p></li><li><p><code>SET DEFAULT</code>: InnoDB目前不支持。</p></li></ol><p><b>外键约束使用最多的两种情况：</b></p><ol><li>父表更新时子表也更新，父表删除时如果子表有匹配的项，删除失败.</li></ol></li><li><p>父表更新时子表也更新，父表删除时子表匹配的项也删除。</p><p>前一种情况，在外键定义中，我们使用<code>ON UPDATE CASCADE ON DELETE RESTRICT</code>；</p><p>后一种情况，可以使用<code>ON UPDATE CASCADE ON DELETE CASCADE</code>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4&gt;外键(foreign key)&lt;/h4&gt;

&lt;p&gt;定义:如果一个实体的某个字段指向另一个实体的主键,这个字段就是这个实体的外键.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;被指向的实体，称之为主实体(主表),也叫父实体(父表).&lt;br&gt;&amp;nbsp;&amp;nbsp;负责指向的实体，称之为从实体(从表),也叫子实体(子表).&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/08/ChMkJ1bKzWGIGD1xAAlbi8UmgHEAALJAQMblhoACVuj729.jpg&quot; alt&gt;&lt;br&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat绑定域名发布应用</title>
    <link href="http://yoursite.com/2016/10/30/tomcat%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%E5%8F%8A%E5%8F%91%E5%B8%83%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/10/30/tomcat绑定域名及发布应用/</id>
    <published>2016-10-30T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<hr><p><b>我们使用<code>Tomcat</code>发布应用时，默认是绑定在<code>8080</code>端口，这种情况一般在测试后使用。如果应用需要部署到服务器上则需要修改端口为<code>80</code>，并通过域名直接访问。具体如何做呢？<br></b></p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/ChMkJ1cghZGIbfOAAARV4Pwpv4QAAQsDQJ9YssABFX4485.jpg" alt></p><h4 id="打包应用为war"><a href="#打包应用为war" class="headerlink" title="打包应用为war"></a>打包应用为war</h4><p><b>首先打包应用为.war文件，具体步骤为在<code>Myeclipse</code>中点击<code>File-&gt;Export</code>选择<code>web-&gt;war file</code>下一步之后选择要打包的应用，重命名为发布名称，比如<code>test.war</code>确定之后即打包。</b></p><a id="more"></a><p><b>我们把War包传到主机上去，放到Tomcat的webapps下，启动tomcat的startup.bat，会自动解压项目；到了这里，还不够。我们只能通过 <a href="http://外网IP:8080/项目名称访问；" target="_blank" rel="noopener">http://外网IP:8080/项目名称访问；</a> (<a href="http://外网IP:8080/项目名称访问；" target="_blank" rel="noopener">http://外网IP:8080/项目名称访问；</a>)</b></p><p><strong>我们现在要干两个事情，第一个是去掉端口，第二个是去掉项目名称。</strong></p><h4 id="配置容器"><a href="#配置容器" class="headerlink" title="配置容器"></a>配置容器</h4><h4>1.这里是在本地调试时的修改，真正部署可以跳过这段，看下个段落</h4><p>修改tomcat安装目录下的conf下的server.xml</p><blockquote><p>找到Connector节点，将其port改为80后保存，结果如下：</p></blockquote><pre><code>&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;        connectionTimeout=&quot;20000&quot;        redirectPort=&quot;8443&quot; /&gt;</code></pre><blockquote><p>绑定域名</p></blockquote><p>这里博主假设域名是<code>testphoto.com</code><em>(注意域名没有大小写之分，就算是大写也会被浏览器解析成小写)</em> 要绑定的项目时WebPhoto</p><p><b>1.首先因为是在本地访问该域名，所以需要修改Hosts文件，ubuntu系统下修改/<code>etc/hosts</code>加上一条记录</b></p><pre><code>127.0.0.1      testphoto.com</code></pre><p><b>2.之后修改server.xml文件</b></p><p>  找到 Engine节点,在里面添加一个 Host 节点，Engine其中有一个默认的<code>Hostname=&quot;localhost&quot;</code>的Host 节点，增添的Host节点:</p><pre><code>&lt;Host name=&quot;testphoto.com&quot;   appBase=&quot;webapps&quot;      unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;&lt;/Host&gt;</code></pre><p>此时在启动tomcat后，输入绑定的域名<code>testphoto.com</code>就可以看到tomcat了，但是要访问我们的项目，还是要在后面加上项目名称，<br>如<code>testphoto.com/WebPhoto</code></p><p><b>3.绑定项目到域名</b></p><p>  在第二步的基础上，在<host>节点中加入下面的配置</host></p><pre><code>&lt;Context path=&quot;/&quot; docBase=&quot;/opt/tomcat7/webapps/WebPhoto&quot;&gt;&lt;/Context&gt;</code></pre><p>  <code>docBase</code>是你的应用的绝对路径。</p><h4 id="此时通过testphoto-com就可以访问你的页面了"><a href="#此时通过testphoto-com就可以访问你的页面了" class="headerlink" title="此时通过testphoto.com就可以访问你的页面了"></a>此时通过<code>testphoto.com</code>就可以访问你的页面了</h4><p><img src="http://7xta11.com1.z0.glb.clouddn.com/1.png" alt></p><h4>2.真正部署应用到网上的配置</h4><p>  和在本地调试配置步骤一样，只不过这里是在服务器上配置。</p><blockquote><p>修改端口，改成80端口</p></blockquote><pre><code>&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;        connectionTimeout=&quot;20000&quot;        redirectPort=&quot;8443&quot; /&gt;</code></pre><blockquote><p>绑定域名</p></blockquote><pre><code>&lt;Host name=&quot;top.pockerface.cn&quot;  appBase=&quot;webapps&quot;        unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;&lt;Context path=&quot;/&quot; docBase=&quot;/opt/tomcat7/webapps/WebPhoto&quot;&gt;&lt;/Context&gt;&lt;/Host&gt;</code></pre><p><b>这里的<code>top.pockerface.cn</code>是博主的二级域名，需要在DNS解析中，解析域名指向你的服务器。</b></p><h4 id="此时通过top-pockerface-cn就可以访问你的页面了"><a href="#此时通过top-pockerface-cn就可以访问你的页面了" class="headerlink" title="此时通过top.pockerface.cn就可以访问你的页面了"></a>此时通过<code>top.pockerface.cn</code>就可以访问你的页面了</h4><p><img src="http://7xta11.com1.z0.glb.clouddn.com/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;b&gt;我们使用&lt;code&gt;Tomcat&lt;/code&gt;发布应用时，默认是绑定在&lt;code&gt;8080&lt;/code&gt;端口，这种情况一般在测试后使用。如果应用需要部署到服务器上则需要修改端口为&lt;code&gt;80&lt;/code&gt;，并通过域名直接访问。具体如何做呢？&lt;br&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xta11.com1.z0.glb.clouddn.com/ChMkJ1cghZGIbfOAAARV4Pwpv4QAAQsDQJ9YssABFX4485.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;打包应用为war&quot;&gt;&lt;a href=&quot;#打包应用为war&quot; class=&quot;headerlink&quot; title=&quot;打包应用为war&quot;&gt;&lt;/a&gt;打包应用为war&lt;/h4&gt;&lt;p&gt;&lt;b&gt;首先打包应用为.war文件，具体步骤为在&lt;code&gt;Myeclipse&lt;/code&gt;中点击&lt;code&gt;File-&amp;gt;Export&lt;/code&gt;选择&lt;code&gt;web-&amp;gt;war file&lt;/code&gt;下一步之后选择要打包的应用，重命名为发布名称，比如&lt;code&gt;test.war&lt;/code&gt;确定之后即打包。&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>解决Ubuntu下搜狗输入法无法输入中文问题</title>
    <link href="http://yoursite.com/2016/10/20/%E8%A7%A3%E5%86%B3ubuntu%E4%B8%8B%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/10/20/解决ubuntu下搜狗输入法无法输入中文问题/</id>
    <published>2016-10-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<h1>解决ubuntu16.04下搜狗输入法无法输入中文问题</h1><p>今天打开电脑,突然发现一直正常使用的搜狗输入法无法无法输入中文(<b>具体现象是，可以呼出搜狗输入法界面，但是候选词列表无显示</b>).在查阅了别人的博客后解决了这个问题，下面是解决方案.</p><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/0D/06/ChMkJ1ojqAGISeb1AAexeXbMtcgAAiwQAPGnzMAB7GR200.jpg" alt></p><a id="more"></a><p>我的版本号:</p><ul><li>OS：<code>Ubuntu16.04LST</code></li><li>搜狗版本:<code>sogoupinyin_2.1.0.0082_amd64.deb</code><br><center><br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1490240967&amp;di=a8c79abaa880c6efe8cd7a471576e4b1&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fwww.xiazaizhijia.com%2Fuploads%2Fallimg%2F140217%2F36-14021GAA2615.png" alt></center></li></ul><p></p><p></p><h3>方法一:</h3><br>重启搜狗输入法,看是否有效<p></p><pre><code>~$ killall fcitx~$ killall sogou-qinpanel~$ fcitx</code></pre><p></p><h3>方法二：检查修复安装依赖</h3><br>我本机依赖完好,所以应该不是依赖的问题。但如果刚安装搜狗无法使用,可以尝试下修复依赖.<p></p><pre><code>~$ sudo apt  install -f</code></pre><p></p><h3>方法三:删除配置文件,重启搜狗</h3><br>ubuntu下搜狗配置文件在~/.config下的3个文件夹内:<br>    <code>SogouPY</code>,<code>SogouPY.users</code>、<code>sogou-qimpanel</code><br>    删除这3个文件夹,之后重启.<p></p><p><b>注:我就是用这个方法解决了无法输入中文问题</b></p><p></p><h3>总结</h3><br>Linux下软件经常会因为配置问题而崩溃，最直观的现象就是无法正常使用.因此，如果Linux下正常使用的软件，突然崩溃无法使用，可以尝试删除或修改配置文件的方式尝试解决。<p></p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;解决ubuntu16.04下搜狗输入法无法输入中文问题&lt;/h1&gt;

&lt;p&gt;今天打开电脑,突然发现一直正常使用的搜狗输入法无法无法输入中文(&lt;b&gt;具体现象是，可以呼出搜狗输入法界面，但是候选词列表无显示&lt;/b&gt;).在查阅了别人的博客后解决了这个问题，下面是解决方案.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/0D/06/ChMkJ1ojqAGISeb1AAexeXbMtcgAAiwQAPGnzMAB7GR200.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ngrok神器映射外网</title>
    <link href="http://yoursite.com/2016/09/20/%E7%A5%9E%E5%99%A8Ngrok%E6%98%A0%E5%B0%84%E5%A4%96%E7%BD%91/"/>
    <id>http://yoursite.com/2016/09/20/神器Ngrok映射外网/</id>
    <published>2016-09-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<p><b>ngrok 服务可以分配给你一个域名让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API (比如微信公众号，企业号的开发) </b></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJ1lkKOSIMAebABMY8g_U_F0AAeWIQDF5hoAExkK642.jpg"></p><a id="more"></a><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ul><li>下载linux版本的客户端，解压到你喜欢的目录,注意：要给ngrok文件的可执行权限<a href="http://pan.baidu.com/s/1jG4fEGu" target="_blank" rel="noopener">Ubuntu 64 位下载地址</a></li></ul><ul><li>在命令行下进入到<code>path/to/linux_amd64/</code>下</li><li>执行 <code>./ngrok -config=ngrok.cfg -subdomain xxx 8080</code> //(<code>xxx</code> 是你自定义的域名前缀，<code>8080</code>是你本机服务器对应的端口，由于我用的是<code>Apache Tomcat 7</code>所以端口是<code>8080</code>)</li><li>如果开启成功 你就可以使用 <code>xxx.tunnel.qydev.com</code> 来访问你本机的 <code>127.0.0.1:80</code> 的服务啦</li><li>如果你自己有顶级域名，想通过自己的域名来访问本机的项目，那么先将自己的顶级域名解析到<code>123.57.165.240</code> (域名需要已备案哦),然后执行<code>./ngrok -config=ngrok.cfg -hostname xxx.xxx.xxx 8080</code> //(xxx.xxx.xxx是你自定义的顶级域名)</li><li>如果开启成功 你就可以使用你的顶级域名来访问你本机的 <code>127.0.0.1:8080</code> 的服务啦</li></ul><p><b>参考文献:<a href="http://qydev.com/#" target="_blank" rel="noopener">http://qydev.com/#</a></b></p><pre><code>Writen on 11.Apri.2016</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;ngrok 服务可以分配给你一个域名让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API (比如微信公众号，企业号的开发) &lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJ1lkKOSIMAebABMY8g_U_F0AAeWIQDF5hoAExkK642.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ngrok" scheme="http://yoursite.com/tags/Ngrok/"/>
    
  </entry>
  
  <entry>
    <title>Git使用ssh密钥</title>
    <link href="http://yoursite.com/2016/09/13/Git%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5/"/>
    <id>http://yoursite.com/2016/09/13/Git使用ssh密钥/</id>
    <published>2016-09-13T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJllkKMeIJ6CSAAdGdB9XHNIAAeWIAJf87AAB0aM436.jpg" alt></p><a id="more"></a><hr><p><b><br>git使用https协议，每次pull, push都要输入密码，相当的烦。<br>使用git协议，然后使用ssh密钥。这样可以省去每次都输密码。<br></b></p><hr><p>大概需要三个步骤：</p><ol><li>本地生成密钥对；</li><li>设置github上的公钥；</li><li>修改git的remote url为git协议。</li></ol><hr><h2 id="详细讲解第3部分"><a href="#详细讲解第3部分" class="headerlink" title="详细讲解第3部分"></a>详细讲解第3部分</h2><p>修改你本地的ssh remote url. 不用https协议，改用git 协议</p><p>可以用<code>git remote -v</code>查看你当前的<code>remote url</code></p><pre><code>$ git remote -vorigin    https://github.com/Helloxyw/Helloxyw.github.io.git (fetch)origin    https://github.com/Helloxyw/Helloxyw.github.io.git (push)</code></pre><p>可以看到是使用https协议进行访问的。</p><p>你可以使用浏览器登陆你的github，在上面可以看到你的ssh协议相应的url。类似如下：</p><pre><code>git@github.com:someaccount/someproject.git</code></pre><p>这时，你可以使用<code>git remote set-url</code> 来调整你的<code>url</code>。</p><pre><code>git remote set-url origin git@github.com:someaccount/someproject.git</code></pre><p>完了之后，你便可以再用<code>git remote -v</code> 查看一下。<br>    $ git remote -v<br>    origin    git@github.com:Helloxyw/Helloxyw.github.io.git (fetch)<br>    origin    git@github.com:Helloxyw/Helloxyw.github.io.git (push)</p><p> 至此，OK。</p><p>你可以用<code>git fetch, git pull , git push</code>， 现在进行远程操作，应该就不需要输入密码那么烦了。</p><pre><code>Writhen On 18-Apr-2016 By Ricardo Xu</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1440x900c5/g5/M00/06/0B/ChMkJllkKMeIJ6CSAAdGdB9XHNIAAeWIAJf87AAB0aM436.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>高并发秒杀项目</title>
    <link href="http://yoursite.com/2016/04/20/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2016/04/20/高并发秒杀项目/</id>
    <published>2016-04-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-springmvc-Mybatis"><a href="#spring-springmvc-Mybatis" class="headerlink" title="spring-springmvc-Mybatis"></a>spring-springmvc-Mybatis</h1><h3>SSM整合实现Java高并发秒杀</h3><p><strong> 选择使用<code>springmvc</code> + <code>spring</code> +<code>mybatis</code>三大框架原因是:</strong></p><ul><li>轻量</li><li>易使用</li></ul><p><strong>主要使用到的技术：</strong></p><p><img src="http://7xta11.com1.z0.glb.clouddn.com/mybatis-spring.png" alt></p><a id="more"></a><h4>Mysql</h4><ul><li>表设计</li><li>SQL技巧</li><li>事务和行级锁</li></ul><h4>MyBatis</h4><ul><li>DAO层设计开发</li><li>MyBatis全程使用</li><li>MyBatis与Spring整合</li><li>推荐XML配置Sql</li></ul><h4>Spring</h4><ul><li>IOC整合Service</li><li>声明式事务运用</li></ul><p></p><h4>Spring MVC</h4><p></p><ul><li>Restful接口设计使用</li><li>框架运作流程</li><li>Controller开发技巧</li></ul><p></p><h4>前端</h4><p></p><ul><li>交互设计</li><li>Bootstrap</li><li>jQuery</li></ul><h3 id="所用到的包的依赖-pom-xml文件"><a href="#所用到的包的依赖-pom-xml文件" class="headerlink" title="所用到的包的依赖(pom.xml文件)"></a>所用到的包的依赖(pom.xml文件)</h3><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.seckill&lt;/groupId&gt;    &lt;artifactId&gt;seckill&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;name&gt;seckill Maven Webapp&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;dependencies&gt;        &lt;!-- 补全项目依赖 --&gt;        &lt;!-- 使用junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.11&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- 1:日志 java日志： slf4j,log4j,logback,common-logging slf4j是规范/接口 日志实现：log4j,logback,common-logging            使用:slf4j + logback --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;1.7.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-core&lt;/artifactId&gt;            &lt;version&gt;1.1.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;1.1.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 数据库相关依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.35&lt;/version&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;c3p0&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- DAO框架：Mybatis依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.2.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Servlet web 依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;taglibs&lt;/groupId&gt;            &lt;artifactId&gt;standard&lt;/artifactId&gt;            &lt;version&gt;1.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jstl&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;            &lt;version&gt;2.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;            &lt;version&gt;2.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Spring 依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Spring dao层依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Spring web依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;4.2.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc-portlet&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring test依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;4.2.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- redis客户端:Jedis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;redis.clients&lt;/groupId&gt;            &lt;artifactId&gt;jedis&lt;/artifactId&gt;            &lt;version&gt;2.7.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- protostuff序列化依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;            &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt;            &lt;version&gt;1.0.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;            &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;            &lt;version&gt;1.0.8&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;seckill&lt;/finalName&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spring-springmvc-Mybatis&quot;&gt;&lt;a href=&quot;#spring-springmvc-Mybatis&quot; class=&quot;headerlink&quot; title=&quot;spring-springmvc-Mybatis&quot;&gt;&lt;/a&gt;spring-springmvc-Mybatis&lt;/h1&gt;&lt;h3&gt;SSM整合实现Java高并发秒杀&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt; 选择使用&lt;code&gt;springmvc&lt;/code&gt; + &lt;code&gt;spring&lt;/code&gt; +&lt;code&gt;mybatis&lt;/code&gt;三大框架原因是:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轻量&lt;/li&gt;
&lt;li&gt;易使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;主要使用到的技术：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xta11.com1.z0.glb.clouddn.com/mybatis-spring.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下安装java</title>
    <link href="http://yoursite.com/2015/09/20/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85jdk%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/09/20/Ubuntu下安装jdk两种方式/</id>
    <published>2015-09-20T11:59:53.000Z</published>
    <updated>2019-05-08T14:23:10.867Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-通过ppa-源-方式安装"><a href="#1-通过ppa-源-方式安装" class="headerlink" title="1.通过ppa(源) 方式安装."></a>1.通过ppa(源) 方式安装.</h3><p><b>这里推荐第1种,因为可以通过 <code>apt-get upgrade</code> 方式方便获得jdk的升级</b></p><h4>在我们继续了解如何安装Java之前，让我们快速地了解<code>JRE、OpenJDK</code>和<code>Oracle JDK</code>之间的不同之处。</h4><p><img src="https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/04/ChMkJlpZZLeIGFB8AATf7vf_nYQAAkD4wFg_xEABOAG369.jpg"><br><a id="more"></a></p><h4><code>JRE（Java Runtime Environment）</code>，它是你运行一个基于Java语言应用程序的所正常需要的环境。如果你不是一个程序员的话，这些足够你的需要。</h4><h4>JDK代表Java开发工具包，如果你想做一些有关Java的开发（阅读程序），这正是你所需要的。</h4><h4>OpenJDK是Java开发工具包的开源实现，Oracle JDK是Java开发工具包的官方Oracle版本。尽管OpenJDK已经足够满足大多数的案例，但是许多程序比如Android Studio建议使用Oracle JDK，以避免UI/性能问题。</h4><h3 id="检查Java是否已经安装在Ubuntu上"><a href="#检查Java是否已经安装在Ubuntu上" class="headerlink" title="检查Java是否已经安装在Ubuntu上"></a>检查Java是否已经安装在Ubuntu上</h3><p><strong>打开终端输入命令：</strong></p><pre><code>java -version</code></pre><p><strong>如果有看到类似以下的输出，则表明你的电脑上已经安装好了JDK，否则就是没有安装：</strong></p><pre><code>java version &quot;1.8.0_73&quot;Java(TM) SE Runtime Environment (build 1.8.0_73-b02)Java HotSpot(TM) 64-Bit Server VM (build 25.73-b02, mixed mode)</code></pre><p><strong>安装Oracle JDK</strong></p><pre><code>sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installer</code></pre><p><strong>    设置 Java 8 环境变量：</strong></p><pre><code>sudo apt-get install oracle-java8-set-default</code></pre><p><strong>此时打开配置文件</strong></p><pre><code>sudo gedit ~/.bashrc</code></pre><p><strong>在打开的文本编辑器末尾换行添加如下内容：(部分内容在安装时可能已经自动配置好了)</strong></p><pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-oracleexport JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH</code></pre><p><strong>右上角保存后，在终端输入 <code>java -version</code> 或 <code>java</code> 或者<code>javac</code>回车，如果显示了版本信息或者一些帮助信息，则表示配置成功</strong></p><h3 id="2-通过官网下载安装包安装"><a href="#2-通过官网下载安装包安装" class="headerlink" title="2:通过官网下载安装包安装."></a>2:通过官网下载安装包安装.</h3><h4 id="首先去官网下载最新的jdk-8u92-linux-x64-tar-gz"><a href="#首先去官网下载最新的jdk-8u92-linux-x64-tar-gz" class="headerlink" title="首先去官网下载最新的jdk-8u92-linux-x64.tar.gz"></a>首先去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">官网</a>下载最新的<code>jdk-8u92-linux-x64.tar.gz</code></h4><h4 id="打开终端创建Java目标路径文件"><a href="#打开终端创建Java目标路径文件" class="headerlink" title="打开终端创建Java目标路径文件"></a>打开终端创建Java目标路径文件</h4><pre><code>sudo mkdir /usr/lib/jvm</code></pre><h4 id="解压jdk文件到目标文件下"><a href="#解压jdk文件到目标文件下" class="headerlink" title="解压jdk文件到目标文件下"></a>解压jdk文件到目标文件下</h4><pre><code>sudo tar -C /usr/lib/jvm -xzf (你下载的路径)/jdk-8u92-linux-x64.tar.gz</code></pre><h4 id="查看本机上是否还有java可选"><a href="#查看本机上是否还有java可选" class="headerlink" title="查看本机上是否还有java可选"></a>查看本机上是否还有java可选</h4><pre><code>sudo update-alternatives --list java</code></pre><h4 id="若显示-update-alternatives-错误-无-java-的候选项-则表示系统中没有java可选，可以进行以下步骤"><a href="#若显示-update-alternatives-错误-无-java-的候选项-则表示系统中没有java可选，可以进行以下步骤" class="headerlink" title="若显示   update-alternatives: 错误: 无 java 的候选项  则表示系统中没有java可选，可以进行以下步骤"></a>若显示   <code>update-alternatives: 错误: 无 java 的候选项</code>  则表示系统中没有java可选，可以进行以下步骤</h4><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><pre><code>sudo gedit ~/.bashrc</code></pre><h4 id="在打开的文本编辑器末尾换行添加如下内容："><a href="#在打开的文本编辑器末尾换行添加如下内容：" class="headerlink" title="在打开的文本编辑器末尾换行添加如下内容："></a>在打开的文本编辑器末尾换行添加如下内容：</h4><pre><code>export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_92   export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH</code></pre><p><strong>右上角保存后，在终端输入 <code>java -version</code> 或 <code>java</code> 或者<code>javac</code>回车，如果显示了版本信息或者一些帮助信息，则表示配置成功</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-通过ppa-源-方式安装&quot;&gt;&lt;a href=&quot;#1-通过ppa-源-方式安装&quot; class=&quot;headerlink&quot; title=&quot;1.通过ppa(源) 方式安装.&quot;&gt;&lt;/a&gt;1.通过ppa(源) 方式安装.&lt;/h3&gt;&lt;p&gt;&lt;b&gt;这里推荐第1种,因为可以通过 &lt;code&gt;apt-get upgrade&lt;/code&gt; 方式方便获得jdk的升级&lt;/b&gt;&lt;/p&gt;
&lt;h4&gt;在我们继续了解如何安装Java之前，让我们快速地了解&lt;code&gt;JRE、OpenJDK&lt;/code&gt;和&lt;code&gt;Oracle JDK&lt;/code&gt;之间的不同之处。&lt;/h4&gt;



&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1366x768c5/g5/M00/02/04/ChMkJlpZZLeIGFB8AATf7vf_nYQAAkD4wFg_xEABOAG369.jpg&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
